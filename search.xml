<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MyBatis在SpringBoot中的使用</title>
    <url>/2023/02/15/15%E5%85%AB%E8%82%A1_MyBatis/</url>
    <content><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>优秀的持久层框架，对象关系映射，将持久层数据库中的记录的属性，映射到Java的对象上,称为ORM对象关系映射。</p>
<p>ORM的实现:复杂的多表查询用XML，简单的可以用注解的方式，或者MyBatisPlus</p>
<span id="more"></span>

<h2 id="XML方式，整个使用流程"><a href="#XML方式，整个使用流程" class="headerlink" title="XML方式，整个使用流程"></a>XML方式，整个使用流程</h2><ol>
<li><p>一般同一个模块的业务写在一个mapper.xml文件中，xml文件中namespace指定映射的mapper接口，xml文件中每个sql标签的id对应mapper接口的方法;</p>
</li>
<li><p>xml文件路径要配置在application.yml文件中，每个mapper接口要中@Mapper注解，表示接口的实现类交给Spring Ioc容器管理，或者在启动类用@MapperScan指定所有mapper接口的路径，就不用每个都写@mapper注解了;</p>
</li>
<li><p>然后service层调用mapper接口的方法，就能和持久层交互了;</p>
</li>
</ol>
<h2 id="多条件查询（sql传入参数）"><a href="#多条件查询（sql传入参数）" class="headerlink" title="多条件查询（sql传入参数）"></a>多条件查询（sql传入参数）</h2><p>xml中sql传入的每个参数用#{ } 或者${ }符号传递;</p>
<blockquote>
<p>#{ } 是把传入的参数当作字符串处理;</p>
<p>${ }是通过sql拼接的方式，传入的什么就原封不动的拼接在sql中，所以要注意<strong>sql注入</strong>问题；</p>
<p>所以：</p>
<ol>
<li>如果传入的<strong>变量的值</strong>，最好用#;</li>
<li>对于一些特殊的业务，可能要传入一些非变量的部分，比如传入<strong>数据库名</strong>，<strong>表名</strong>之类的，这时候用#不行，因为给表明加引号sql语法就不对了，这时候就要用$符号了。</li>
</ol>
</blockquote>
<p>三种方式：</p>
<ol>
<li>mapper接口方法用@Param标记多个参数名（对应sql中的#{ }）</li>
<li>用Map传递参数</li>
<li>用pojo类传递参数</li>
</ol>
<p>动态sql：</p>
<p>一个sql语句不用每次都写的所有参数都要传进来，根据实际传进来的参数，动态变换sql语句。</p>
<p>常用标签： if, where , foreach</p>
<h2 id="结果处理（sql返回结果）"><a href="#结果处理（sql返回结果）" class="headerlink" title="结果处理（sql返回结果）"></a>结果处理（sql返回结果）</h2><p>返回的每条记录的接收类型：（xml中的resultType）</p>
<ol>
<li><p>用pojo类接收结果</p>
</li>
<li><p>用HashMap接收结果</p>
</li>
</ol>
<blockquote>
<p>a. 对于pojo接收，可以定义一个resultMap，把pojo的属性名和数据库字段名对应；</p>
<p>b. 用sql中的 as把返回数据规定好属性名规定好</p>
<p>c.啥也没定义就默认用返回的数据数据的字段首字母小写作为返回数据的属性名。</p>
</blockquote>
<p>多条返回记录，mapper接口中的方法返回值类型写  <code>List&lt;HashMap&gt; </code>或者<code>List&lt;Entity&gt;</code></p>
<p>List<HashMap> getUserByName(String name)</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/2023/03/02/10%E5%85%AB%E8%82%A1_IO/</url>
    <content><![CDATA[<h1 id="IO概念"><a href="#IO概念" class="headerlink" title="IO概念"></a>IO概念</h1><p>I&#x2F;O就是输入输出，指的是计算机内存空间与外部设备之间的通信过程。</p>
<p>常见的IO通信：磁盘IO[内存与磁盘],   网络IO[内存与网卡]</p>
<p>操作系统的内存空间分为：内核空间和用户空间。内核空间独立于用户进程，为操作系统内核所属。</p>
<p>涉及到资源有关的操作（如内存管理，文件管理，进程调度等）要在内核空间执行，用户进程无法访问内核空间，因此用户程序要想IO操作时，需要发起IO操作的系统调用，由操作系统内核来执行具体的IO操作。</p>
<span id="more"></span>

<img src="https://github.com/WayV5/imgs/blob/main/IO/p2.png?raw=true" alt="p2.png" style="zoom: 50%;" />

<h1 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h1><p>UNIX 系统下， IO 模型一共有 5 种：<strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p>
<blockquote>
<p>同步&#x2F;异步：在操作系统角度看，是看数据在系统内核在准备就绪之后，往用户空间拷贝的时候，用户进行是否要等待。</p>
<p>阻塞&#x2F;非阻塞：看用户进程发起系统调用后，是否需要一直阻塞等待到数据传输完成。</p>
</blockquote>
<p>用户进程进行网络IO需要经过以下步骤：</p>
<ol>
<li>用户进程向操作系统发起IO系统调用；</li>
<li>操作系统内核将网卡数据读取到内核缓冲区；</li>
<li>内核缓冲区的数据拷贝到用户缓冲区。</li>
</ol>
<img src="https://github.com/WayV5/imgs/blob/main/IO/p1.png?raw=true" alt="p1.png" style="zoom:67%;"/>

<p>图片来源：微信公众号“阿斌Java之路”</p>
<h2 id="两种套接字Socket"><a href="#两种套接字Socket" class="headerlink" title="两种套接字Socket"></a>两种套接字Socket</h2><ul>
<li>监听套接字：用于监听客户端发起TCP连接，并在三次握手成功后，生成一个连接套接字；</li>
<li>连接(通讯)套接字：用于TCP连接成功后的通讯；</li>
</ul>
<h2 id="TCP连接过程"><a href="#TCP连接过程" class="headerlink" title="TCP连接过程"></a>TCP连接过程</h2><ul>
<li><p>用户程序中的监听线程调用socket()函数（这里提到的函数都是系统调用）创建一个监听套接字，bind()函数为其绑定 &lt;地址+端口&gt;（如本机的80端口），listen()函数监听该套接字，是其成为处理tcp连接的窗口；</p>
</li>
<li><p>客户端通过connect()发起tcp连接，connect()之前自己也要socket()创建一个监听套接字</p>
</li>
<li><p>当三次握手成功，连接会进入连接已完成队列；监听线程通过accept()函数从连接已完成队列取数据，生成通讯socket，并生成fd进行绑定，工作者进程用来进行通讯。BIO的accept()是阻塞的，连接已完成队列有数据才会返回，tcp连接这个过程是在操作系统内核进行的，阻塞的也是操作系统内核。</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/IO/p4.png?raw=true" alt="p4.png"></p>
<p>感谢大佬 : <a href="https://www.cnblogs.com/f-ck-need-u/p/7623252.html">https://www.cnblogs.com/f-ck-need-u/p/7623252.html</a></p>
</li>
</ul>
<h1 id="BIO-Blocking-I-x2F-O-同步阻塞I-x2F-O"><a href="#BIO-Blocking-I-x2F-O-同步阻塞I-x2F-O" class="headerlink" title="BIO (Blocking I&#x2F;O) 同步阻塞I&#x2F;O"></a>BIO (Blocking I&#x2F;O) 同步阻塞I&#x2F;O</h1><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom: 67%;" />

<ul>
<li>监视线程调用”监听socket”的accept()来阻塞的监听tcp连接，当有tcp连接时，accept()返回生成一个通讯socket；</li>
<li>这时立刻由一个用户工作线程对其发起recv系统调用（也可能监视线程也是工作线程），去请求recv()读取数据，即使内核区数据没准备好也会一直阻塞，直到内核将数据拷贝到用户空间才返回。</li>
</ul>
<p>此时用户线程阻塞，一个线程只能处理一个请求；因此每监听到一个用户连接，就要生成一个新的工作线程去执行。</p>
<p>所以一个服务端线程只能同时处理一个请求，面对大量连接时，只能创建多个线程，开销很大。</p>
<blockquote>
<p>优点：当数据没准备好，用户线程让出CPU，进入休眠；等到数据拷贝好了，再通过中断唤醒用户线程。</p>
</blockquote>
<blockquote>
<p>缺点：对于单个线程，面对多个请求时，前面的阻塞，后面的也会阻塞，效率低，适合并发量低的场景。</p>
</blockquote>
<h1 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h1><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom: 67%;" />

<ul>
<li>通过CPU忙轮询方式来实现非阻塞，每次轮询做两件事情：</li>
</ul>
<ol>
<li>非阻塞的调用 “监听socket” 的accept()方法 ,如果accept()方法返回了结果，就是有新的连接，那就将accept()返回的通讯socket加入到集合中去；在操作系统层面就是将fd加入到fds；</li>
<li>遍历通讯socket集合，对每个连接都执行一次recv系统调用，内核区准备好数据就直接拷贝（阻塞），没准备好就返回一个错误状态信息；</li>
</ol>
<blockquote>
<p>优点：避免用户线程阻塞，一个线程能同时处理多个请求；</p>
</blockquote>
<blockquote>
<p>缺点：每次都轮询所有的fd，发生多次用户态到核心态的转换，并且对于即使没有发生IO的连接，也会进行recv系统调用，十分浪费CPU资源。</p>
</blockquote>
<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><blockquote>
<p>java中的NIO(Non-blocking&#x2F;New I&#x2F;O) 是IO多路复用模型</p>
</blockquote>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:67%;" />

<ul>
<li><p>使用单个线程作为selector监听多个客户端连接，当有一个新的tcp连接过来，就会将对应的socket注册，绑定在一个socketChannel上；在操作系统层面，会生成一个文件描述符fd，并加入到fds中；</p>
</li>
<li><p>selector线程发起select&#x2F;poll&#x2F;epoll系统调用，会进入阻塞，让操作系统内核去检查fds中是否有某个连接想要的数据在内核准备就绪了，如果有会返回，然后再调用recv去拷贝相应fd对应的内核数据到用户空间；</p>
</li>
<li><p>IO多路复用模型中，selector不仅可以监听’通讯socket’, 还可以监听 ‘监听socket’, 它能够注册多种事件（connect, accept, send, recv）；</p>
</li>
<li><p>检查到监听socket的Channel有ACCEPT事件，可以accept()出通讯socket了，同时注册到一个新的socketChannel上，并注册READ事件；这样客户端发送数据，就可以出发read事件了，同时在selector上注册该socketChannel的WRITE事件，实现服务器往客户端写数据。</p>
</li>
</ul>
<h2 id="select-x2F-poll-x2F-epoll的区别"><a href="#select-x2F-poll-x2F-epoll的区别" class="headerlink" title="select&#x2F;poll&#x2F;epoll的区别"></a>select&#x2F;poll&#x2F;epoll的区别</h2><ul>
<li><p>select的文件描述符集合fds是通过数组方式实现的，数组大小默认1024，有上限；</p>
</li>
<li><p>1先将fds从用户空间拷贝到内核空间；2内核去遍历判断是否有socket数据准备就绪，更改状态；3将fds从内核空间拷贝到用户空间；4用户线程遍历fds状态。   要两次拷贝，两次遍历。</p>
</li>
<li><p>poll和select的区别就是poll的文件描述符集合fds是通过链表实现的，没有上限，当然会受制于操作系统文件描述符上限；select和poll都需要线性遍历，时间复杂度O（n）;</p>
</li>
</ul>
<blockquote>
<p>select和poll都是通过系统内核轮询检查的，但是只进行一次系统调用；但是同步阻塞IO是用户空间轮询的，多次系统调用，多次用户态和内核态之间的转换，浪费CPU资源；</p>
</blockquote>
<ul>
<li><p>epoll内核会创建红黑树存储事件，通过事件和回调机制，只会返回有事件发生的文件描述符，</p>
</li>
<li><p>时间复杂度O（1）；epoll通过内核和 ⽤户空间共享⼀块内存来实现的，无需select的两次拷贝。</p>
</li>
<li><p>epoll是Linux特有的，而select是所有操作系统都有的。</p>
</li>
</ul>
<h1 id="AIO-Asynchronous-I-x2F-O"><a href="#AIO-Asynchronous-I-x2F-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h1><p>异步IO基于事件和回调机制，应用进程发起系统调用后，会直接得到返回结果，等系统内核从内核空间向用户空间拷贝好之后，再通知用户进程。</p>
<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2023/03/06/11%E5%85%AB%E8%82%A1_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="经典排序算法的性能"><a href="#经典排序算法的性能" class="headerlink" title="经典排序算法的性能"></a>经典排序算法的性能</h1><p><img src="https://github.com/WayV5/imgs/blob/main/%E6%8E%92%E5%BA%8F/p1.png?raw=true" alt="十大排序算法"></p>
<span id="more"></span>

<p>图片来源：<a href="http://www.guoyaohua.com/sorting.html#%E5%BC%95%E8%A8%80">http://www.guoyaohua.com/sorting.html#%E5%BC%95%E8%A8%80</a></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>每次循环把最大值挪到最后，最小值逐渐向前挪（冒泡）。</p>
<p>时间复杂度：最好O(n)，最坏O(n2)，平均O(n2);</p>
<p>空间复杂度：O(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>每次循环，选择最小的，放到前边</p>
<p>时间复杂度：最好O(n2)，最坏O(n2)，平均O(n2);</p>
<p>空间复杂度：O(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minValIdx</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minValIdx]) &#123;</span><br><span class="line">                    minValIdx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minValIdx != i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[minValIdx];</span><br><span class="line">                arr[minValIdx] = arr[i];</span><br><span class="line">                arr[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>分治思想</strong>。</p>
<p>为了避免每次递归都创建一个新数组，事先创建一个O(n)的数组，用起止坐标控制；</p>
<p>每次递归，将左右两个数组借助临时数组进行排序。【后序遍历】</p>
<p>时间复杂度：最好O(nlogn)，最坏O(nlogn)，平均O(nlogn);</p>
<p>空间复杂度：O(n);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length, temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, mid, temp);</span><br><span class="line">        mergeSort(arr, mid, right, temp);</span><br><span class="line">        merge(arr, left, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid, idx = left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[idx++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[idx++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; mid) &#123;</span><br><span class="line">            temp[idx++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right) &#123;</span><br><span class="line">            temp[idx++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt; right; k++) &#123;</span><br><span class="line">            arr[k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>分治思想</strong>。</p>
<ol>
<li>从序列中随便选取一个元素，作为基准pivot，【一般取最后一个】</li>
<li>分区操作(partition)：然基准前的元素都小于基准，基准后的元素都大于基准；</li>
<li>以基准为分界线，递归进行分区操作。【前序遍历】</li>
</ol>
<p>时间复杂度：最好O(nlogn)，最坏O(nlogn)，平均O(nlogn);</p>
<p>空间复杂度：O(logn);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">povitIdx</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, povitIdx - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, povitIdx + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[right]) &#123;</span><br><span class="line">                swap(arr, i, pointer);</span><br><span class="line">                pointer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pointer, right);</span><br><span class="line">        <span class="keyword">return</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>并不是真的用堆的数据结构，而是看作堆。升序排列用大顶堆方便操作。</p>
<ol>
<li><p>先建立起大顶堆；</p>
<blockquote>
<p>heapify()方法，将某一个节点进行大顶堆化操作；i节点的左子节点索引为2i+1,右子节点索引为2i+2，在左右节点索引没超过heapLen前提下，比较找出三个节点中最大的，变成头节点；如果交换了节点，还要递归向下heapify()。</p>
</blockquote>
<blockquote>
<p>从最后一个非叶子节点（len &#x2F; 2 - 1）开始，到头节点，每个都要执行heapify()；这算是个剪枝操作，从最后一个节点开始也可以，但是叶子节点无需heapify()，因此可剪枝。</p>
</blockquote>
</li>
<li><p>依次将堆顶与最后一个对调，然后将剩余元素再建立大顶堆，heapLen减1；</p>
</li>
</ol>
<p>时间复杂度：最好O(nlogn)，最坏O(nlogn)，平均O(nlogn);</p>
<p>空间复杂度：O(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> idx, <span class="type">int</span> heapLen)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> idx * <span class="number">2</span> + <span class="number">1</span>, right = idx * <span class="number">2</span> + <span class="number">2</span>;   <span class="comment">//左右节点下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapLen &amp;&amp; arr[left] &gt; arr[maxValIdx]) maxValIdx = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapLen &amp;&amp; arr[right] &gt; arr[maxValIdx]) maxValIdx = right;</span><br><span class="line">        <span class="keyword">if</span> (maxValIdx != idx) &#123;</span><br><span class="line">            swap(arr, idx, maxValIdx);</span><br><span class="line">            heapify(arr, maxValIdx, heapLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapBuild</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> heapLen)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;        <span class="comment">//从后往前找到第一个非叶子节点，开始树化</span></span><br><span class="line">            heapify(arr, i, heapLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapLen</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        heapBuild(arr, heapLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, i, <span class="number">0</span>);</span><br><span class="line">            heapLen--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, heapLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2022/12/30/14%E5%85%AB%E8%82%A1_%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList基于动态数组实现，当使用无参构造函数创建一个ArrayList对象时，初始化一个空数组，当第一次往里面add值得时候，数组扩容为10，之后每次当容量满的时候，扩容为原来的1.5倍。扩容时先创建一个新容量的数组，然后将原数据拷贝过去。</p>
<span id="more"></span>

<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>在JDK1.8之前，基于<strong>数组</strong>+<strong>链表</strong>实现，JDK1.8之后，基于<strong>数组</strong>+链表+<strong>红黑树</strong>；</p>
<h2 id="寻址算法"><a href="#寻址算法" class="headerlink" title="寻址算法"></a>寻址算法</h2><p>HashMap时根据key对象的hashCode进行散列的，首先要对key对象的hashCode进行一个扰动函数处理，扰动函数的目的是散列效果更好，减小哈希冲突。</p>
<blockquote>
<p>JDK1.8的扰动函数hash()      (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p>
<p>将hashCode有符号右移16位，然后和原来的hashCode异或，得到哈希值</p>
</blockquote>
<p>寻址： hash &amp; (n - 1)  n位数组长度</p>
<h2 id="为什么HashMap的数组长度要是2的整数次方？"><a href="#为什么HashMap的数组长度要是2的整数次方？" class="headerlink" title="为什么HashMap的数组长度要是2的整数次方？"></a>为什么HashMap的数组长度要是2的整数次方？</h2><p>这要从HashMap的寻址算法说起了，寻址的思想就是对key的哈希值对数组长度进行取模运算，但是计算机取模运算速度比较慢，因此HashMap用与运算来代替取模，采用hash &amp; (n - 1)的方式进行寻址，提高计算速度。</p>
<p> 这样计算的原理是：n是2的次方，那么n-1的二进制表示就都是1，和哈希值相与的话，比n大的二进制位就都变成了0，其效果和取模运算是相同的；如果数组长度不是2的整数次方，还使用这种寻址方式的话，那么n-1低位就不都是1了，与运算得到的散列效果就不会连续的了，哈希冲突概率提高。</p>
<h2 id="HashMap如何解决哈希冲突"><a href="#HashMap如何解决哈希冲突" class="headerlink" title="HashMap如何解决哈希冲突"></a>HashMap如何解决哈希冲突</h2><p>HashMap通过拉链法解决哈希冲突，如果有key寻址到数组的相同位置，那么就通过链表的方式存储后添加进来的元素。JDK1.8之前采用头插法，之后采用尾插法。</p>
<p>当链表长度大于转换阈值（默认是8）的时候，如果数组长度＞64，会优先进行扩容，如果数组长度≥64，链表会转化成红黑树；如果红黑树的节点数≤6，红黑树会退化成链表。</p>
<h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><p>通过无参构造函数new一个HashMap对象时，会创建一个空的数组，第一次put值的时候，初始化一个长度为16的数组。</p>
<p>当HashMap中的<strong>节点数量</strong>（k-v数量）＞数组长度<em>负载因子（默认为0.75）时（初始为16</em> x 0.75 &#x3D; 12），数组容量扩容为原来的2倍，并进行resize()，扩容时会创建新的数组，并对原有的链表和红黑树结构的元素数据进行重新哈希分配rehash</p>
<h2 id="为什么链表到红黑树的转化因子是8？"><a href="#为什么链表到红黑树的转化因子是8？" class="headerlink" title="为什么链表到红黑树的转化因子是8？"></a>为什么链表到红黑树的转化因子是8？</h2><p>在理想条件下，使用随机hashCode进行寻址，每个节点在桶中出现的概率是遵循泊松分布的，当我们的负载因子选用0.75时，一个桶中出现链表长度大于8的概率不超过千万分之一。</p>
<h2 id="为什么要引入红黑树"><a href="#为什么要引入红黑树" class="headerlink" title="为什么要引入红黑树"></a>为什么要引入红黑树</h2><p>因为链表的搜索时间复杂度时O（n），当链表长度过长时，搜索效率大大降低；红黑树是log(n)，但是红黑树的空间占用大（链表的2倍）；因此在节点数较少时，红黑树的搜索时间复杂度并不比链表高多少，采用链表，当节点数多时才转换成红黑树。</p>
<blockquote>
<p>红黑树：自动平衡，自动排序。</p>
</blockquote>
<h2 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h2><h3 id="Iterator迭代器—EntrySet"><a href="#Iterator迭代器—EntrySet" class="headerlink" title="Iterator迭代器—EntrySet"></a>Iterator迭代器—EntrySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">	Map.Entry&lt;Integer, Integer&gt; entry = it.next();</span><br><span class="line">	<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">	<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iterator迭代器—KeySet"><a href="#Iterator迭代器—KeySet" class="headerlink" title="Iterator迭代器—KeySet"></a>Iterator迭代器—KeySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; it = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> it.next();</span><br><span class="line">	<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> map.get(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Foreach—EntrySet"><a href="#Foreach—EntrySet" class="headerlink" title="Foreach—EntrySet"></a>Foreach—EntrySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">	<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Foreach—KeySet"><a href="#Foreach—KeySet" class="headerlink" title="Foreach—KeySet"></a>Foreach—KeySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Streams-API-单线程"><a href="#Streams-API-单线程" class="headerlink" title="Streams API 单线程"></a>Streams API 单线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Streams-API-多线程"><a href="#Streams-API-多线程" class="headerlink" title="Streams API 多线程"></a>Streams API 多线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="速度比较"><a href="#速度比较" class="headerlink" title="速度比较"></a>速度比较</h3><p>1.迭代器EntrySet 2.foreach EntrySet 3.foreach KeySey 4. 迭代器KeySet 5.Lambda 6.Streams API</p>
<p><strong><code>entrySet</code> 的性能比 <code>keySet</code> 的性能高出了一倍之多，因此我们应该尽量使用 <code>entrySet</code> 来实现 Map 集合的遍历</strong>。</p>
<h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>不能在遍历map时，通过map.remove()方法来删除元素，这是不安全的操作；但是可以用迭代器，通过迭代器的iterator.remove()来安全的删除元素。</p>
<p>同样的我们也可以使用 Lambda 中的 <code>removeIf</code> 来提前删除数据，或者是使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 <code>for</code> 循环前删除数据在遍历也是线程安全的。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>JDK1.7之前，采用Segment数组 + Entry数组 + 链表实现，segment数组中的一个位置对应一组哈希桶，Segment数组默认容量16，不可扩容，也就是最多支持16个线程并发；</p>
<blockquote>
<p>JDK1.7之前，对一组哈希桶；</p>
</blockquote>
<p>JDK1.8之后，采用Node数组 + 链表 + 红黑树的方式，对Node数组的node加锁。</p>
<blockquote>
<p>JDK1.8之后，锁的粒度更细了，对每个单独的哈希桶加锁，并发量更大。</p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的一些基本使用命令</title>
    <url>/2023/06/02/16%E5%85%AB%E8%82%A1_git/</url>
    <content><![CDATA[<h1 id="第一次-从远端拉取代码"><a href="#第一次-从远端拉取代码" class="headerlink" title="第一次 从远端拉取代码"></a>第一次 从远端拉取代码</h1><p>git clone  远端地址</p>
<span id="more"></span>

<h1 id="上班改代码之前第一件事情-先拉取代码（更新）"><a href="#上班改代码之前第一件事情-先拉取代码（更新）" class="headerlink" title="上班改代码之前第一件事情 先拉取代码（更新）"></a>上班改代码之前第一件事情 先拉取代码（更新）</h1><p>git pull</p>
<h1 id="修改自己代码"><a href="#修改自己代码" class="headerlink" title="修改自己代码"></a>修改自己代码</h1><p>  自己改代码，此时项目在本地的文件系统中有变化了。</p>
<h1 id="提交过程"><a href="#提交过程" class="headerlink" title="提交过程"></a>提交过程</h1><h2 id="查看修改了什么"><a href="#查看修改了什么" class="headerlink" title="查看修改了什么"></a>查看修改了什么</h2><p>git diff</p>
<h2 id="对修改-x2F-添加了的文件，在git版本库中进行更改"><a href="#对修改-x2F-添加了的文件，在git版本库中进行更改" class="headerlink" title="对修改&#x2F;添加了的文件，在git版本库中进行更改"></a>对修改&#x2F;添加了的文件，在git版本库中进行更改</h2><p>git add .  #点表示所有文件</p>
<p>git add abc.txt</p>
<h2 id="对删除了的文件，在git版本库中进行处理"><a href="#对删除了的文件，在git版本库中进行处理" class="headerlink" title="对删除了的文件，在git版本库中进行处理"></a>对删除了的文件，在git版本库中进行处理</h2><p>git rm efg.txt</p>
<h2 id="创建一个提交"><a href="#创建一个提交" class="headerlink" title="创建一个提交"></a>创建一个提交</h2><p>git commit -m    ‘name’      #”起个commit名字”</p>
<h2 id="再一次pull"><a href="#再一次pull" class="headerlink" title="再一次pull"></a>再一次pull</h2><p>git pull</p>
<h2 id="push到远端"><a href="#push到远端" class="headerlink" title="push到远端"></a>push到远端</h2><p>git push -u origin main</p>
<blockquote>
<p>一次push能处理多个commit</p>
</blockquote>
<h2 id="回滚commit"><a href="#回滚commit" class="headerlink" title="回滚commit"></a>回滚commit</h2><p>git reset </p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/02/08/13%E5%85%AB%E8%82%A1_Redis_mongoDB/</url>
    <content><![CDATA[<h1 id="Redis基础概念"><a href="#Redis基础概念" class="headerlink" title="Redis基础概念"></a>Redis基础概念</h1><p>Redis是一种基于内存的数据库，读写速度快，常用于缓存；他是非关系型数据库nosql，数据采用键值对关系存储。</p>
<p>采用NIO的IO多路复用模型。默认一共有16个库。redis服务进程是单线程的。</p>
<blockquote>
<p>关系型数据库:像mysql数据库，表中的每条记录都有字段关系的约束。</p>
</blockquote>
<span id="more"></span>

<h1 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>最基本的数据类型，可以存储字符串，整数，浮点数，jpg，序列化的对象等等。最大512MB</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>可以看成一个map容器，一个容器可以存储多个键值对。&lt;key,&lt;key1,value&gt;&gt;</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>双向链表结构</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序不可重复集合</p>
<h2 id="Zset-Sorted-set"><a href="#Zset-Sorted-set" class="headerlink" title="Zset(Sorted set)"></a>Zset(Sorted set)</h2><p>有序不可重复集合；每个元素有一个分数（score），默认按照分数从小到大排序</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB持久化（全量同步）（默认开启）"><a href="#RDB持久化（全量同步）（默认开启）" class="headerlink" title="RDB持久化（全量同步）（默认开启）"></a>RDB持久化（全量同步）（默认开启）</h2><p>周期性的将redis数据以snapshot形式存储到二进制文件，一般一个小时一次；</p>
<p>redis通过fork一个子线程来定时生成rdb文件，避免影响redis服务进程的执行效率。</p>
<h2 id="AOF持久化（增量同步）"><a href="#AOF持久化（增量同步）" class="headerlink" title="AOF持久化（增量同步）"></a>AOF持久化（增量同步）</h2><p>AOF文件记录的是redis的增删改操作；</p>
<p>AOF同步策略：1. 每秒同步 2.每个增删改操作同步 3.不同步</p>
<blockquote>
<ol>
<li>RDB存储的是压缩过的二进制文件，占用空间小；AOF占用空间大；因此RDB更适合做备份，并且RDB是存储的快照，恢复大量数据时速度比较快。</li>
<li>AOF文件可以做到秒级备份，安全性更高。</li>
<li>如果对于数据丢失安全性要求不高，只用RDB就行了；如果对安全性要求较高，可以RDB和AOF混用。</li>
</ol>
</blockquote>
<h1 id="Redis缓存的好处"><a href="#Redis缓存的好处" class="headerlink" title="Redis缓存的好处"></a>Redis缓存的好处</h1><p>因此磁盘的访问速度远低于内存的访问速度，常用的数据缓存到内存中，能保证系统的高可用性和并发性。</p>
<h1 id="Redis的三种缓存读写（更新）策略"><a href="#Redis的三种缓存读写（更新）策略" class="headerlink" title="Redis的三种缓存读写（更新）策略"></a>Redis的三种缓存读写（更新）策略</h1><h2 id="旁路缓存"><a href="#旁路缓存" class="headerlink" title="旁路缓存"></a>旁路缓存</h2><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-write.png" alt="img"></p>
<p><strong>读</strong>的时候：1.先到redis中读取 2.如果没有数据，就去数据库中读 并返回3. 再把数据放到redis中；</p>
<p><strong>写</strong>的时候：1.先更新数据库 2.然后直接删除缓存中对应的数据</p>
<blockquote>
<p>必须先更新db，再删除cache; 否则如果先删除cache再更新db，会造成cache和db数据不一致</p>
</blockquote>
<h2 id="读写穿透"><a href="#读写穿透" class="headerlink" title="读写穿透"></a>读写穿透</h2><p>读的时候：1.先到redis中读取 2.如果没有数据，就去数据库加载数据到redis 3.redis返回数据</p>
<p>写的时候：1.先查cache，cache不存在，直接更新db；2.如果查到cache,直接更新cache,然后由redis更新db；</p>
<h2 id="异步缓存写入"><a href="#异步缓存写入" class="headerlink" title="异步缓存写入"></a>异步缓存写入</h2><p>与读写穿透相似，都是由redis来更新db，但是这个更新是批量异步更新的。这点和mysql的批量同步机制类似。</p>
<h1 id="除了缓存Redis还能干什么"><a href="#除了缓存Redis还能干什么" class="headerlink" title="除了缓存Redis还能干什么"></a>除了缓存Redis还能干什么</h1><ol>
<li>消息队列</li>
<li>分布式锁</li>
<li>限流</li>
</ol>
<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>redis事务比较鸡肋，应用较少，不能保证原子性；且事务中的每个命令都要redis服务器进行一次交互，比较浪费网络资源。</p>
<p>为了解决redis事务的缺陷，提出了Lua脚本，可以批量的原子性的执行redis命令，减少网络开销。</p>
<p>Lua脚本在执行过程中不会有其他Lua脚本和redis执行同时执行；但是Lua脚本如果执行到一半出现崩溃，后面的不会执行，执行过的也不会回滚。</p>
<h1 id="Redis生产问题"><a href="#Redis生产问题" class="headerlink" title="Redis生产问题"></a>Redis生产问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>频繁的使用大量不存在的key进行查询，导致缓存无法命中，给数据造成很大压力。</p>
<p>解决方案：</p>
<ol>
<li>缓存无效的key【没太大用，因为黑客攻击会使用大量不同的key】</li>
<li>对客户端限流，限制请求频率。</li>
<li>布隆过滤器【将所有可能存在的请求的值都放在布隆过滤器中，请求来了之后先用布隆过滤器判断，如果请求无效，直接返回错误参数给客户端。】</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>热点key的过期问题。热key过期瞬间会有大量请求打到数据库，给数据库造成压力。</p>
<p>解决方案：</p>
<ol>
<li>设置热key永不过期，或设置一个比较长的过期时间。</li>
<li>在秒杀场景下，对热key提前预热，设置在秒杀结束之前不过期。</li>
<li>请求数据库写到缓存的这个操作，加互斥锁，保证只有一个请求到达数据库。</li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>在同一时间有大量key同时失效，导致大量请求都打到数据库上。</p>
<p>解决方法：</p>
<ol>
<li>失效时间都加一个随机值；</li>
<li>集群部署redis</li>
<li>设置所有Key永不过期【笨方法】</li>
</ol>
<h1 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h1><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>在用到key的时候，再对数据进行过期检查，删除过期数据，这样对CPU友好</p>
<h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><p>每隔一段时间对过期数据进行删除，这样对内存友好；</p>
<blockquote>
<p>redis采用 惰性删除 + 定期删除的策略</p>
</blockquote>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>如果用单点redis，那么redis挂了之后全部请求都打在db，给数据库带来很大压力。</p>
<p>主从复制就是建立一个redis主节点master，可以有多个从节点来同步主节点的数据，从而实现主节点写，从节点读；当主节点宕机了，可以从从节点中选择一个作为主节点来实现故障转移。保证redis的高可用性。</p>
<h2 id="主从复制下，从节点数据过期怎么处理？"><a href="#主从复制下，从节点数据过期怎么处理？" class="headerlink" title="主从复制下，从节点数据过期怎么处理？"></a>主从复制下，从节点数据过期怎么处理？</h2><p>从节点数据过期的话，会删除过期数据，并返回空值；</p>
<h2 id="主从过期时间不一致问题？"><a href="#主从过期时间不一致问题？" class="headerlink" title="主从过期时间不一致问题？"></a>主从过期时间不一致问题？</h2><p>由于主从同步时，网络传输原因，可能造成过期时间不一致，因为如果采用EXPIRE设置过期时间，是按照命令执行时间开始计时过期时间的；因此可以采用设置UNIX时间戳的过期时间设置方式，但要注意主从节点的时区设置一致。</p>
<h2 id="如何实现主从同步？"><a href="#如何实现主从同步？" class="headerlink" title="如何实现主从同步？"></a>如何实现主从同步？</h2><ol>
<li>首次主从连接的时候，采用全量同步，用主节点的RDB文件来给从节点进行同步；</li>
<li>后续操作，采用增量同步，根据主节点的AOF文件，主节点根据从节点的offset偏移量，讲偏移量后的数据同步到从节点</li>
</ol>
<h2 id="主从复制的缺陷"><a href="#主从复制的缺陷" class="headerlink" title="主从复制的缺陷"></a>主从复制的缺陷</h2><p>如果主节点宕机，需要人工选取一个从节点来作为新的主节点，进行配置，不能够自动完成。这时就需要哨兵机制了。</p>
<h1 id="Sentinal"><a href="#Sentinal" class="headerlink" title="Sentinal"></a>Sentinal</h1><p>Sentinal（哨兵）模式是一种redis的运行方式，在主从复制的基础上，多了哨兵角色，来监控redis节点运行状态，自动完成故障转移。</p>
<p>想要保证高可用性，sentinal数量应大于等于3且为单数。防止sentinal误判。</p>
<blockquote>
<ol>
<li>sentinal会检测集群中所有节点的运行状态</li>
<li>当主节点故障，且判断出主节点故障的哨兵数量大于预设阈值，则判定主节点下线；</li>
<li>判定主节点下线后，采取故障转移，把一个从节点升级为主节点，并完成相应主从关系的配置。</li>
</ol>
</blockquote>
<blockquote>
<p>每隔sentinal每隔一段时间会向集群中所有节点发送ping命令，如果收到回复超时，则单个sentinal会判断某个redis节点的<strong>主观下线</strong>；当判断某个节点的sentinal数量大于预设阈值时，则判断该节点<strong>客观下线</strong>。</p>
</blockquote>
<h2 id="sentinal如何选举新的master"><a href="#sentinal如何选举新的master" class="headerlink" title="sentinal如何选举新的master"></a>sentinal如何选举新的master</h2><ol>
<li>首先看从节点的优先级replica-priority，挑优先级最高的从节点选做master；（最高优先级是1，最低是100；0表示永不被升级）</li>
<li>优先级相同，则看哪个节点的数据偏移量，偏移量越大说明同步到的原主节点数据越多，则优先被选为master；</li>
<li>最后看runid；每个redis启动时都会生成一个40位的随机数作为runid，选取runid最小的升级。</li>
</ol>
<h1 id="Cluster集群"><a href="#Cluster集群" class="headerlink" title="Cluster集群"></a>Cluster集群</h1><h2 id="为什么需要Cluster集群"><a href="#为什么需要Cluster集群" class="headerlink" title="为什么需要Cluster集群"></a>为什么需要Cluster集群</h2><p>传统的主从复制和哨兵集群只有一个master，每个节点都保存全部数据，通过故障转移策略，来保证高可用性，和<strong>读</strong>吞吐量；但是无法解决数据总量过大带来的缓存压力和<strong>写</strong>压力。</p>
<p>因此有了Cluster集群，能够配置多个master节点，每个master节点可以有一个或多个从节点；</p>
<p>存储数据根据key值进行负载均衡，分别存储在各个主从节点；Cluster集群是去（无）中心化的，每个主节点都可以作为集群入口，根据查找的key值不同，根据路由原则，讲请求分发到对应的master。</p>
<p>通过横向扩展可以根据需求方便的进行集群动态扩容和缩容；</p>
<h2 id="一个最基本的cluster集群"><a href="#一个最基本的cluster集群" class="headerlink" title="一个最基本的cluster集群"></a>一个最基本的cluster集群</h2><p>为了保证高可用性，最基本的cluster集群要3个master，每个master配有一个slave，当一个master挂掉，由它的从节点代替成为master。</p>
<h2 id="哈希槽slots"><a href="#哈希槽slots" class="headerlink" title="哈希槽slots"></a>哈希槽slots</h2><p>一个cluster集群有16384 &#x3D; 2^14 &#x3D; 16K个哈希槽，根据key值，对数据进行哈希，分配到每个哈希槽，每个主节点及其从节点负责一定数量的哈希槽的数据存储与访问；</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>如果当前访问的key对应的哈希槽与redis节点不对应，则请求会被重定向到相应节点。</p>
<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>一种非关系型数据库，为快速开发web应用而生，灵活性更强；</p>
<p>其数据模型是面向文档的，所谓文档是一种类似JSON的结构，称为BSON，可以存储比较复杂的数据类型。</p>
<h2 id="MongoDB的存储结构"><a href="#MongoDB的存储结构" class="headerlink" title="MongoDB的存储结构"></a>MongoDB的存储结构</h2><ul>
<li>文档：由BSON键值对组成，类似于关系型数据库的行；BSON（Binary JSON 二进制JSON，遍历速度优于JSON）</li>
<li>集合：一个集合可以包含多个文档，类似于关系型数据库的表；集合没有固定的结构，但是集合中存放的文档往往是有一定联系的。</li>
<li>数据库：一个数据库可以包含多个文档</li>
</ul>
<h2 id="MongoDB的特点"><a href="#MongoDB的特点" class="headerlink" title="MongoDB的特点"></a>MongoDB的特点</h2><ul>
<li>数据记录为文档格式，具体来说是BSON文档，类似于JSON的结构；</li>
<li>模式自由：文档存放在集合中，集合相当于关系型数据库表的概念，但是没有固定的表结构，比较灵活。</li>
<li>支持事务：虽然是NoSQL,但是支持事务</li>
<li>支持索引：索引类型多样</li>
<li>支持分片集群</li>
<li>支持存储大文件</li>
</ul>
<h2 id="MongoDB的适合应用场景"><a href="#MongoDB的适合应用场景" class="headerlink" title="MongoDB的适合应用场景"></a>MongoDB的适合应用场景</h2><p>MongDB的优势在于其数据模型灵活，便于扩展。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2023/05/16/0%E5%85%AB%E8%82%A1_Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="为什么重写equals方法还要重写hashCode方法？"><a href="#为什么重写equals方法还要重写hashCode方法？" class="headerlink" title="为什么重写equals方法还要重写hashCode方法？"></a>为什么重写equals方法还要重写hashCode方法？</h2><ul>
<li>首先，从判断两个对象相等的逻辑意义上来讲，从源码来看，在这两个方法都不重写时，equals用&#x3D;&#x3D;比较是内存地址，而hashCode也是通过对象的内存地址进行计算得到的。所以要判断两个对象逻辑上相等，既要保证equals相等，也要保证他们的hashCode相等</li>
</ul>
<span id="more"></span>

<ul>
<li>其次，是hashCode在应用层面，特别是在HashMap，HashSet的集合实现上，都是根据key对象的hashCode进行散列寻址的；所以如果只重写equals不重写hashCode，会造成equals判断相等的两个对象，对应HashMap中两个不同的节点，这会产生逻辑上的矛盾。</li>
</ul>
<h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><p>重写是针对父类或者接口的方法的覆盖，方法的名称，入参，返回值必须是完全相同的。</p>
<p>而重载是针对同一个类中，同一个名字方法的不同种实现，</p>
<p>重载的判断条件有两个：1、重载的两个方法名必须相同；2、传入参数的数量和种类不能完全相同。</p>
<p>至于重载的方法，它的权限public&#x2F;private，是否是静态方法static，返回值int&#x2F;void类型是否相同，不做要求，都可以。</p>
<blockquote>
<p><strong><code>如果问继续问说出java的一个返回值类型不同的重载方法？</code></strong></p>
<p>我想到了一个最近用过的一个工具类，CountDownLatch，他是JUC并发包下的，用于线程的并发流程控制。</p>
<p>我们new 一个 CountDownLatch实例的时候，会创建一个计时器并设置计数值，每有一个线程调用countDown()方法，计数值减一；</p>
<p>主线程会调用CountDownLatch实例的await方法，阻塞等待计时器被清零才会被唤醒；</p>
<p>如果直接调用await，不传入参数，那么表示这个等待永不超时；</p>
<p>如果await传入超时时间，那么它有一个boolean类型的返回值，判断这个唤醒是因为超时，还是计数器清零。</p>
<p>所以说这个类的await方法两个重载返回值类型不同。</p>
</blockquote>
<h2 id="IO密集型和CPU密集型？"><a href="#IO密集型和CPU密集型？" class="headerlink" title="IO密集型和CPU密集型？"></a>IO密集型和CPU密集型？</h2><p>IO密集型是指，系统的任务中，含有大量的数据传输，数据保存等IO工作，因此IO设备成为了限制系统性能的瓶颈；如网络通讯等web服务器。</p>
<p>而CPU密集型是指，系统的任务中，含有大量的CPU计算的工作，因此CPU性能和数量称为限制系统性能的瓶颈。如图像处理，数据加解密，对象序列化等任务。</p>
<h2 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h2><p>Function 函数  :一个输入，一个输出<br>Predicate 断言 ：一个输入，输出boolean<br>Supplier 供给 ：没输入，有输出<br>Consumer 消费 : 有输入，没输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有一个方法，并有@FunctionalInterface注解的接口;</p>
<p>通常是用匿名内部类实现这些接口，并且都能方便的写成lambda表达式的形式，简化编程代码。</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何<em>CRUD</em>。</p>
<p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p>
<p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">23</span>, <span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;c&quot;</span>, <span class="number">18</span>, <span class="string">&quot;suzhou&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>, <span class="number">29</span>, <span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>, <span class="number">35</span>, <span class="string">&quot;hangzhou&quot;</span>);</span><br><span class="line">        User[] users = <span class="keyword">new</span> <span class="title class_">User</span>[]&#123;u1,u2,u3,u4&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.stream(users)</span><br><span class="line">                .peek(user -&gt; user.setName(user.getName().toUpperCase()))</span><br><span class="line">                .filter(user -&gt; user.getAge() &lt; <span class="number">30</span>)</span><br><span class="line">                <span class="comment">//.map(User::getName)</span></span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((a,b) -&gt; b.getCity().compareTo(a.getCity()))</span><br><span class="line">                .forEach(user -&gt; list.add(user.getCity()));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;User&gt; users1 = Stream.of(users); <span class="comment">//还可以先通过Stream.of获取到流对象，再进行操作</span></span><br><span class="line">users1.forEach(System.out::println);    <span class="comment">//.forEach(user -&gt; System.out.println(user));</span></span><br></pre></td></tr></table></figure>

<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ol>
<li>修饰类 -&gt; 不可继承</li>
<li>修饰方法 -&gt; 不能被重写</li>
<li>修饰变量 -&gt;<br>   a. 基本数据类型，表示不可修改；<br>   b. 修饰引用类型，该引用不可指向其他对象；<br>   final修饰的变量必须初始化赋值；<br>   并且final在修饰一个类的静态变量时，它的赋值动作会提前到类加载的准备阶段；如果没被final修饰的话，在准备阶段是赋默认值，在初始化阶段才赋给用户代码设定的值。</li>
</ol>
<h2 id="Exception和Error"><a href="#Exception和Error" class="headerlink" title="Exception和Error"></a>Exception和Error</h2><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul>
<li><p>反射提供了运行时分析类的能力; (字段，方法，构造器等)，许多框架Spring MyBatis等都用了反射；Spring的Bean就是工厂模式+反射生成的。</p>
</li>
<li><p>new Person() 生成的时静态加载字节码</p>
</li>
<li><p>反射 生成的时静态加载字节码</p>
<blockquote>
<p>所谓静态加载和动态加载，是指类加载时 的 “加载”那一步：获取类的二进制字节码，并生成对应的Class对象；</p>
<p>静态加载：如果编译时，编译出的字节码文件就把运行时可能遇到的情况都核验过了，并且生成的自己码都是直接形式，不需要二次加载；</p>
<p>动态加载：则是在运行时，真正执行到某行代码，需要加载某个类了，才去验证并加载字节码；执行不到的动态字节码，即使是错的也没事。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  <span class="comment">//编译时就会报错</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//编译时就会报错</span><br><span class="line">java: 找不到符号</span><br><span class="line">  符号:   类 Person</span><br><span class="line">  位置: 类 Demo</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  <span class="comment">//编译不会报错，运行时才会报错</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="获取Class对象4种的方法"><a href="#获取Class对象4种的方法" class="headerlink" title="获取Class对象4种的方法"></a>获取Class对象4种的方法</h2><p>Class对象，表示访问一个类的标识信息</p>
<ol>
<li>调用运行时类的属性</li>
</ol>
<ul>
<li>Class clazz &#x3D; Person.class;</li>
</ul>
<ol start="2">
<li>调用实例的方法</li>
</ol>
<ul>
<li>Class clazz &#x3D; person.getClass();</li>
</ul>
<ol start="3">
<li>静态方法forName()</li>
</ol>
<ul>
<li>Class clazz &#x3D; Class.forName(“com.pojo.Person”);</li>
</ul>
<ol start="4">
<li>使用类加载器对象的loadClass()方法</li>
</ol>
<ul>
<li>Class clazz &#x3D; ClassLoader.getSystemClassLoader().loadClass(“com.pojo.Person”);</li>
</ul>
<h2 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h2><ul>
<li>Field</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field[] getFields();</span><br><span class="line">Field[] getDeclaredFields();</span><br></pre></td></tr></table></figure>

<ul>
<li>Method</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method m = clazz.getMethod(&quot;getName&quot;);</span><br><span class="line">Method m = clazz.getMethod(&quot;getName&quot;, String.class);</span><br><span class="line"></span><br><span class="line">Method[] getMethods();</span><br><span class="line">Method[] getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">Method m;</span><br><span class="line">Object obj;</span><br><span class="line">String res = (String) m.invoke(obj,arg1,arg2 ...); //后边可以传递参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Constructor</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor[] getConstructors();</span><br><span class="line">Constructor[] getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">Constructor cons = clazz.getConstructor(int.class, String.class);</span><br><span class="line">obj = cons.newInstance(arg1, arg2...); //后边可以传递参数  </span><br><span class="line">obj = clazz.newInstance();  //默认使用无参构造函数</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>-java</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2023/06/08/17%E5%85%AB%E8%82%A1_Docker/</url>
    <content><![CDATA[<h1 id="docker概念"><a href="#docker概念" class="headerlink" title="docker概念"></a>docker概念</h1><h2 id="镜像image"><a href="#镜像image" class="headerlink" title="镜像image"></a>镜像image</h2><ul>
<li>镜像是一种特殊的文件系统，提供了容器运行时所需的资源（程序、库、配置等），不包含动态数据。</li>
</ul>
<h2 id="容器container"><a href="#容器container" class="headerlink" title="容器container"></a>容器container</h2><ul>
<li>镜像运行时的实体。（image — container  相当于 类 — 实例 的关系）<span id="more"></span></li>
<li><blockquote>
<p>容器的存储层不应写入任何数据，存储层要保持无状态化；</p>
<p>所有文件的写入操作，应该用   <strong>数据卷</strong>  或者  <strong>绑定宿主机目录</strong>； 这样容器删除，重启后，数据不会消失；</p>
</blockquote>
</li>
</ul>
<h2 id="仓库repository"><a href="#仓库repository" class="headerlink" title="仓库repository"></a>仓库repository</h2><ul>
<li>仓库是主机存放镜像的地方。</li>
<li>一个linux主机可以有多个仓库，每个仓库的不同标签tag代表不同版本的镜像；</li>
<li>&lt;仓库名&gt;:&lt;标签&gt;表示一个具体的image；如果不指出标签，默认用latest作为标签tag</li>
</ul>
<h1 id="docker的好处"><a href="#docker的好处" class="headerlink" title="docker的好处"></a>docker的好处</h1><ul>
<li>可以将不同项目打包运行在各自的容器中，隔绝环境；</li>
<li>镜像可以让项目在任何地方的运行环境是一致的；</li>
<li>相比于传统虚拟机，docker容器直接使用宿主机的内核，启动速度更快；</li>
</ul>
<h1 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h1><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>docker pull &lt;镜像名称&gt;：&lt;版本&gt;</p>
<h3 id="查看dockerhub远程仓库中镜像"><a href="#查看dockerhub远程仓库中镜像" class="headerlink" title="查看dockerhub远程仓库中镜像"></a>查看dockerhub远程仓库中镜像</h3><p>Docker search &lt;镜像名称&gt;</p>
<h3 id="查看本地已有镜像"><a href="#查看本地已有镜像" class="headerlink" title="查看本地已有镜像"></a>查看本地已有镜像</h3><p>docker images</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>docker rmi &lt;镜像名&gt;</p>
<h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><pre><code>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。
</code></pre>
<ol>
<li>从已经创建的容器中更新镜像，并且提交这个镜像</li>
<li>使用 Dockerfile 指令来创建一个新的镜像</li>
</ol>
<h4 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a><strong>更新镜像</strong></h4><pre><code>更新镜像之前，我们需要使用镜像来创建一个容器。

To be continued
</code></pre>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="创建一个新的容器并启动该容器"><a href="#创建一个新的容器并启动该容器" class="headerlink" title="创建一个新的容器并启动该容器"></a>创建一个新的容器并启动该容器</h3><p>docker run -itd &lt;Image名称&gt;</p>
<p>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现**”对话”**的能力：</p>
<ul>
<li>-t: 在新容器内指定一个伪终端或终端。</li>
<li>-i: 允许你对容器内的标准输入 (STDIN) 进行交互</li>
<li>-d: 后台启动</li>
</ul>
<p>docker run -itd –name &lt;给容器起个名字&gt; &lt;Image名称&gt;</p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>docker stop &lt;容器ID&gt;</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<ul>
<li><strong>docker attach</strong></li>
<li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。</li>
</ul>
<h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><p>docker ps -a</p>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><p>docker logs &lt;容器ID&gt;</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a><strong>删除容器</strong></h3><p><code>docker rm -f &lt;容器ID&gt;</code> 清理某一容器</p>
<p><code>docker container prune</code>  清理掉所有处于终止状态的容器</p>
<h3 id="运行一个-web-应用"><a href="#运行一个-web-应用" class="headerlink" title="运行一个 web 应用"></a>运行一个 web 应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br><span class="line">docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line">Docker run -d -p hostPort:containerPort training/webapp python app.py</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>-P :<strong>是容器内部端口</strong>随机</strong>映射到主机的端口。</li>
<li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。 《主机端口：容器端口》</li>
</ul>
<h3 id="网络端口的快捷方式"><a href="#网络端口的快捷方式" class="headerlink" title="网络端口的快捷方式"></a>网络端口的快捷方式</h3><p>docker port &lt;容器ID或名字&gt;</p>
<h3 id="查看-WEB-应用程序日志"><a href="#查看-WEB-应用程序日志" class="headerlink" title="查看 WEB 应用程序日志"></a>查看 WEB 应用程序日志</h3><p>docker logs [ID或者名字]</p>
<h3 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker top </span><br></pre></td></tr></table></figure>

<h3 id="检查-WEB-应用程序"><a href="#检查-WEB-应用程序" class="headerlink" title="检查 WEB 应用程序"></a>检查 WEB 应用程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>-docker</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/11/13/1%E5%85%AB%E8%82%A1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="7层模型为什么干不过TCP-x2F-IP体系4层模型？"><a href="#7层模型为什么干不过TCP-x2F-IP体系4层模型？" class="headerlink" title="7层模型为什么干不过TCP&#x2F;IP体系4层模型？"></a>7层模型为什么干不过TCP&#x2F;IP体系4层模型？</h1><ul>
<li>制定时OSI专家缺乏实际经验，并且完成标准时缺乏商业驱动力；</li>
<li>层次划分不太合理，有些功能在多个层次重复出现</li>
</ul>
<p>TCP&#x2F;IP四层模型：</p>
<p>​			应用层，传输层，网络层，网络接口层（数据链路层+物理层）</p>
<p>五层理论模型（便于教学）</p>
<span id="more"></span>

<ul>
<li>应用层：定义了两个终端设备上应用程序之间信息交换的格式，从而实现某种特定的网络应用。</li>
<li>传输层：负责向两台终端设备进程之间的通信提供数据传输服务，为应用进程传送应用层报文。</li>
<li>网络层：负责分组网络上不同主机的通讯服务</li>
<li>数据链路层：将网络层下发的IP数据包封装成帧，在相邻节点链路上传输帧 物理层：实现相邻计算机节点之间将数据帧以比特流的方式透明传输，尽可能屏蔽传输介质和物理设备的干扰。</li>
<li>物理层：实现相邻计算机节点之间将数据帧以比特流的方式透明传输，尽可能屏蔽传输介质和物理设备的干扰。</li>
</ul>
<h1 id="网络模型分层的原因？"><a href="#网络模型分层的原因？" class="headerlink" title="网络模型分层的原因？"></a>网络模型分层的原因？</h1><p>对于复杂系统，往往都需要分层， 分层之后每一层只需要专注做一类事情，网络分层也是一样，我认为这样做的好处有以下3点：</p>
<ol>
<li>各层之间相互独立，不需要关注下层如何实现，就像我们平时使用框架开发一个后台程序来说，会分成数据库持久层，业务层service还有前后端数据交互的controller层。上层知道下层提供的接口，进行调用就好。</li>
<li>提高了整体灵活性。每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li>大问题化小 ：分层可以将复杂的网络问题分解为许多较小的问题分而治之，使计算机系统易于设计和标准化。我们进行开发时，也会将系统功能分解成许多更容易解决的小问题，这些小的问题具有更好的边界定义。</li>
</ol>
<blockquote>
<p> “计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.”</p>
</blockquote>
<h1 id="常见的应用层协议？"><a href="#常见的应用层协议？" class="headerlink" title="常见的应用层协议？"></a>常见的应用层协议？</h1><ul>
<li>HTTP：超文本传输协议</li>
</ul>
<blockquote>
<p>主要是为了Web浏览器和Web服务器之间通信而设计的；</p>
</blockquote>
<blockquote>
<p>基于TCP协议，建立连接需要3次握手；目前使用的HTTP大部分是1.1版本，在HTTP1.1中，默认开启Keep-Alive, 表示建立的连接可以在多次请求中复用；</p>
</blockquote>
<blockquote>
<p>HTTP协议是“无状态的”，指对于事务处理没有记忆能力，无法记录客户端用户的状态，意味着如何后续处理需要前面的信息，则必须要重传；一般哦我们通过Session来记录客户端用户的状态。</p>
</blockquote>
<ul>
<li><p>SMTP 邮件传输协议</p>
</li>
<li><p>FTP 文件传输协议</p>
</li>
<li><p>DHCP 动态主机配置协议</p>
</li>
<li><p>DNS 域名解析协议</p>
</li>
<li><p>Telnet 远程登陆协议，通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送。</p>
</li>
<li><p>SSH 安全的网络传输协议，<strong>Telnet</strong> <strong>和</strong> <strong>SSH</strong> <strong>之间的主要区别在于</strong> <strong>SSH</strong> <strong>协议会对传输的数据进行加密保证数据安全性。</strong></p>
</li>
</ul>
<h1 id="TCP-与-UDP-的区别（重要）"><a href="#TCP-与-UDP-的区别（重要）" class="headerlink" title="TCP 与 UDP 的区别（重要）"></a>TCP 与 UDP 的区别（重要）</h1><ol>
<li><strong>是否面向连接</strong> ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong> ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
</ol>
<h1 id="什么时候选择-TCP-什么时候选-UDP"><a href="#什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="什么时候选择 TCP,什么时候选 UDP?"></a>什么时候选择 TCP,什么时候选 UDP?</h1><ol>
<li><p><strong>UDP</strong> <strong>一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大;广播通讯;以及总包量较少的通讯：DHCP DNS</p>
</li>
<li><p><strong>TCP</strong> <strong>用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</p>
</li>
</ol>
<h1 id="使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h1><p>使用TCP协议的应用层协议：</p>
<ol>
<li><strong>HTTP</strong> <strong>协议</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。</li>
<li><strong>HTTPS</strong> <strong>协议</strong> ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li>
<li><strong>FTP</strong> <strong>协议</strong>：文件传输协议 FTP</li>
<li><strong>SMTP</strong> <strong>协议</strong>：简单邮件传输协议</li>
<li><strong>POP3&#x2F;IMAP</strong> <strong>协议</strong>： POP3 和 IMAP 两者都是负责邮件接收的协议。</li>
<li><strong>Telnet</strong> <strong>协议</strong></li>
<li><em>SSH</em>* <strong>协议</strong></li>
</ol>
<p>使用UDP协议的应用层协议：</p>
<ol>
<li>DHCP</li>
<li>DNS</li>
</ol>
<h1 id="TCP-三次握手和四次挥手（非常重要）"><a href="#TCP-三次握手和四次挥手（非常重要）" class="headerlink" title="TCP 三次握手和四次挥手（非常重要）"></a>TCP 三次握手和四次挥手（非常重要）</h1><p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP1.png?raw=true" alt="TCP1.png"></p>
<p>一次握手：客户端发送带有同步标志位SYN的报文（并带有这条报文的序号seq&#x3D;x），然后客户端进入<strong>SYN_SEND</strong> 状态，等待服务器的确认；</p>
<p>二次握手：服务端发送带有同步标志位SYN的确认报文（ACK是确认标志位），并且报文中还包含对一次握手报文的确认序号（x + 1）以及该报文的序号y; 然后服务端进入 <strong>SYN_RECV</strong> 状态</p>
<p>三次握手：客户端发送确认报文ACK，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</p>
<p>【TCP报文为每个字节数据进行了编号seg】</p>
<p>三次握手的目的是建立可靠的通信信道，三次握手的目的是建立可靠的通信信道，必须保证双向</p>
<p>其实三次握手可以拆解成像四次挥手那样，</p>
<p>Client发送同步报文SYN，server返回确认报文ACK client可以确保client à server发送通信正常；</p>
<p>Server发送同步报文SYN, client返回确认报文ACK  server可以确保serveràclient发送通信正常；</p>
<p>显然第二步和第三步可以合并；要保证双向传输的可靠。</p>
<blockquote>
<p>问题的本质是，信道不可靠，为满足“在不可靠信道上可靠地传输信息”，通信双方所需要达成的协议。（三次握手）精辟啊~！</p>
</blockquote>
<h1 id="TCP为什么不是两次握手？"><a href="#TCP为什么不是两次握手？" class="headerlink" title="TCP为什么不是两次握手？"></a>TCP为什么不是两次握手？</h1><p>接下来以3个方面分析三次握手的原因：</p>
<ul>
<li><p><strong>避免历史连接（主要原因）</strong>：如果采用两次握手，server端只要接收到syn报文就要进入连接建立状态，如果由于网络阻塞，client重传了多次同步报文，那么延迟的历史请求报文到达server端后，server也会进入连接建立状态，而client对server发来的确认报文并不理会，造成server端资源浪费；</p>
<p>而三次握手，当server端发来对于历史请求的ack报文后，client会返回带有RST标志位的报文，以此终止历史连接。</p>
</li>
<li><p><strong>三次握手才可以同步双方的初始序列号：</strong></p>
<p>序列号能够保证数据包不重复、不丢弃和按序传输。如果两次握手，只能保证客户端的初始序列号ISN被同步，而不能保证服务端的初始序列号被同步。</p>
</li>
</ul>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>第一次挥手：client发送一个带有终止标志位FIN的报文，用来关闭客户端到服务端的数据传送;</p>
<p>第二次挥手：server收到客户端的FIN后，发送确认报文ACK，通知应用进程该方向数据传输停止；</p>
<p>第三次挥手：server发送带有终止标志位的FIN报文，用来关闭服务端到客户端的数据传送；</p>
<p>第四次挥手：client收到服务端发送的FIN报文，之后发送确认报文ACK，之后进入TIME-WAIT时间等待状态，如果客户端经过2MSL（报文段最长寿命，一个片段在网络中的最大存活时间）一九没有收到server发来的报文，则证明服务端已经关闭连接，随之客户端关闭连接。</p>
<h1 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h1><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<h1 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h1><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h1 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h1><p>因为第四次挥手client发送给server的确认报文ACK可能丢失，server端会超时重传，如果client在发送完ACK之后就直接关闭连接，那么server超时重传的FIN就不会被client接收到。所以2*MSL是为了保证这个FIN的超时重传能被接收。</p>
<h1 id="TCP-如何保证传输的可靠性？"><a href="#TCP-如何保证传输的可靠性？" class="headerlink" title="TCP 如何保证传输的可靠性？"></a>TCP 如何保证传输的可靠性？</h1><p>​    差错检测 超时重传 流量控制  拥塞处理</p>
<h1 id="TCP-如何实现流量控制？"><a href="#TCP-如何实现流量控制？" class="headerlink" title="TCP 如何实现流量控制？"></a>TCP 如何实现流量控制？</h1><p><strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong>如果接收方处理不过来的话，就只能把处理不过来的数据存在 接收缓冲区(Receiving Buffers) 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。</p>
<p><strong>TCP</strong> <strong>利用滑动窗口实现流量控制。发送方有一个发送窗口，接收方有一个接收窗口，</strong> </p>
<p>接收方的确认报文中有已确认接收的字节序号以及接收窗口大小，发送方根据确认报文，进行发送窗口移动和发送窗口大小的调整。</p>
<p>接收方必须有累计确认【累计收到多少个字节就要发送确认报文，确认推迟的时间不应超过0.5秒】和稍带确认机制【接收方在自己有数据要发送时，把确认信息顺便稍带上，稍带确认并不常发生，因为很少同时在两个方向发送数据】</p>
<h1 id="TCP-的拥塞控制是怎么实现的？"><a href="#TCP-的拥塞控制是怎么实现的？" class="headerlink" title="TCP 的拥塞控制是怎么实现的？"></a>TCP 的拥塞控制是怎么实现的？</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫<strong>拥塞</strong>。</p>
<p><strong>拥塞控制</strong>就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP4.png?raw=true" alt="TCP4.png"></p>
<h2 id="拥塞控制与流量控制的区别？"><a href="#拥塞控制与流量控制的区别？" class="headerlink" title="拥塞控制与流量控制的区别？"></a>拥塞控制与流量控制的区别？</h2><p>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>而流量控制是是个端到端的问题，流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<h2 id="TCP如何实现拥塞控制的？"><a href="#TCP如何实现拥塞控制的？" class="headerlink" title="TCP如何实现拥塞控制的？"></a>TCP如何实现拥塞控制的？</h2><p>发送方要维持一个拥塞窗口（cwnd），来衡量网络的拥塞程度，这取决于网络中发生超时重传的次数。发送方让自己的发送窗口取拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>。</p>
<h1 id="ARQ-协议了解吗"><a href="#ARQ-协议了解吗" class="headerlink" title="ARQ 协议了解吗?"></a>ARQ 协议了解吗?</h1><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>
<p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<p><strong>停止等待<strong><strong>ARQ</strong></strong>协议</strong>：发送方发送完一个分组，就停止发送，等待接收的确认ACK</p>
<p><strong>连续<strong><strong>ARQ</strong></strong>协议</strong>：发送方维护一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待确认，接收方采用累计确认的方式。（如果有一个丢失，需要回退N帧的策略，讲窗口起点移动到最后一个确认接收的分组处）</p>
<h1 id="从输入URL-到页面展示到底发生了什么？（非常重要）"><a href="#从输入URL-到页面展示到底发生了什么？（非常重要）" class="headerlink" title="从输入URL 到页面展示到底发生了什么？（非常重要）"></a>从输入URL 到页面展示到底发生了什么？（非常重要）</h1><ol>
<li><p>解析URL </p>
<p>检查URL是否完整合法，确定访问地址</p>
</li>
<li><p>DNS域名解析</p>
<p>先查询本机缓存，没有缓存再查询本地DNS服务器（可能是大学，或者ISP），没有缓存再去查找DNS根服务器（存储着顶级域名），然后查询顶级域名服务器，然后再查低一级的域名服务器…… 迭代查询</p>
<img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS.png?raw=true" alt="DNS.png" style="zoom:50%;" />
</li>
<li><p>如果使用 HTTPS，会在 TCP 与 HTTP 之间多添加一层协议做加密及认证的服务。HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security） 协议，保障了信息的安全。</p>
</li>
<li><p>TCP协议三次握手建立连接</p>
</li>
<li><p>在TCP包头前添加IP信息，生成IP数据报</p>
</li>
<li><p>ARP协议获取对方MAC地址，并讲自己的MAC地址信息封装在帧头帧尾，形成数据帧。</p>
</li>
<li><p>网卡将数字信号转化成电信号传递出去</p>
</li>
<li><p>经过网络中的交换机、路由器，多次转发到达目的主机</p>
</li>
<li><p>目的主机将获取到的数据逐层解析，挨个核对，应用程序接收到HTTP请求报文，处理请求并返回HTTP响应报文，传输结束就通过TCP四次挥手断开连接。</p>
</li>
<li><p>浏览器收到的响应正文，通常包含有HTML,CSS,JS还有图片等文件，再经过浏览器解析渲染，就得到了我们看到的画面。</p>
</li>
</ol>
<h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><p>请求报文：请求行 请求头 请求体 </p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png?raw=true" alt="HTTP请求报文.png"></p>
<p>响应报文：状态行 响应头 响应体</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png?raw=true" alt="HTTP响应报文.png"></p>
<h1 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h1><h2 id="1xx-Informational（信息性状态码）"><a href="#1xx-Informational（信息性状态码）" class="headerlink" title="1xx Informational（信息性状态码）"></a>1xx Informational（信息性状态码）</h2><p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。</p>
<h2 id="2xx-Success（成功状态码）"><a href="#2xx-Success（成功状态码）" class="headerlink" title="2xx Success（成功状态码）"></a>2xx Success（成功状态码）</h2><p>200 OK ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</p>
<p>201 Created ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</p>
<p>202 Accepted ：服务端已经接收到了请求，但是还未处理。</p>
<p>204 No Content ： 服务端已经成功处理了请求，但是没有返回任何内容。</p>
<h2 id="3xx-Redirection（重定向状态码）"><a href="#3xx-Redirection（重定向状态码）" class="headerlink" title="3xx Redirection（重定向状态码）"></a>3xx Redirection（重定向状态码）</h2><p><strong>301 Moved Permanently</strong> ： 资源被永久重定向了。比如你的网站的网址更换了。</p>
<p><strong>302 Found</strong> ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</p>
<p><strong>304 Not Modified</strong> : 如果代理服务器中的文档过期，则代理服务器向原始服务器发起请求，原始服务器给代理服务器的响应为304时，表示代理服务器缓存有效，更新过期时间即可。</p>
<h2 id="4xx-Client-Error（客户端错误状态码）"><a href="#4xx-Client-Error（客户端错误状态码）" class="headerlink" title="4xx Client Error（客户端错误状态码）"></a>4xx Client Error（客户端错误状态码）</h2><p><strong>400 Bad Request</strong> ： 发送的HTTP请求存在问题。比如请求参数不合法、请求方法错误。</p>
<p><strong>401 Unauthorized</strong> ： 未认证却请求需要认证之后才能访问的资源。</p>
<p><strong>403 Forbidden</strong> ：直接拒绝HTTP请求，不处理。一般用来针对非法请求。</p>
<p><strong>404 Not Found</strong> ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</p>
<p><strong>409 Conflict</strong> ： 表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</p>
<h2 id="5xx-Server-Error（服务端错误状态码）"><a href="#5xx-Server-Error（服务端错误状态码）" class="headerlink" title="5xx Server Error（服务端错误状态码）"></a>5xx Server Error（服务端错误状态码）</h2><p><strong>500 Internal Server Error</strong> <strong>：</strong> <strong>服务端出问题了（通常是服务端出<strong><strong>Bug</strong></strong>了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</strong></p>
<p><strong>502 Bad Gateway</strong> <strong>：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</strong></p>
<h1 id="HTTP-和-HTTPS-有什么区别？（重要）"><a href="#HTTP-和-HTTPS-有什么区别？（重要）" class="headerlink" title="HTTP 和 HTTPS 有什么区别？（重要）"></a>HTTP 和 HTTPS 有什么区别？（重要）</h1><ul>
<li><p><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</p>
</li>
<li><p><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 http:&#x2F;&#x2F;，HTTPS 的 URL 前缀是 https:&#x2F;&#x2F;。</p>
</li>
<li><p><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>
</li>
<li><p>HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用<strong>服务器方的证书</strong>进行了<strong>非对称加密</strong>。【保证对称密钥在网络传输的安全性】所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。、</p>
</li>
<li><p><strong>数字证书</strong>：HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ul>
<p>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式： </p>
<ul>
<li><p>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</p>
</li>
<li><p>「会话秘钥」由浏览器生成，通过公钥加密后，发送给服务器。</p>
</li>
<li><p>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
</li>
<li><p>采用「混合加密」的方式的原因： 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但 速度慢。</p>
</li>
</ul>
<h1 id="HTTP-1-0-和-HTTP-1-1-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-有什么区别？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 有什么区别？"></a>HTTP 1.0 和 HTTP 1.1 有什么区别？</h1><ul>
<li><p><strong>连接方式</strong> <strong>:</strong> HTTP 1.0 为TCP短连接，HTTP 1.1 支持TCP长连接。</p>
</li>
<li><p><strong>状态响应码</strong> : HTTP&#x2F;1.1中新加入了大量的状态码</p>
</li>
<li><p><strong>Host</strong>字段 <strong>:</strong> HTTP&#x2F;1.1在请求头中加入了Host字段。</p>
</li>
<li><p><strong>支持管道（<strong><strong>pipeline</strong></strong>）网络传输</strong>：HTTP1.1只要第一个请求发出去了，不必等其回来，就可以发第二个请求 出去，可以减少整体的响应时间。</p>
</li>
</ul>
<h1 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h1><p>http是无状态协议，也就是说客户端对于每个http请求，是不知道哪个客户端发起的。</p>
<p>这就意味着每次用户请求都要进行用户认证。</p>
<p>解决方法有：</p>
<p><strong>Cookie:</strong> </p>
<p>cookie是一种客户端会话技术，每次发起http请求，请求头携带cookie数据，服务端也可以通过在响应头给客户端设置Set-Cookie；通过cookie方式，可以将用户状态（登录信息、及会话期间的其他信息）保存在客户端，客户端请求携带状态信息，以此传递用户状态。</p>
<p>如果用cookie传递信息，容易信息泄露，并且cookie有大小限制。</p>
<p><strong>Session：</strong></p>
<p>​    Session是将用户的会话信息保存在服务端，用一个sessionId来跟踪这个会话信息，sessionId通过cookie方式来和客户端之间进行传递。</p>
<p>​    如果服务端是分布式部署的话，会出现session不共享的问题。</p>
<p><strong>Token：</strong></p>
<p>​    Token与session的流程差不多，区别是token是用保存在redis中的，token一般是一个随机字符串（UUID）作为key，value是用户ID（用于识别用户的登录信息），并且有一个过期时间，token字符串还要传递给客户端一份，每次请求带着token，如果redis中存在相应的token，就表示认证成功；如果请求没带着token或者redis中没有相应token，则会生成一个新的token字符串，保存在redis一份，传给客户端一份。</p>
<p>​    缺点是每次请求都要查询一次redis，给redis带来压力，还要占用redis的空间。</p>
<p><strong>JWT：</strong></p>
<p>​    Json Web Token，他不像session和token是基于存储和验证的，他是基于解析+验证的；JWT登录流程需要额外的一个认证服务器，客户端发起登录请求时（浏览器没有JWT），会到认证服务器去申请到JWT，然后向web应用服务器发起请求，带着JWT，应用服务器验证JWT，检查登录信息。</p>
<p>​    JWT字符串<strong>组成</strong>：[header].[payload].[signature]</p>
<p>​    header部分和payload部分都是json格式，通过base64编码成字符，</p>
<p>​    signature部分是【base64编码处理后的header和payload字符串和secret拼接起来，然后进行一个单向加密算法加密，生成signature部分】secret是保存在服务器的。</p>
<p>​    header字符串，payload字符串和signature字符串三个部分通过.连接，组成JWT字符串。</p>
<p>​    应用服务器<strong>验证</strong>的时候，通过前两部分header，signature，加上服务器才有的secret，用header保存的加密算法进行加密，比较生成的JWT和传来的是否相同就行了。</p>
<p>​    优点：JWT字节占用小，并且不占用服务器资源。</p>
<h1 id="假如客户端浏览器禁用了cookie，该怎么办？"><a href="#假如客户端浏览器禁用了cookie，该怎么办？" class="headerlink" title="假如客户端浏览器禁用了cookie，该怎么办？"></a>假如客户端浏览器禁用了cookie，该怎么办？</h1><p>SessionId, token ,JWT都可以通过cookie传递，如果cookie被浏览器禁用了，</p>
<p>主要有两种方式：Cookie 与 URL 重写【url?传参】或者将SessionId存储在localStorage&#x2F;sessionStorage</p>
<p>url重写，比如 <a href="http://taobao.com/getitem?sessionid=1wui87htentg&?name=baymax&action=buy">http://taobao.com/getitem?sessionid=1wui87htentg&amp;?name=baymax&amp;action=buy</a></p>
<p>在web开发过程中，cookie是我们常用的功能；最基本的用来存储服务端返回的jsessionid来识别用户，甚至保存其它更多的客户信息。假如客户端浏览器禁用了cookie，</p>
<p>就要通过其他方式， URL 重写或者 将SessionId存储在localStorage&#x2F;sessionStorage，每次发送html请求时带上（html5）。后端项目返回相应给前端，前端解析出token字符串，保存在localStorage&#x2F;sessionStorage【另外，cookie不能跨域，localStorage&#x2F;sessionStorage能跨域】</p>
<h1 id="说一下-GET-和-POST-的区别？"><a href="#说一下-GET-和-POST-的区别？" class="headerlink" title="说一下 GET 和 POST 的区别？"></a>说一下 GET 和 POST 的区别？</h1><p>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等，Get请求不带有请求体。</p>
<p>而 POST 方法可以向指定的资源提交数据，我们通常使用json格式将数据放在HTTP请求报文的body里面。</p>
<h1 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h1><p>GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。</p>
<p>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据 就会创建多个资源，所以不是幂等的。</p>
<h1 id="ARP协议了解吗？"><a href="#ARP协议了解吗？" class="headerlink" title="ARP协议了解吗？"></a>ARP协议了解吗？</h1><p>​    ARP协议能够将IP地址解析成对应的MAC地址，每个主机或者路由器有一个ARP高速缓存表，缓存着IP地址和MAC地址的对应关系。如果缓存未命中，那么则广播发送ARP报文，请求指定IP的MAC地址。</p>
<h1 id="NAT-x2F-NAPT协议了解吗？"><a href="#NAT-x2F-NAPT协议了解吗？" class="headerlink" title="NAT&#x2F;NAPT协议了解吗？"></a>NAT&#x2F;NAPT协议了解吗？</h1><p>网络地址转换协议，能够解决公网Ip不足的问题，NAPT协议能够使多个内网Ip公用一个公网Ip，NAPT路由器维护一个映射关系表，能够将内网ip：端口号映射成公网Ip：端口号，用这个公网Ip：端口号去访问网络资源。</p>
<p>Ping命令过程？</p>
<p>Ping命令基于ICMP协议，ICMP是网络控制报文协议。</p>
<p>ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。</p>
<p>Ping命令发送方向目的方发送icmp报文，目的主机接收到该报文，返回响应报文。如果目的方不可达， 则由路由器返回差错报文。</p>
<h1 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h1><p>Base64是用64个可打印字符表示二进制数据的一种编码方式。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li><p>将每三个字节的二进制数据，一共24位，分成4组，每组6位，在每个6位数据前补两个0，一共就变成了4个字节，再根据每个字节的值去查表找到对应的字符。</p>
</li>
<li><p>那么由于原有数据可能不是三个字节的倍数，转化过程中就可能出现：1.每个拆分成的数据不足6位，那么我们就在后面补0，然后再根据值去查表；2.还会导致拆分的总个数不足4个，那么后面空着的就直接补“&#x3D;”就好。</p>
</li>
<li><p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/base64.png?raw=true" alt="base64.png"></p>
</li>
</ul>
<h2 id="Base64用途"><a href="#Base64用途" class="headerlink" title="Base64用途"></a>Base64用途</h2><ul>
<li><p><strong>二进制存储文件的传输：</strong></p>
<p>因为HTTP1.1是文本传输协议，而对于图片、视频这些二进制存储的文件，在网络传输要转换成文本格式才能传输，json直接传输byte[ ]可能导致字节流发生变化？</p>
</li>
<li><p><strong>特殊字符引发的解析问题：</strong></p>
<p> Get请求方法，要把请求参数拼接在url后边，当出现空格的时候就会导致访问链接解析异常；</p>
<p>还有一些特殊字符会导致http报文格式解析错误；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2022/11/20/2%E5%85%AB%E8%82%A1_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h1><p>​    操作系统是在计算机上运行的最基本的软件程序，它位于计算机硬件资源和应用程序之间，能够管理计算机的硬件资源和应用程序，为应用程序提供服务。</p>
<span id="more"></span>

<h1 id="系统调用？"><a href="#系统调用？" class="headerlink" title="系统调用？"></a>系统调用？</h1><p>​    首先要提到进程在操作系统上运行的两个等级  用户态和核心态，</p>
<p>用户态只能直接读取用户程序的数据，特权较低，想要运行涉及到资源的相关操作，比如进程调度，文件管理，内存管理这些，必须通过操作系统执行内核代码去执行，操作系统为用户进程提供了使用接口，用户进程调用，转交给操作系统去执行这些特权指令，此时状态称为内核态，这个调用接口称作系统调用。</p>
<p>​    这样做的好处是：具有用户态和内核态的区分，保证了计算机系统的</p>
<p>​    <strong>安全性</strong>：如果用户能直接操控系统资源，有些指令是很危险的，安全性难以保证。</p>
<p>​    <strong>性能</strong>：如果用户直接访问共享资源，势必会产生冲突，影响执行效率。</p>
<p>​    系统调用会发生进程的用户态和核心态之间的转换，转换时需要保存现场，恢复现场，状态的保存和恢复都要在CPU寄存器，浪费CPU资源（空间资源、时间资源）。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程?"></a>进程?</h1><p>​    进程实体由 PCB 程序段 数据段 三部分组成。</p>
<p>   *<em>PCB</em>***：进程控制块，是操作系统跟踪、管理进程的一个数据结构。组成有：</p>
<ul>
<li>进程描述信息：PID UID</li>
<li>进程控制和管理信息：如当前进程状态，进程优先级等</li>
<li>资源分配清单：程序段指针，数据段指针，键盘，鼠标。。。</li>
<li>CPU相关信息：保存当前CPU寄存器中的值，用于记录和恢复进程<strong>上下文切换</strong>时的状态。</li>
</ul>
<h2 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态?"></a>进程有哪几种状态?</h2><ul>
<li>创建状态(new) ：进程正在被创建，尚未到就绪状态。</li>
<li>就绪状态(ready) ：进程获得了除了CPU之外的一切所需资源，一旦得到CPU时间片即可运行。</li>
<li>运行状态(running) ：进程正在CPU上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li>阻塞状态(waiting)：由于进程缺少某种资源或等待某件事情而进入的状态</li>
<li>结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<p>阻塞态的进程占⽤着物理内存，在<strong>虚拟内存管理</strong>的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换⼊到物理内存。</p>
<p>挂起态：新的状态，描述进程没有占⽤实际的物理内存空间的情况，这个状态就是挂起状态</p>
<p>阻塞挂起状态： 进程在外存（硬盘）并等待某个事件的出现</p>
<p>就绪挂起状态： 进程在外存（硬盘），但只要进⼊内存，马上运行</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/p1.png?raw=true" alt="p1.png"></p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度?"></a>进程调度?</h2><p>进程调度就是按照某种算法，为处于就绪队列中的进程分配CPU资源的方式。</p>
<p>进程调度算法有以下几种：</p>
<p>​    早期批处理系统：</p>
<ol>
<li><p><strong>先来先服务：非抢占式</strong>（进程主动放弃CPU，正常&#x2F;异常完成，或主动阻塞[请求IO]）。按照进程请求CPU的顺序。有利于长作业，不利于短作业。</p>
</li>
<li><p><strong>短作业优先：默认非抢占式（也有抢占式版本）</strong>。按照估计出的进程运行时间来排队，事件短的排在前边。如果一直有短作业请求，那么长作业会产生<strong>饥饿</strong>。</p>
</li>
<li><p><strong>高响应比优先：非抢占式</strong>。响应比&#x3D;（等待时间+进程作业时间）&#x2F;进程作业时间。响应比大的排在前边。</p>
</li>
</ol>
<p>​    交互式系统：</p>
<ol>
<li><p><strong>时间片轮转：抢占式（定时中断）</strong>。为每个进程分配同样长的时间片。</p>
</li>
<li><p><strong>优先级调度算法：</strong>抢占、非抢占式都有。为每个进程分配⼀个优先级，按优先级进⾏调度。</p>
</li>
<li><p><strong>多级反馈队列：抢占式。</strong>设置多个队列，各级队列优先级从高到低，时间片长度从小到大。一个进程如果时间片用完了还没执行完，那么就会被分到下一个队列。【平衡优秀，但是可能会造成饥饿】</p>
</li>
</ol>
<h2 id="进程通信？"><a href="#进程通信？" class="headerlink" title="进程通信？"></a>进程通信？</h2><p><strong>同一主机间进程通信</strong></p>
<ol>
<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：半双工，先进先出，位于内存中。只能用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Named Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道，可以实现本机<strong>任意</strong>两个进程通信。有名管道以<strong>磁盘文件</strong>的方式存在。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：<strong>消息队列存放在内核</strong>中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息<strong>不一定要以先进先出</strong>的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是解决<strong>进程同步</strong>的一种方式，能够解决并发进程对共享数据的访问问题。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
</ol>
<p><strong>不同主机间进程通信</strong></p>
<ol>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h2 id="进程同步？"><a href="#进程同步？" class="headerlink" title="进程同步？"></a>进程同步？</h2><p>并发执行的进程之间访问共享资源时，可能会发生冲突，那么如何协调并发执行的进程之间对资源的使用，就叫做进程同步。</p>
<p>操作系统一般有下面三种线程同步的方式：</p>
<ol>
<li><strong>互斥量(Mutex)：又叫互斥锁，</strong>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，信号量其实就是一个变量，能够表示系统中某种资源的数量，可根据操作信号量值的结果判断是否对公共资源具有访问的权限。</li>
<li><strong>事件(Event)</strong> :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<h2 id="僵尸进程和孤儿进程？"><a href="#僵尸进程和孤儿进程？" class="headerlink" title="僵尸进程和孤儿进程？"></a>僵尸进程和孤儿进程？</h2><p>Linux 系统中，子进程通常是通过fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。</p>
<ul>
<li><p>僵尸进程：任何⼀个⼦进程(init除外)在exit()之后，并⾮马上就消失掉，⽽是留下⼀个称为僵⼫进程 (Zombie)的数据结构，包含进程的PCB信息，以便父进程得到子进程的状态信息（mysql主从复制，从库起一个子线程来接收处理binlog），父进程使用wait()或waitpid()系统调用才能释放子进程的PCB。父进程长时间不使用wait()或waitpid()就会留下僵尸进程。</p>
</li>
<li><p>孤儿进程：父进程已经结束，子进程还在执行。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。解决方法为：操作系统有一个进程号为1的init进程，操作系统会把孤儿进程的父进程设置为init进程，由init进程来回收孤儿进程的资源。</p>
</li>
</ul>
<h2 id="死锁？"><a href="#死锁？" class="headerlink" title="死锁？"></a>死锁？</h2><p>一个进程集合中的每一个进程，都在等待其他进程执行某件事情，而产生的同时被阻塞的现象。</p>
<h3 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h3><ol>
<li><p><strong>互斥</strong>：造成进程死锁的资源必须为互斥资源，在一个时刻只能被一个进程使用。资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</p>
</li>
<li><p><strong>不可抢占</strong>：已经分配给⼀个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放</p>
</li>
<li><p><strong>占有且等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</p>
</li>
<li><p><strong>循环等待</strong>：有一组等待进程 {P0, P1,…, Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。</p>
</li>
</ol>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防死锁，避免死锁，死锁的检测和解除</strong>。</p>
<ol>
<li><p><strong>预防死锁</strong> ：想办法采用某种策略，能够使产生死锁的必要条件被破坏。</p>
</li>
<li><p><strong>避免死锁 ：银行家算法，</strong>在系统分配资源之前，根据当前资源使用情况进行判断，看分配之后是否会进入不安全状态，来判断是否分配资源。</p>
</li>
<li><p><strong>死锁的检测和解除</strong>：</p>
</li>
</ol>
<blockquote>
<p>检测：有向图来记录资源分配，检测有向图中是否存在环，来判断是否死锁。</p>
<p> 恢复: (1) 利用抢占恢复  ： 强行将某进程挂起</p>
<p>（2）利用回滚恢复  ：将某一进程回滚到不发生死锁的状态</p>
<p>（3）强行杀死某一进程</p>
</blockquote>
<h2 id="Java如何排查死锁"><a href="#Java如何排查死锁" class="headerlink" title="Java如何排查死锁"></a>Java如何排查死锁</h2><ol>
<li><p>先看日志</p>
</li>
<li><p>再看堆栈信息：</p>
<ol>
<li><p>jps -l 查看全部线程信息</p>
</li>
<li><p>jstack + 线程号 ：查看堆栈信息</p>
</li>
</ol>
</li>
</ol>
<h3 id="能写一个模拟产生死锁的代码吗？"><a href="#能写一个模拟产生死锁的代码吗？" class="headerlink" title="能写一个模拟产生死锁的代码吗？"></a>能写一个模拟产生死锁的代码吗？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="线程"><a href="#线程" class="headerlink" title="线程?"></a>线程?</h2><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul>
<li><p>进程是操作系统进⾏<strong>资源</strong>调度和分配的基本单位，而线程是最小的执行单位。</p>
</li>
<li><p>一个进程在运行过程中可以产生多个线程，线程更加轻量化：</p>
</li>
</ul>
<blockquote>
<p>线程共享进程的资源（内存空间、网络连接、文件句柄），因此<strong>创建和终止</strong>的时间更快；</p>
<p>线程的切换仅涉及到少量的寄存器和栈区，因此线程<strong>上下文切换</strong>的速度更快；</p>
<p>线程天生共享了进程的大多数资源，因此<strong>线程间通信</strong>效率更高。</p>
</blockquote>
<h3 id="多线程的好处？"><a href="#多线程的好处？" class="headerlink" title="多线程的好处？"></a>多线程的好处？</h3><p>​    线程比进程的开销小，创建和终止的速度快，上下文切换的速度也快，有些应用从功能上要同时发生多个活动，分解成多个线程执行，可以简化模型，加快执行效率；</p>
<h1 id="内存？"><a href="#内存？" class="headerlink" title="内存？"></a>内存？</h1><h2 id="用户代码到内存中的流程"><a href="#用户代码到内存中的流程" class="headerlink" title="用户代码到内存中的流程"></a>用户代码到内存中的流程</h2><p>程序代码编写 -&gt; 编译 -&gt; 链接 -&gt;装入</p>
<p>链接：编译出的机器代码都有各自独立的逻辑地址，链接就是整合他们的逻辑地址，形成一个具有统一逻辑地址的可执行文件。</p>
<blockquote>
<ol>
<li>静态链接</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ol>
</blockquote>
<p>装入：将可执行文件放入内存</p>
<blockquote>
<ol>
<li>绝对装入</li>
<li>静态重定位装入</li>
<li>动态运行时装入：重定位寄存器</li>
</ol>
</blockquote>
<h2 id="局部性原理？"><a href="#局部性原理？" class="headerlink" title="局部性原理？"></a>局部性原理？</h2><p>​    局部性原理是计算机程序运行所呈现出的一种局部性规律，分为时间局部性和空间局部性。</p>
<ul>
<li><p>时间局部性：执行了一条指令，那么这条指令很可能很快会被再次被执行；某个数据被访问过，这个数据很可能很快被再次被访问（由于存在大量循环）</p>
</li>
<li><p>空间局部性：一个程序访问了一个存储单元，在不久时间内，附近的存储单元很可能被访问。（因为数据存放形式大多是连续的）</p>
</li>
</ul>
<h2 id="内存管理主要做什么"><a href="#内存管理主要做什么" class="headerlink" title="内存管理主要做什么"></a>内存管理主要做什么</h2><ul>
<li><strong>内存空间的分配与回收</strong></li>
<li><em>地址转换*<em>：装入时完成逻辑地址到物理地址的转换</em></em></li>
<li>内存空间的扩展<strong>：覆盖、交换、虚拟内存</strong></li>
<li>存储保护**：每个用户进程只能访问各自的内存地址</li>
</ul>
<h2 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收?"></a>内存空间的分配与回收?</h2><blockquote>
<p>内存管理分为<strong>连续分配</strong>管理方式和<strong>非连续</strong>分配管理方式，连续分配管理方式是指为一个用户程序分配一个连续的内存空间。</p>
</blockquote>
<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a><strong>连续分配</strong>管理方式</h3><p>又有固定分区分配和动态分区分配:</p>
<ol>
<li><p>固定分区分配：是将用户内存空间分为若干个固定大小的分区，每个分区只能运行一个用户程序，会产生<strong>内部碎片，</strong>导致内存利用率低。</p>
</li>
<li><p>动态分区分配：在用户进程装入内存时，根据进程的大小动态分配内存空间。回收再分配时，会产生<strong>外部碎片</strong>，可用”紧凑”的技术来解决，但是“紧凑”的<strong>时间代价</strong>很高。</p>
</li>
</ol>
<h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a><strong>非连续分配</strong>管理方式</h3><p>分为页式分配、段式分配、段页式分配。</p>
<h4 id="页式分配管理"><a href="#页式分配管理" class="headerlink" title="页式分配管理"></a>页式分配管理</h4><ul>
<li><p>将内存采用固定分区分配的方式进行分配，不过每个分区空间更小，称为<strong>页框。</strong></p>
</li>
<li><p>将进程分成多个部分，每个部分大小与页框相等，称为<strong>页&#x2F;页面</strong>。</p>
</li>
<li><p>那么只有最后一个页有可能产生很小的内部碎片。</p>
</li>
</ul>
<h5 id="页式分配如何得到物理地址？"><a href="#页式分配如何得到物理地址？" class="headerlink" title="页式分配如何得到物理地址？"></a><strong>页式分配如何得到物理地址？</strong></h5><p>将程序页放入内存页框时可以采用离散的方式存放，因此难点在于逻辑地址到物理地址的转换。</p>
<p>​		<em>页号</em>* &#x3D; 逻辑地址&#x2F;页面大小  <strong>页内偏移量</strong> &#x3D; 逻辑地址%页面大小</p>
<p>​		<strong>页表</strong>记录了页号与页面地址的对应关系，通过页号查询得到页面地址，再结合页内偏移量就能得到实际的物理地址。页表存储地址的信息存放在PCB中。</p>
<p>当然这是基本的分页管理方式，如果采用的是虚拟内存技术，那么在地址转换过程要更加复杂，页表还要记录页面在外存中的状态，判断页面是否在内存中，（也就是判断是否缺页），进行页面置换，页表项也要动态更新。</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/p2.png?raw=true" alt="p2.png"></p>
<p>​		页表中的页号字段其实是隐含的，因为每个页表项（每条记录）是等长的，看多少位能把所有的业内偏移量表示，就用了多少位。</p>
<h5 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h5><p>​		快表是为了解决页式管理时，逻辑地址到物理地址转换时，查询页表速度较慢的问题。</p>
<p>​		快表是页表的<strong>高速缓存存储器</strong>，当需要查询页表时，先查询快表中的缓存，缓存命中直接返回页面地址，未命中则去查询页表，然后缓存到快表中。</p>
<p>​		由于局部性原理，我们访问了一个内存单元，那么这个内存单元附近的内存单元很可能在短时间内被访问，因此很可能查询到的页号是相同的，所以这种缓存机制命中率是很高的，能够很好的提高地址转换效率。</p>
<p>​    	这种操作系统的设计思想在我们开发系统时也经常用到。</p>
<h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><p>​    	多级页表是为了避免，由于页表是连续存放的，把全部页表一直放在内存中占用过多内存空间。由于局部性原理，在一段时间内，程序只需要访问某些特定的存储空间就可以了，那些不需要的页表就不需要保留在内存中，我们通过将页表分块来解决。多级页表属于时间换空间的典型场景。</p>
<h4 id="段式分配管理"><a href="#段式分配管理" class="headerlink" title="段式分配管理"></a>段式分配管理</h4><p>​    	分段的实际意义是：将用户程序按照逻辑关系，分成多个段（如MAIN段, 子程序段，数据段等）,以段为单元离散存放在物理内存中。</p>
<p>​    	地址转换方式：段表记录了每个段的段号，段长，以及在物理内存中的基址，然后根据段号+段内偏移量，实现逻辑地址到物理地址的转换。</p>
<p>段式管理和页式管理的区别和共同点：</p>
<ul>
<li>两者的<strong>相同点</strong>是：</li>
</ul>
<p>​		在完成逻辑地址到物理地址转换时，都通过一定映射关系来完成，分页有页表，分段有段表，通过页号段号+偏移量来实现，只不过由于分段长度不是固定的，段表需要额外维护一个段长的字段。（段长对于寻址没有帮助，作用在做越界检查，看段内地址是否大于段长）</p>
<ul>
<li>两者的<strong>主要区别</strong>是：</li>
</ul>
<p>​    	分页是以系统为基准的，系统将内存固定分成了等长的页框，那用户程序就要基于这个标准，被分成一个个页面装入内存；</p>
<p>​    	分段是以用户程序为基准的，根据用户程序的逻辑模块，分成一个个段，长度是不固定的，然后以段为单元分配在系统内存中；这种分段做法的好处是方便进行资源的保护和共享，缺点就是内存利用率低，会产生外部碎片（和连续内存分配中的动态分区分配很像）。</p>
<p>​    	在现代使用虚拟技术的计算机系统上，多采用分页管理。</p>
<h4 id="段页式分配管理"><a href="#段页式分配管理" class="headerlink" title="段页式分配管理"></a>段页式分配管理</h4><p>​    	段页式管理综合分页和分段两种方式，先按照用户程序的逻辑模块分段，然后再将每段分成固定长度的页面，页长由系统决定。</p>
<p>​    	不会产生外部碎片，每段分成最后一页会有较小的内部碎片。</p>
<p>​    	<strong>地址转换</strong>：维护两个表</p>
<p>​		段表记录  段号-段内页数-起始页号</p>
<p>​		页表记录  页号-页基址 </p>
<p>​       根据段号和段内偏移量可算出页号和页内偏移量，根据页号和业内偏移量可知物理地址。</p>
<p>​			a)    段号查表得到起始页号；<br>​			b)   页号 &#x3D; 起始页号 + 段内偏移量&#x2F;页长；<br>​			c)    页内偏移量 &#x3D; 段内偏移量 % 页长；</p>
<h2 id="内存空间的扩充？"><a href="#内存空间的扩充？" class="headerlink" title="内存空间的扩充？"></a>内存空间的扩充？</h2><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p>​    早期计算机使用，将内存分为<strong>固定区</strong>和<strong>覆盖区</strong>，固定区存放需要常驻内存的程序模块，对于不会同时装入内存的程序模块，共享某一段覆盖区。实现了内存空间的扩展。</p>
<p>​    缺点：哪些程序段是常驻内存的，哪些可以共享覆盖区的，需要程序员声明，增加了编程负担。</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>​    当内存紧张时，将暂时不具备运行条件的进程换到外存，比如处于阻塞态、就绪态的进程，可以给它换到外存，此时状态叫他挂起态，然后具备运行条件再换入内存。</p>
<p>​    外存的磁盘空间分为<strong>对换区</strong>和<strong>文件区</strong>：</p>
<p>​    <strong>文件区</strong>：用于存放文件，追求存储空间的利用率，离散分布，随机读写；</p>
<p>​    <strong>对换区</strong>：用于存放被换出的进程数据，追究的是换入换出的速度，采用顺序读写的方式，IO速度更快。</p>
<p>​    交换技术以进程为单位，而虚拟内存是针对进程内的页面的。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h4><p>​    虚拟内存通过一种“数据交换”的方式，将暂时用不到的程序模块放在外存中，在逻辑上扩展了系统的内存空间，是局部性原理的一个重要应用。</p>
<p>​    请求分页管理方式：基本分页管理+虚拟内存。</p>
<h4 id="页缺失是什么意思？"><a href="#页缺失是什么意思？" class="headerlink" title="页缺失是什么意思？"></a>页缺失是什么意思？</h4><p>需要访问的程序页不在内存中，被置换到了外存当中。</p>
<h4 id="页面置换算法有哪些？"><a href="#页面置换算法有哪些？" class="headerlink" title="页面置换算法有哪些？"></a>页面置换算法有哪些？</h4><p>​    页面置换算法是在请求分页管理方式中，当内存块都被占满的情况下，有新的页面要从外存中请求调入时，淘汰当前内存中页面的规则。</p>
<p>页面置换算法性能指标是缺页率。</p>
<p>a)    <strong>最佳置换算法OPT</strong>：每次选择淘汰以后永不访问，或最长时间不被访问的页面。这种算法是最理想的算法，但是由于这个衡量标准只能在上帝视角才知道，因此无法实现。但是可以作为衡量其他算法的一个标准</p>
<p>b)   <strong>先入先出置换算法FIFO</strong>：维护一个<strong>先进先出队列</strong>，最先进入内存的页面被淘汰。</p>
<p>算法实现简单，但是当为进程分配的内存页增加时，缺页率反而会上升，称为Belady异常。</p>
<p>c)    <strong>最近最久页面置换算法LRU</strong>：淘汰最近最久没有被使用的页面。页表中记录分配一个字段，记录这个页面没被使用的时间。Mysql里边，当buffer pool满了的时候，淘汰页面用的就是这个算法。</p>
<p>d)   <strong>时钟页面置换算法：</strong>可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2023/02/16/3%E5%85%AB%E8%82%A1_JVM/</url>
    <content><![CDATA[<h1 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h1><p>​    JVM管理的内存区域称为运行时数据区，包括以下几个部分：</p>
<p>​    <strong>线程共享的：</strong></p>
<ol>
<li>堆</li>
<li>方法区（JDK8之后变为本地内存中的元空间）</li>
</ol>
<p>​    <strong>线程私有的：</strong></p>
<ol>
<li><p>虚拟机栈</p>
</li>
<li><p>本地方法栈</p>
</li>
<li><p>程序计数器</p>
</li>
</ol>
<span id="more"></span>

<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>​    可以看作当前进行线程所执行字节码的行号指示器。</p>
<p>​    作用：</p>
<ol>
<li>代码执行中的跳转、循环等流程依赖于程序计数器。</li>
<li>线程切换程序计数器保存、恢复线程的执行到哪一步</li>
</ol>
<p>唯一一个不会出现OOM情况内存区域</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>​    每个方法被执行都会创建一个栈帧，方法被调用到执行完毕的过程，对应着栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>​    栈帧包含：局部变量表，操作数栈，动态链接，方法出口</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>​    主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>​    如果一个方法调用其他方法，那么就要使用运行时常量池的该方法的符号引用，将符号引用转化为内存中实际地址的直接引用的过程，叫做动态链接。</p>
<p>​    有些符号引用在类加载阶段或第一次使用时完成饿了转换，称为静态解析；</p>
<p>​    另外一部分在每次运行期间被转换，称为动态链接。</p>
<p>如果线程请求的栈深度大于虚拟机请求所允许的深度，将抛出stackoverflowError,</p>
<p>如果虚拟机栈容量空一动态扩展，则当扩展时无法申请到足够内存空间时，会抛OOM错误。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>​    与虚拟机栈相似，只不过是运行本地方法（Native方法）</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>​    线程共享，几乎所有对象实例都在这里分配内存。</p>
<p>​    新生代 老年代 永久代，都是因为大部分都是基于分代垃圾回收器而得名的，只是一个设计风格，而并非java虚拟机固定的布局。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>​    存储已被JVM加载的类型信息、常量、静态变量、等</p>
<p>​    方法区的具体实现并不是固定的，JDK8之前是永久代实现，JDK8之后就变成本地内存中的元空间了。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>​    位于方法区，编译期生成的各种字面量、<strong>符号引用</strong>，在类加载之后存放到方法区的运行时常量池。</p>
<p>​    一般情况下，类加载后，由符号引用翻译出来的直接引用也存储在运行时常量池。</p>
<p>​    符号引用：在一个类中（当然不仅是类，还包括类的其他部分，比如方法，字段等），用到其他类（或其他类的方法、字段等），编译时并不知道其具体内存地址，要等类加载之后才知道，因此先用一个符号引用来表示。</p>
<p>​    在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>​    位于本地内存。</p>
<h2 id="一个对象的创建过程"><a href="#一个对象的创建过程" class="headerlink" title="一个对象的创建过程"></a>一个对象的创建过程</h2><p><strong>1.</strong>    <strong>类加载检查</strong></p>
<p>​    当虚拟机遇到一个new 指令时，首先检查能否在常量池定位到对应的类的符号引用，再检查该类是否被加载过，如果没有必须先执行类加载过程。</p>
<ol start="2">
<li><strong>分配内存</strong></li>
</ol>
<p>​    对象所需的内存大小在类加载完成后便可确定，分配内存就是在堆空间划出一块固定内存给新建的对象。有两种方式，1. “指针碰撞”：内存空间是规整的； 2. “空闲列表”:内存空间不规整； 能否规整看垃圾收集器是否有空间压缩整理功能。</p>
<ol start="3">
<li><strong>初始化零值</strong></li>
</ol>
<p>··   将对象的内存空间（不包括对象头）都初始化为0，保证Java对象不用赋初值就能直接使用。</p>
<ol start="4">
<li><strong>设置对象头</strong></li>
</ol>
<p>​    对象头包扩：对象的类型指针，hashCode, 线程的锁信息，对应的元数据信息等。</p>
<ol start="5">
<li><strong>执行 init 方法</strong></li>
</ol>
<p>​    按照程序员设置的参数，执行初始化方法。</p>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="一个类的生命周期"><a href="#一个类的生命周期" class="headerlink" title="一个类的生命周期"></a>一个类的生命周期</h2><p>加载 验证 准备 解析 初始化 使用 卸载</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/JVM/p1.png?raw=true" alt="p1.png"></p>
<p>类加载过程包括：加载-&gt;连接-&gt;初始化 ， 连接过程包括：验证、准备、解析。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><strong>加载：</strong></p>
<p>​    通过<strong>类加载器</strong>完成，具体用哪个加载器，通过双亲委派模型选取。</p>
<ol>
<li>虚拟机获得类的二进制字节流Class文件</li>
</ol>
<p>​       获取方式多样：源程序.java编译得来，压缩包jar、网络传输Web Applet 、运行时动态生成：动态代理</p>
<ol start="2">
<li>将字节流代表的静态存储结构，转化为方法区内的运行时数据结构。</li>
<li>在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类数据的访问接口<strong>。</strong></li>
</ol>
<p><strong>验证：</strong></p>
<p>​    保证Class文件中的信息是否正确，且不会危害虚拟机安全：</p>
<p>​    Class文件格式是否正确，字节码语义是否符合逻辑，符号引用的验证</p>
<p><strong>准备</strong>：</p>
<p>​    为静态变量(类变量，static修饰)分配内存，并设置初值为0；</p>
<p>​    在JDK8之前，Class对象与静态变量存储在方法区（JDK8之前方法区由永久代实现）；</p>
<p>JDK8之后，Class对象与静态变量放在Java堆里了。</p>
<p>​    Public static int value &#x3D; 123;</p>
<p>​    准备阶段后，value为0，而不是123，赋值为123要等到类的初始化，通过<code>&lt;clinit&gt;()</code>方法；</p>
<p>​    而如果final修饰静态变量，在准备阶段就会直接被赋值。</p>
<p><strong>解析</strong>：</p>
<p>​    将符号引用（类的，方法，字段，等）转化为直接引用</p>
<p><strong>初始化</strong>:</p>
<p>​    根据程序员的代码，主观初始化静态变量和其他资源。这个阶段就是执行类构造器的<clinit>()方法的过程，这个方法是Javac编译器的自动生成物。</p>
<p>​    <clinit>()收集静态变量的赋值行为和静态语句块static{}</p>
<p>​    即  public static int value &#x3D; 123;</p>
<p>​       static { value &#x3D; 456;}</p>
<p>​    按照他们在源文件中出现的顺序进行。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>​    类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</p>
<p>每个 Java 类都有一个引用指向加载它的 ClassLoader。</p>
<p>数组类不是通过 ClassLoader 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</p>
<p><strong>类加载器的主要作用就是加载</strong> <strong>Java</strong> <strong>类的字节码（</strong><code>.class</code><strong>文件）到</strong> <strong>JVM</strong> <strong>中（在内存中生成一个代表该类的</strong><code>Class</code><strong>对象）</strong></p>
<p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/JVM/p2.png?raw=true" alt="p2.png"></p>
<h2 id="双亲委派模型："><a href="#双亲委派模型：" class="headerlink" title="双亲委派模型："></a>双亲委派模型：</h2><p>​		先判断这个类有没有被加载过，如果加载过直接返回，没加载过就走加载流程。</p>
<p>​		一个类加载器收到加载请求，要先把请求委派给父类加载器，这个请求会一直传递到最顶层类加载器；</p>
<p>​		只有父类加载器反馈加载不了（它的搜索范围内找不到class文件），子加载器才能加载。</p>
<p>​		这种父子关系不是通过<strong>继承</strong>实现的，而是使用<strong>组合</strong>关系来复用父加载器的代码</p>
<p>​		好处：双亲委派模型主要是为了类加载的稳定性，可以避免加载相同名字的类造成混乱，比如Object类存放在rt.jar，由启动类加载器加载，如果用户自己编了一个Object类，类加载请求最终会传递到最顶层的启动类加载器，判断Object类加载过了，就不会加载用户的Object类了。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="为什么垃圾回收主要针对堆和方法区，而虚拟机栈，本地方法栈，程序计数器不需要？"><a href="#为什么垃圾回收主要针对堆和方法区，而虚拟机栈，本地方法栈，程序计数器不需要？" class="headerlink" title="为什么垃圾回收主要针对堆和方法区，而虚拟机栈，本地方法栈，程序计数器不需要？"></a>为什么垃圾回收主要针对堆和方法区，而虚拟机栈，本地方法栈，程序计数器不需要？</h2><p>​		因为虚拟机栈、本地方法栈、程序计数器是线程私有的，随线程生，随线程灭，且每一个栈帧所需的大小在编译期即可确定，不受程序运行期变量数据的影响，因此内存的分配和回收都具有确定性，因此不需要过多考虑如何回收。</p>
<p>​		而堆和方法区中的内存分配受不同运行情况影响，比如一个接口的多个实现类所需内存不同，一个方法执行不同条件分支所需内存也可能不一样，因此只有处于运行期间才能指导会创建哪些对象，创建多少对象。</p>
<h2 id="Java引用分类"><a href="#Java引用分类" class="headerlink" title="Java引用分类"></a>Java引用分类</h2><ol>
<li><p>强引用</p>
<blockquote>
<p>程序代码中最常见的引用方式，只要强引用关系还在，被引用对象永远不能被回收。</p>
</blockquote>
</li>
<li><p>软引用</p>
<blockquote>
<p>用来描述一些还有用，但非必须的对象。被软引用关联的对象，在系统将要发生内存溢出异常前，会将这些对象列入回收范围，进行第二次回收。</p>
</blockquote>
</li>
<li><p>弱引用</p>
<blockquote>
<p>用来描述非必须对象。弱引用关联的对象只能生存到下一次垃圾收集发生。</p>
</blockquote>
</li>
<li><p>虚引用</p>
<blockquote>
<p>不影响对象生存时间，也无法通过虚引用获取对象实例。为对象设置虚引用的唯一目的就是：为了在这个对象被回收时收到一个系统通知。</p>
</blockquote>
</li>
</ol>
<h2 id="死亡对象的判定方法"><a href="#死亡对象的判定方法" class="headerlink" title="死亡对象的判定方法"></a>死亡对象的判定方法</h2><blockquote>
<p>对象死亡即不存在对该对象的引用。</p>
</blockquote>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>​    	给对象中添加一个引用计数器：每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
<p>​    	这个方法简单，效率高，但是无法解决两个对象循环引用的现象，因此现代虚拟机不采用这种方式。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>​    	通过一系列称为”GC roots”对象为根节点，通过引用关系向下查找，如果一个对象不和任何一个GC roots的调用链相连，则说明该对象不可达，将被判定为回收对象。</p>
<p>​    	可作为GC roots的对象包括以下几种：</p>
<ol>
<li>虚拟机栈中引用的对象。</li>
<li>方法区类静态变量引用的对象。</li>
<li>被同步锁synchronized关键字持有的对象</li>
<li>方法去常量池引用的对象等</li>
</ol>
<h2 id="可达性分析出对象可以被回收，就代表一定会被回收吗？"><a href="#可达性分析出对象可以被回收，就代表一定会被回收吗？" class="headerlink" title="可达性分析出对象可以被回收，就代表一定会被回收吗？"></a>可达性分析出对象可以被回收，就代表一定会被回收吗？</h2><p>不一定。</p>
<p>当对象通过可达性分析，判定为不可用对象后，会被第一次标记，之后将对象放入一个名叫F-Queue的队列里，再进行一次筛选，判断有没有必要执行该对象的finalize（）方法，【如果该对象没有重写finalize()方法，或者finalize()方法已经被调用过一次了，就判定为没必要执行finalize()方法。】</p>
<p>Finalize方法是对象逃脱死亡的最后一次机会，如果对象重新与引用链上的任何一个对象建立关联，即使是把自己this赋给某个类变量或者对象的成员变量也行，那么对象就会逃脱回收。</p>
<p>所以说Object类的finalize方法设计的比较糟糕，它是Java诞生时对C C++程序员容易接受的一项妥协，运行代价昂贵，不确定性大，JDK9之后就开始逐渐弃用了。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>​    	主要针对分代收集理论，“分代收集”的几个假说</p>
<ul>
<li><p>弱分代假说：绝大多数对象都是朝生夕灭的（新生代有98%熬不过第一轮垃圾回收）</p>
</li>
<li><p>强分代假说: 熬过越多次垃圾回收的对象就越难以消亡</p>
</li>
<li><p>跨代引用假说：跨代引用相对于同代引用来说仅占少数;</p>
</li>
</ul>
<p>部分收集Partial GC:</p>
<ul>
<li>新生代收集Minor GC&#x2F;Young GC</li>
<li>老年代收集 Major GC&#x2F;Old GC</li>
<li>混合收集 Mixed GC</li>
</ul>
<p>整堆收集Full GC:</p>
<ul>
<li>收集整个Java堆和方法区的垃圾收集</li>
</ul>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>​    	最基础的垃圾收集算法，通过垃圾判定，对对象进行标记，标记之后统一回收所标记的对象。</p>
<p>​    	缺点：执行效率不稳定，并且会产生内存碎片。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>​    	最早的标记-复制算法采用“半区复制”，就是将内存空间分成两个大小相等的块，每次只是用一个，当一个满了，将活着的对象复制到另一个块，其余的回收。</p>
<p>​    	不会产生内存碎片，但是代价是可用的内存空间变少了。</p>
<p>​    	因此后来根据对象“朝生夕灭”的特性，提出了更优化的标记-复制算法，将新生代分为一个Eden区和两个Suivivor区，比例为8：1：1；</p>
<p>​    	每次给对象分配内存，只是用Eden区和其中一个Suivivor区，垃圾回收时，将存活的对象复制到另一个Suivivor区，如果空间不足，就通过<strong>分配担保机制</strong>，直接进入老年代。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>​    先标记，之后将存活对象向空间一端移动，然后清除掉边界外的空间。</p>
<p>​    不会产生内存碎片，但是对象移动的效率慢，多用于老年代。</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>​    比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<p>​    年龄增大到15岁，将从新生代晋升到老年代。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>​    	如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<p>​    	现代虚拟机采用的垃圾收集器多采用：</p>
<p>​		新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2023/02/28/4%E5%85%AB%E8%82%A1_JUC/</url>
    <content><![CDATA[<h1 id="JUC基本概念"><a href="#JUC基本概念" class="headerlink" title="JUC基本概念"></a><strong>JUC基本概念</strong></h1><p>JUC : 使用java.util.concurrent包编程，完成多线程并发编程。</p>
<p>并发编程的目的：充分利用CPU资源，提高cpu执行效率</p>
<p>并发编程可能带来的问题：内存泄漏、死锁、线程不安全等</p>
<span id="more"></span>

<h2 id="JVM能直接开启线程吗"><a href="#JVM能直接开启线程吗" class="headerlink" title="JVM能直接开启线程吗"></a>JVM能直接开启线程吗</h2><p>java只能通过native本地方法去调用，来和操作系统之间进行交互，Java不能直接操控系统底层</p>
<h2 id="并行-并发"><a href="#并行-并发" class="headerlink" title="并行 并发"></a>并行 并发</h2><blockquote>
<p>并行：微观上线程同时进行，多核技术  ；  并发：微观上交替进行，宏观上同时进行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object类的wait-notify-notifyAll"><a href="#Object类的wait-notify-notifyAll" class="headerlink" title="Object类的wait(), notify(),  notifyAll()"></a>Object类的wait(), notify(),  notifyAll()</h2><p>都是C语言编写的本地native代码</p>
<blockquote>
<p>执行这几个方法的线程都必须先获得某个对象的锁，因此必须在synchronized作用的语句块或方法中调用</p>
</blockquote>
<p><strong>wait</strong>() : 调用该方法的线程，释放掉某一对象的锁，进入等待池</p>
<p><strong>notify</strong>():唤醒处在等待该对象的线程，等待池中的线程开始争夺这个对象锁。</p>
<blockquote>
<p>notify()：等待池中的线程被随机唤醒，但Hotspot虚拟机是顺序唤醒的</p>
<p>notifyAll():默认情况是最后进入的会先被唤起来,即LIFO的策略</p>
</blockquote>
<p><strong>notify()或者notifyAll()调用时并不会真正释放对象锁, 必须等到synchronized方法或者语法块执行完才真正释放锁.</strong></p>
<h2 id="java线程的6个状态"><a href="#java线程的6个状态" class="headerlink" title="java线程的6个状态"></a>java线程的6个状态</h2><p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" alt="Java 线程状态变迁图"></p>
<ol>
<li><p>new初始  </p>
</li>
<li><p>runnable运行  </p>
<p>相当于操作系统进程的<strong>就绪态</strong>+<strong>运行态</strong> </p>
<p>就绪态：获得了除CPU外的一切资源</p>
</li>
<li><p>blocked阻塞</p>
<p>线程由于请求的资源（java对象）被锁住了而等待，具体来说是等待请求对象Object的monitor lock，Object通过监视器monitor来保证自身的线程安全，拿到监视器锁的线程才能访问该对象。</p>
</li>
<li><p>waiting等待  </p>
<p>表示线程处于无限期的等待状态，要等到其他线程的notify()或notifyAll(),或者该线程join的线程终止。</p>
</li>
<li><p>timed_waiting有限时间等待</p>
<p>表示线程处于有限期的等待状态，可能是该线程使用了sleep方法，或者调用了有限时间的Object.wait()方法，或有限时间的Thread.join()方法</p>
<blockquote>
<p>join方法，在一个线程t1中调用t2.join(),表示t1线程主动进入等待状态，等待t2线程终结才能重新运行。</p>
<p>往往适用于t1线程需要等待t2线程的结果，要等待t2执行完毕再去运行</p>
</blockquote>
</li>
<li><p>terminated终止</p>
</li>
</ol>
<h2 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep() 和 wait()的区别"></a>sleep() 和 wait()的区别</h2><ol>
<li>来自不同的类，sleep是Thread的一个本地静态方法，wait()是Object的本地普通方法。</li>
<li>是否释放锁</li>
</ol>
<ul>
<li>sleep()方法，线程进入休眠，但不会释放锁</li>
<li>wait()方法，释放锁，线程进入等待池，等待notify唤醒</li>
</ul>
<ol start="3">
<li>适用范围</li>
</ol>
<ul>
<li>wait只能用在同步代码块中，sleep在线程代码任意地方都能用</li>
</ul>
<h2 id="可以直接调用Thread的run方法吗？"><a href="#可以直接调用Thread的run方法吗？" class="headerlink" title="可以直接调用Thread的run方法吗？"></a>可以直接调用Thread的run方法吗？</h2><p>可以的，但是如果直接调用Thread的run方法，会当作main线程下的普通方法去执行，并不是多线程工作；</p>
<p>调用Thread的start方法，才是开启多线程执行，自动执行run方法。</p>
<h2 id="线程上下文切换？"><a href="#线程上下文切换？" class="headerlink" title="线程上下文切换？"></a>线程上下文切换？</h2><p>当发生以下情况时，会发生进程的上下文切换：</p>
<ol>
<li>当一个线程时间片用完了</li>
<li>线程中调用了sleep wait方法，主动让出CPU</li>
<li>线程运行中请求了阻塞型的系统调用，如请求IO</li>
</ol>
<p>当线程退出CPU使用时，会保存当前的程序计数器，栈信息等，当线程重新获得CPU使用权时，再恢复现场。</p>
<blockquote>
<p>由于上下文切换时，保存和恢复现场也需要占据一定的CPU时间，因此频繁上下文切换会降低CPU利用率。</p>
</blockquote>
<h2 id="Runnable-和-Callable"><a href="#Runnable-和-Callable" class="headerlink" title="Runnable 和 Callable"></a>Runnable 和 Callable</h2><p>创建线程： new Thread(Runnable target)，传入一个Runnable实现类</p>
<p>Runnable是一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask是Runnable的实现类，可作为Callable的适配类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">System.out.println(futureTask.get());  <span class="comment">//获取call()的返回值</span></span><br></pre></td></tr></table></figure>

<p>callable接口类似于runnable，但是call()方法能够有返回值，需要抛异常。</p>
<p>callable的返回结果可以通过FutureTask.get()方法获取，返回结果有缓存，可能阻塞【放到代码最后，或者异步方式获取】</p>
<h1 id="java锁"><a href="#java锁" class="headerlink" title="java锁"></a><strong>java锁</strong></h1><blockquote>
<p> java锁的实现方式有synchronized关键字和Lock接口</p>
</blockquote>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized是java内置关键字，在java早期版本，synchronized是重量级锁，因为监视器锁依赖于底层操作系统的<strong>Mutex Lock</strong>实现，Java线程是映射到操作系统的原生线程上的，线程切换需要用户态与核心态之间转换，时间成本较高。</p>
<p>在Java6之后，对synchronized进行了优化，较少了锁的开销，因此现在很多开源框架使用synchronized</p>
<blockquote>
<p>synchronized如何使用？</p>
<ol>
<li>修饰实例方法：锁实例对象</li>
<li>修饰静态方法：锁当前类的Class对象</li>
<li>修饰代码块，锁代码块括号里配置的对象。</li>
</ol>
</blockquote>
<p>普通方法不受锁的影响，在main线程被调用。</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock接口，具体实现类有ReentrantLock, </p>
<p>使用方法：</p>
<ol>
<li>Lock l &#x3D; …</li>
<li>l.lock();  &#x2F;&#x2F;上锁</li>
<li>try{&#x2F;&#x2F;执行业务代码}  finally{l.unlock() &#x2F;&#x2F;解锁}</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) System.out.println(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock接口的实现是通过聚合了一个<strong>队列同步器(AbstractQueuedSynchronizer)AQS</strong>的子类来实现的。</p>
<p>锁是面向锁的使用者，隐藏了实现细节；</p>
<p>同步器是面向锁的实现者，简化了锁的实现方式，屏蔽了底层操作系统的一些细节。</p>
<h3 id="什么是可重入锁？"><a href="#什么是可重入锁？" class="headerlink" title="什么是可重入锁？"></a>什么是可重入锁？</h3><p>可重入是指当一个线程拥有了某一个资源的锁之后，可以再次上锁。</p>
<p>比如一个线程调用了一个对象的同步方法，对这个对象上了一次锁，在这个方法里还需再调用该对象的另一个同步方法，那么可重入锁是支持再次上锁的。不可重入锁就会被自己阻塞。</p>
<p>ReentrantLock和synchronized都是可重入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span>  &#123;</span><br><span class="line">        B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="synchronized和Lock的区别？"><a href="#synchronized和Lock的区别？" class="headerlink" title="synchronized和Lock的区别？"></a>synchronized和Lock的区别？</h2><p>主要区别：</p>
<ol>
<li>synchronized是关键字，Lock是一个接口</li>
<li>synchronized会自动释放锁，lock必须手动释放锁</li>
</ol>
<p>Lock的具备的优点：</p>
<ol>
<li>能够通过tryLock()方法，<strong>尝试非阻塞的获取锁</strong></li>
<li>获取到锁的线程，<strong>能够被中断</strong>，线程被中断后抛出终端异常，同时锁被释放；</li>
<li>获取锁有超时机制，到达截止时间还获取不到锁会直接返回。</li>
</ol>
<p>因此Lock锁的可操作性更强。</p>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a>synchronized实现</h3><p>资源类的操作方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(判断条件) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait(); <span class="comment">//等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">    <span class="built_in">this</span>.notifyAll();  <span class="comment">//通知其他线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>资源类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= <span class="number">5</span>) &#123;     <span class="comment">//5 是仓库最大容量</span></span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;     <span class="comment">//业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Producer  &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + num);</span><br><span class="line">        <span class="comment">//通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer  &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + num);</span><br><span class="line">        <span class="comment">//通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><blockquote>
<p>资源类操作方法中，如果判断等待条件要用while,如果用if，在多生产者、消费者时，会出现<strong>虚假唤醒</strong> ，造成逻辑越界，也就是超过我们设定的容量范围</p>
</blockquote>
<p><strong>产生原因</strong>：</p>
<p>虚假唤醒是因为，当我们notify的时候，唤醒了所有等待的线程，由于是If判断，被唤醒的线程在拿到资源对象的监视器锁之后，会直接运行wait()方法后面的业务代码，不会再管此时的判断条件，就会导致业务逻辑上的越界。</p>
<p>虚假唤醒是因为：</p>
<ul>
<li><p>我们一个线程notify的时候，唤醒了所有等待的线程；</p>
</li>
<li><p>并且如果是if条件判断，被唤醒的线程如果拿到监视器锁，就会接着上次wait的代码继续执行，就不管这个if约束了；</p>
</li>
<li><p>最先获得监视器锁的线程，执行业务逻辑是没有问题的，但是后续获得监视器锁的其他线程，如果继续执行业务代码时，就可能导致逻辑上的越界。</p>
<p>ps:某一时刻，资源为0，所有消费者进程进入等待，生产者生产了一些资源，唤醒了消费者进程，之后的一段时间内，消费者消费的速度大于生产速度（cpu时间片分配的更多），第一个获得锁的消费者1执行了一段时间代码，cpu时间片用光了，消费者2获得锁，也要执行业务代码，就可能导致资源小于0了。</p>
</li>
</ul>
<p><strong>解决方式</strong>：</p>
<p>将if换成while，那么一个线程被唤醒的时候，会再判断以下逻辑条件，如果不满足则再次进入等待。</p>
<h3 id="JUC-Lock实现"><a href="#JUC-Lock实现" class="headerlink" title="JUC Lock实现"></a>JUC Lock实现</h3><p>JUC.Lock接口 替换synchronized关键字</p>
<p>JUC.Condition接口 替换Object监视器锁的wait和notify方法</p>
<blockquote>
<p>Condition.await() -&gt; Object.wait()</p>
<p>Condition.signal() -&gt; Object.nofity()</p>
<p>Condition.signalAll() -&gt; Object.notifyAll()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data2</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data2.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data2.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data2.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data2.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();        <span class="comment">//Lock接口  替代了synchronized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();     <span class="comment">//Condition接口  替代了Object监视器的wait,notify方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= <span class="number">5</span>) &#123;     <span class="comment">//5是最大容量</span></span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;     <span class="comment">//业务</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Producer  &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + num);</span><br><span class="line">            <span class="comment">//通知其他线程</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">0</span>) &#123;     <span class="comment">//5是最大容量</span></span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num--;     <span class="comment">//业务</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Producer  &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + num);</span><br><span class="line">            <span class="comment">//通知其他线程</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JUC-Lock-x2F-Condition实现方式的优点"><a href="#JUC-Lock-x2F-Condition实现方式的优点" class="headerlink" title="JUC Lock&#x2F;Condition实现方式的优点"></a>JUC Lock&#x2F;Condition实现方式的优点</h4><blockquote>
<p>JUC.Condition能够实现精准的<strong>通知</strong>某个线程唤醒，将资源类创建多个condition，不同方法锁不同condition，通知的时候调用指定的condition.notify()</p>
</blockquote>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock是一个接口，ReentrantReadWriteLock是它的实现类，在ReentrantLock上实现了更高粒度的锁。</p>
<p>readWriteLock.readLock();加读锁</p>
<p>readWriteLock.writeLock();加写锁</p>
<p>读-读共享，写-写互斥，读-写互斥。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">readWriteLock.readLock();</span><br><span class="line">readWriteLock.writeLock();</span><br></pre></td></tr></table></figure>

<h1 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a><strong>并发集合</strong>类</h1><p>Java普通集合进行并发写操作，可能会报ConcurrentModificationException并发修改异常。</p>
<h2 id="ArrayList的并发问题"><a href="#ArrayList的并发问题" class="headerlink" title="ArrayList的并发问题"></a>ArrayList的并发问题</h2><ol>
<li>List<String> list &#x3D; new Vector&lt;&gt;();</li>
<li>List<String> list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</li>
<li>List<String> list &#x3D; new CopyOnWriteArrayList&lt;&gt;() ;</li>
</ol>
<p>1.Vector的添加和删除方法都有synchronized关键字作用，都是同步方法；</p>
<p>2.Collections工具类的synchronizedList方法，能够将容器变为线程安全的，也是基于synchronized关键字的。</p>
<p>3.CopyOnWriteArrayList在JUC并发包下的一个类，通过ReentrantLock+写时复制+volatile关键字保证并发安全。</p>
<blockquote>
<p>读操作不加锁，写操作时先加ReentrantLock锁，</p>
</blockquote>
<blockquote>
<p>然后利用写时复制（COW），复制原数据数组，然后在新数组上进行写操作，写操作完成之后，将新数组的引用赋给容器。最后解锁。</p>
</blockquote>
<blockquote>
<p>并通过volatile关键字保证可见性，让其他线程能立刻感知到。</p>
</blockquote>
<p>优点：相比于synchronized关键字，更加轻量化，并发效率更高。</p>
<h2 id="HashSet-并发问题"><a href="#HashSet-并发问题" class="headerlink" title="HashSet 并发问题"></a>HashSet 并发问题</h2><ol>
<li>List<String> list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</li>
<li>List<String> list &#x3D; new <strong>CopyOnWriteArraySet</strong>&lt;&gt;()</li>
</ol>
<h2 id="HashMap并发问题"><a href="#HashMap并发问题" class="headerlink" title="HashMap并发问题"></a>HashMap并发问题</h2><ol>
<li>Collections.synchronizedMap();</li>
<li>HashTable  &#x2F;&#x2F;基于synchronized关键字</li>
<li>ConcurrentHashMap</li>
</ol>
<h3 id="ConcurrentHashMap-底层实现原理"><a href="#ConcurrentHashMap-底层实现原理" class="headerlink" title="ConcurrentHashMap  底层实现原理"></a>ConcurrentHashMap  底层实现原理</h3><p><a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#concurrenthashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB">Java集合常见面试题总结(下) | JavaGuide(Java面试+学习指南)</a></p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>非阻塞的线程安全的队列，采用循环CAS方式实现</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列BlockingQueue,是一个线程安全接口，</p>
<p>之所以阻塞，是因为队列有<strong>容量</strong>，容量满了添加就会阻塞，容量为0读取元素也会阻塞。</p>
<p>主要api有4组类型，与线程不安全的队列相比，多了后边两组。</p>
<p><img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230421195340584.png" alt="image-20230421195340584"></p>
<p>主要实现类:</p>
<ul>
<li>ArrayBlockingQueue  :数组实现</li>
<li>LinkedBlockingQueue ：链表实现</li>
<li>PriorityBlockingQueue : 支持优先级排序</li>
<li>SynchronousQueue: 是一个不存储元素(可理解为容量为0，或理解为时刻都保持full)的阻塞队列，作用是起一个传递作用。使用时，一般只用put和take操作，一个线程put之后阻塞，然后等待另一个线程的take操作。</li>
</ul>
<h1 id="JUC并发工具类"><a href="#JUC并发工具类" class="headerlink" title="JUC并发工具类"></a>JUC并发工具类</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><blockquote>
<p>我们new 一个 CountDownLatch实例的时候，会创建一个计时器并设置计数值，</p>
<p>每有一个线程调用countDown()方法，计数值减一；</p>
<p>主线程会调用CountDownLatch实例的await方法，阻塞等待计时器被清零才会被唤醒,或者等到超时时间；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行完毕&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> countDownLatch.await(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;6个线程全部执行结束&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束时计数器是否被置0 : &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用途：某线程如果需要等待其他多个线程的结果才能执行，可以使用CountDownLatch实现这种线程通信。</p>
<h3 id="join也能实现，为什么还要用CountDownLatch？"><a href="#join也能实现，为什么还要用CountDownLatch？" class="headerlink" title="join也能实现，为什么还要用CountDownLatch？"></a>join也能实现，为什么还要用CountDownLatch？</h3><p>​		join是让当前执行线程等待Join线程是否结束，判断依据是看join线程是否存活，而CountDownLatch不必等到join线程结束，只要有线程完成了跟主线程相关的逻辑，就可以调用countdown方法，计数器就会减一；而Join还需要等后续代码执行完毕，所以说CountDownLatch更加灵活，能够使主线程的等待时间更短。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><blockquote>
<p>创建CyclicBarrier实例时，传入一个屏障数量参数，每个线程调用await方法后，告诉CyclicBarrier我已经到达，然后进入阻塞；</p>
<p>当到达的线程达到设定的屏障数量时，所有到达的线程都被唤醒。</p>
<p>之后CyclicBarrier重置计数，等待新的线程到达。</p>
</blockquote>
<p>CyclicBarrier还有一个更加高级的构造方法，传入参数时可以传入一个Runnable实现类，表示线程到达数量到设定值时，优先执行传入的Runnable实现类中的行为动作。</p>
<h2 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h2><ol>
<li><p>CountDownLatch计数器只能用一次，CyclicBarrier计数可以循环使用。</p>
</li>
<li><p>CountDownLatch是等待多个线程完成，阻塞的是等待线程，有一个逻辑上的先后关系；</p>
<p>CyclicBarrier是控制一组线程全都完成才放行，阻塞的是这组里先到达的线程，这组里的线程是一个并列的关系，谁先执行要看cpu分配。</p>
</li>
</ol>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>​		Semaphore可用作并发线程数控制，即流量控制。</p>
<blockquote>
<p>Semaphore semaphore &#x3D; new Semaphore(5);  &#x2F;&#x2F;传入最大并发线程数</p>
<p>线程中调用semaphore.acquire(), 获得许可证</p>
<p>线程结束时调用semaphore.release()，释放许可证</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the permit!&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; released the permit!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java的13个原子操作类"><a href="#Java的13个原子操作类" class="headerlink" title="Java的13个原子操作类"></a>Java的13个原子操作类</h1><p>从JDK1.5开始，提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了简单、高效、线程安全地更新变量的方式。</p>
<p>包括 原子更新基本类型类，原子更新数组，原子更新引用类型，原子字段类型（每个里又有Integer,Long,Boolean类型）共13种。</p>
<p>原子类通过Unsafe类来实现，底层使用<strong>CAS</strong>操作，能够直接操作内存中的值。</p>
<h2 id="synchronized，ReentrantLock，CAS的区别"><a href="#synchronized，ReentrantLock，CAS的区别" class="headerlink" title="synchronized，ReentrantLock，CAS的区别"></a>synchronized，ReentrantLock，CAS的区别</h2><p>synchronized是一种悲观锁，它是独占的，当一个线程获得到锁时，其他请求线程会进入阻塞态,就会涉及到上下文切换，浪费cpu资源；</p>
<p>ReentrantLock也是一种悲观锁，不过跟synchronized不同的是，它有一个tryLock方法，能尝试非阻塞的获取锁，返回一个布尔值，我们可以在代码逻辑上实现一个非阻塞获取锁。</p>
<p>CAS是系统原语，是一种乐观锁。它采用自旋的方式，循环比较判断，会一直占用cpu，因此不会发生上下文切换。</p>
<p>在系统任务并发量较小时，采用CAS开销更小；如果并发量较大，CAS会长时间循环，CPU资源反而消耗更大。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><blockquote>
<p>池化技术：事先准备好资源，并能重复利用，<strong>降低创建和销毁的资源消耗</strong>，提高响应速度，还能够对资源进行统一管理分配，<strong>提高可管理性</strong>。</p>
</blockquote>
<h2 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h2><blockquote>
<p>主线程执行ThreadPoolExecutor的execute后，线程池的处理流程是怎样的？</p>
</blockquote>
<ol>
<li>如果当前运行线程数小于corePoolSize**,创建**新线程来执行；（目的是先把核心线程池允许的最大线程都创建出来，但是如果线程池调用了presstartAllCoreThreads()方法，线程池会提前创建好核心线程池中的所有线程，并启动）</li>
<li>当运行的线程大于等于corePoolSize，则将任务(Runnable实现类)加入到阻塞队列BlockingQueue;</li>
<li>如果BlockingQueue队列已经满了，并且当前线程数小于maximumPoolSize，则<strong>创建</strong>新的<strong>非核心线程</strong>来处理<strong>当前</strong>进来的任务【这里不是优先处理队列中的，而是后进来的】</li>
<li>如果BlockingQueue队列已经满了，并且当前线程数大于等于maximumPoolSize，那么就交给饱和策略来处理。</li>
</ol>
<blockquote>
<p> 其中步骤1和步骤3，由于需要创建新线程，所以需要获得全局锁；</p>
<p>在线程池完成预热（执行线程数大于等于corePoolSize）后，几乎所有execute方法调用都是执行步骤2，无需获取全局锁。</p>
</blockquote>
<blockquote>
<p>线程池的线程执行任务分为两种情况：</p>
<ol>
<li>上述步骤1 和 步骤3，由于直接新建了线程，则立刻由新建的线程执行该任务；</li>
<li>线程池中的线程执行完原有任务后，会返回从BlockingQueue中获取任务来执行.</li>
</ol>
</blockquote>
<blockquote>
<p>核心线程一旦创建，会一直存活，执行完一个任务后，会反复从BlockingQueue中获取任务来执行。</p>
<p>非核心线程，也就是核心线程池外的线程，如果阻塞队列空了，它就会空闲(idle)，超过keepAliveTime时，就会被终结。</p>
</blockquote>
<h2 id="线程池7大核心参数"><a href="#线程池7大核心参数" class="headerlink" title="线程池7大核心参数"></a>线程池7大核心参数</h2><p>ThreadPoolExecutor的构造方法(前5个参数是必须的)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>int corePoolSize ：核心线程数</li>
<li>int maximumPoolSize ：线程池最大线程数</li>
<li>long keepAliveTime ：非核心线程的空闲存活时间</li>
<li>TimeUnit unit ：keepAliveTime 的单位</li>
<li>BlockingQueue<Runnable> workQueue : 阻塞队列</li>
<li>ThreadFactory threadFactory：制造线程的工厂</li>
<li>RejectedExecutionHandler handler ：决绝策略（饱和策略）</li>
</ol>
<h3 id="4个拒绝策略"><a href="#4个拒绝策略" class="headerlink" title="4个拒绝策略"></a>4个拒绝策略</h3><p>当有新任务传进线程池，如果阻塞队列已满，并且当前运行线程数大于等于maximumPoolSize，就会执行拒绝策略。</p>
<img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230422165554721.png" alt="image-20230422165554721" style="zoom:50%;" />

<p>AbortPolicy</p>
<p>直接拒绝，并抛异常</p>
<p>CallerRunsPolicy</p>
<p>哪个线程调用该线程池的execute方法，哪个线程就去执行这个任务</p>
<p>DiscardPolicy</p>
<p>直接拒绝，不抛异常</p>
<p>DiscardOldestPolicy</p>
<p>丢弃队列中最久没被执行的任务【poll队首】，然后再重新调用execute方法执行该任务【再执行execute方法也不见得直接就有位置加到BlockingQueue的队尾了，有可能这个时候有其他任务又给填满了，那么就需要再次poll队首任务，再execute这个任务，直到给它加入到阻塞队列当中去】</p>
<h3 id="如何配置线程池参数"><a href="#如何配置线程池参数" class="headerlink" title="如何配置线程池参数"></a>如何配置线程池参数</h3><p>根据任务性质的不同，可以用不同规模的线程池分开处理。</p>
<p>对于CPU密集型任务，尽可能配置小的线程数，如配置最大线程数为N<em>cpu</em> + 1;</p>
<p>对于IO密集型任务，由于每个任务的CPU耗时不是很长，则应配置尽可能多的线程，如2<em>N</em>cpu*。</p>
<p><em>N</em>cpu是指设备的逻辑处理个数，在代码中配置，可通过以下代码获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()  <span class="comment">//获取当前设备的逻辑处理器个数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>CPU密集型与IO密集型？  说的是什么是系统性能的<strong>瓶颈</strong></p>
<p>CPU密集型：计算任务比较繁重的任务，如图像处理，数据加解密这些；每个任务占用CPU时间较长，当CPU全部被占用了之后，再分配线程也无济于事，因此线程数配置少一点。</p>
<p>IO密集型：数据传输、数据存储之类的工作较多，因此瓶颈在系统的IO设备【网卡，磁盘】上。由于时间花费在IO上比较多，而系统处理IO时，线程是阻塞的不占据CPU的，因此可以配置多一点的线程数。</p>
</blockquote>
<h2 id="Executors工厂类"><a href="#Executors工厂类" class="headerlink" title="Executors工厂类"></a>Executors工厂类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>Executors框架下提供的线程池类：</p>
<p>FixedThreadPool</p>
<p>可设置固定核心线程数，阻塞队列LinkedBlockingQueue容量为Integer.MAX_VALUE;</p>
<p>SingleThreadPool</p>
<p>核心线程数为1，阻塞队列为LinkedBlockingQueue，阻塞队列容量为Integer.MAX_VALUE;</p>
<p>CachedThreadPool</p>
<p>核心线程数为0，最大线程数为Integer.MAX_VALUE，阻塞队列为SynchronousQueue，同步队列的容量为0，只转发任务。（来多少都转发，来一个创建一个线程，可能导致OOM）</p>
<p>ScheduledThreadPool</p>
<p>上边的是核心三大类，而ScheduledThreadPool额外实现了ScheduledExectorService,能够对任务进行延迟执行，或定期执行。核心线程数可设置，但是最大线程数为Integer.MAX_VALUE，阻塞队列采用DelayedWorkQueue</p>
<h3 id="线程池不允许使用Executors创建？"><a href="#线程池不允许使用Executors创建？" class="headerlink" title="线程池不允许使用Executors创建？"></a>线程池不允许使用Executors创建？</h3><p>以下是阿里巴巴Java开发手册写的</p>
<img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230421212603178.png" alt="image-20230421212603178" style="zoom:45%;" />

<h1 id="Fork-x2F-Join框架"><a href="#Fork-x2F-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h1><p>Fork&#x2F;Join是一个<strong>并行</strong>执行任务的框架，把一个大任务分割成若干小任务，最终汇总每个小任务结果，得到大任务结果。</p>
<h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>将大任务拆分成若干互不依赖的子任务，将这些子任务放到不同的队列，然后每个队列创建一个单独线程去执行；</p>
<p>但是有的线程执行结束了，有的线程还没结束，这时干完的线程能够去没干完的线程的队列中去窃取任务去做，因此任务队列采用双端队列，这样就可以从队列另一头去拿任务执行。</p>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>java内存模型是抽象出来的，方便对线程间通信进行规定，控制 的模型。</p>
<p>JMM规定：线程之间的共享变量存储在主内存，每个线程又有一个本地内存，存储主内存中的共享变量的副本用于读写。</p>
<p>JMM的主内存对应着实际内存中实例对象，静态变量这些共享资源的内存区域，而本地内存则主要是指执行该线程的CPU的高速缓存Cache.</p>
<p>必须要保证的两点:</p>
<ol>
<li>一个线程对它本地内存的某个变量副本进行写操作时，必须刷新到主内存；</li>
<li>这个刷新操作对其他线程是可见的。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote>
<ol>
<li>可见性：保证多处理器开发中，共享变量的可见性。可见性是指当一个线程修改一个共享变量的时候，其他线程能够读到这个修改的值。</li>
<li>有序性：禁止指令重排</li>
<li>不能保证原子性</li>
</ol>
</blockquote>
<p>synchronized三个都能保证。volatile只能修饰变量</p>
<h3 id="volatile如何保证可见性"><a href="#volatile如何保证可见性" class="headerlink" title="volatile如何保证可见性"></a>volatile如何保证可见性</h3><p>某个线程对带有volatile修饰的共享变量进行写操作时，JVM会向执行该线程的处理器发送一个LOCK信号，这个LOCK信号会触发处理器将缓存写回到内存中去，并且通过锁总线或者“缓存锁定”，确保不会同时有两个缓存同时刷新到内存区域。</p>
<p>而每个处理器通过嗅探，能够知道这一操作，那么其他处理器对于这个共享变量的缓存失效，需要重新到内存中读取数据填充缓冲行。</p>
<h3 id="volatile为什么不能保证原子性"><a href="#volatile为什么不能保证原子性" class="headerlink" title="volatile为什么不能保证原子性"></a>volatile为什么不能保证原子性</h3><p>synchronized保证有一个线程读改写某个共享资源时，就对这个对象上锁了，然后通过锁总线或者“缓存锁定”的方式，阻止其他线程对这个资源缓存的操作。</p>
<p>而volatile只能让其他线程的缓存失效，保持缓存中的一致性，但它并不能阻止其他线程读的操作，如果其他线程的CPU已经将这个缓存数据读到了寄存器里，进行运算了，这个时候即使有线程完成了写操作，让别人的缓存失效也没有用了，人家已经执行了后续步骤了，已经计算得到中间值了，那么最开始的数据被清空了也不会影响继续运行，因此不能保证原子性。</p>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>源代码到实际执行，编译器和处理器会分别对代码进行重排序优化。这些重排序在单线程下运行是没有问题的，但是多线程运行可能会产生问题。</p>
<p>Java编译器在编译的时候，会插入内存屏障指令，来禁止特定类型的处理重排序。</p>
<blockquote>
<p>synchronized能保证有序性，是保证不同线程加锁执行结果的有序性，简单说即串行。但不能禁止指令重排</p>
<p>volatile通过插入内存屏障指令，禁止指令重排，来保证有序性</p>
</blockquote>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>用处：ThreadLocal是解决多线程并发问题的一种思路，我们可以将共享数据放在ThreadLocal中，当有多个线程来访问数据时，就会创建一个变量副本，保存在自己的线程中，每个线程对各自的变量副本进行操作，避免了并发问题。</p>
<p>实现原理：每个线程内部都有一个ThreadLocalMap，ThreadLocalMap内部有一个Entry数组，每个Entry的key是对公共的ThreadLocal的弱引用，value是ThreadLocal中存放的共享数据；因为是弱引用关系，所以在下一次GC时，弱引用关系就会消失，key就变成了Null，无法通过key找到value，而value是强引用的，所以只要线程不终止，就不会被回收；那么此时value既不会被回收，又无法被访问，也就是内存泄漏。</p>
<p>【每个线程内部ThreadLocalMap是有公共的ThreadLocal去维护的，由ThreadLocal去设置值，删除值。】</p>
<p>线程每次调用set(),get()方法，就会给key为null的Entry的value设置为null，这样下次GC的时候value的内存空间就会被回收；但是很有可能线程执行过程中都不调用set,get()方法，因此每次用完还是都要记得调用remove()方法。</p>
<img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230512163458182.png" alt="image-20230512163458182" style="zoom: 33%;" />

<img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230530202046016.png" alt="image-20230530202046016" style="zoom:35%;" />

<blockquote>
<p>ThreadLocalMap 的key设置成弱引用，是为了防止new ThreadLocal对象的那个强引用消失后，还有其他线程的ThreadLocalMap存在对ThreadLocal的强引用，导致ThreadLocal对象无法被回收。【考虑的是ThreadLocal的回收问题】</p>
</blockquote>
<p>但是通常我们把ThreadLocal定义成静态变量的方式，他一直被class对象强引用，不会被GC</p>
<p>应用场景：用ThreadLocal保存格式化日期格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; local = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy:MM:ddHHmm&quot;</span>));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/04/02/6%E5%85%AB%E8%82%A1_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><ol>
<li><p>开闭原则<br> 对扩展开放，对修改关闭。  为了程序的可扩展性好！</p>
</li>
<li><p>里氏代换原则<br> 任何基类可以出现的地方，子类一定可以出现。是继承复用的基石，面向对象设计采用的就是这种思想。这是对开闭原则的补充。</p>
</li>
<li><p>单一职责原则<br> 一个类，一个接口只负责一项职责</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>依赖倒转原则<br> 指的是面向接口的编程方式，要依赖于抽象而不依赖于具体</p>
</li>
<li><p>接口隔离原则<br> 使用多个隔离的接口，比使用单个接口要好</p>
</li>
<li><p>迪米特原则<br> （最少知道原则）减少类之间的耦合</p>
</li>
</ol>
<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1 创建型模式"></a>1 创建型模式</h2><p>隐藏创建对象的逻辑，不是使用new关键字来创建对象。</p>
<blockquote>
<p>单例模式，工厂模式，抽象工厂模式，建造者模式。。。</p>
</blockquote>
<h2 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2 结构型模式"></a>2 结构型模式</h2><p>关注<code>类和对象的组合，即如何将类或对象按某种布局组成更大的结构</code></p>
<blockquote>
<p>适配器模式，代理模式，享元模式。。。</p>
</blockquote>
<h2 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3 行为型模式"></a>3 行为型模式</h2><p>该模式用于<code>描述类或对象之间怎样通信、协作共同完成任务，以及怎样分配职责</code>。</p>
<blockquote>
<p>访问者模式，责任链模式。。。</p>
</blockquote>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>保证某个类只有一个实例对象，主要防止一个全局使用的类频繁地创建与销毁它的实例。</p>
<h2 id="1-懒汉式-（线程不安全版）"><a href="#1-懒汉式-（线程不安全版）" class="headerlink" title="1 懒汉式 （线程不安全版）"></a>1 懒汉式 （线程不安全版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-懒汉式-（线程安全版）"><a href="#2-懒汉式-（线程安全版）" class="headerlink" title="2 懒汉式 （线程安全版）"></a>2 懒汉式 （线程安全版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3 饿汉式"></a>3 饿汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  <span class="comment">//类加载过程保证了线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-双重检查"><a href="#4-双重检查" class="headerlink" title="4 双重检查"></a>4 双重检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;   <span class="comment">//volatile防止指令重排，不加可能导致没生成实例的时候就返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">//第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">//第二次检查</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5 静态内部类"></a>5 静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  <span class="comment">//内部类是延时加载的，在第一次用到它的时候才加载到内存中，实现了lazy loading</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-枚举类"><a href="#6-枚举类" class="headerlink" title="6 枚举类"></a>6 枚举类</h2><p>枚举类在第一次使用到的时候才被加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两种懒汉模式不建议使用：普通懒汉线程不安全，加锁懒汉影响性能；</p>
<p>饿汉：唯一缺点就是即使不使用实例，也会在类加载时创建，不能lazy loading；一般用这个就行了</p>
<p>双重检查：既能lazy loading，又能减少锁的影响；但是实现起来比较复杂</p>
<p>静态内部类：比较完美</p>
<p>枚举类：完美。还能防止反序列化和反射破坏单例。</p>
</blockquote>
<h2 id="单例模式的破坏"><a href="#单例模式的破坏" class="headerlink" title="单例模式的破坏"></a>单例模式的破坏</h2><ol>
<li>反射</li>
<li>序列化与反序列化</li>
</ol>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h2><p>有一个具体的工厂类，生产所有的具体产品类，这些具体产品类通常有一个共同的父类；根据使用者传递的参数不同，创建不同的具体产品实例。</p>
<blockquote>
<p>优点：实现了产品对象创建和使用的解耦；</p>
</blockquote>
<blockquote>
<p>缺点：当使用者需求变了，比如要新增一个产品，就要去工厂类改代码，加else if，不符合开闭原则。不方便扩展，因此简单工厂模式也不在23种设计模式的范围内。</p>
</blockquote>
<h2 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2 工厂方法模式"></a>2 工厂方法模式</h2><p>定义了一个抽象工厂类，能够生产一种抽象产品类；每个具体工厂类与每个具体的产品类一一对应，也就是一个具体工厂类只能生产一种具体产品类；</p>
<blockquote>
<p>好处：便于扩展，一个具体产品类与一个具体工厂类对应，新增产品时不会影响其他产品的代码；</p>
</blockquote>
<blockquote>
<p>缺点：一个具体产品类要对应一个具体的工厂，系统中的类的个数成倍增加，一定程度上增大了系统复杂度。更适用于简单的系统。</p>
</blockquote>
<h2 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3 抽象工厂模式"></a>3 抽象工厂模式</h2><p>定义了一个抽象工厂类，能够生产多种抽象产品类；每个具体工厂类与每种抽象产品类对应，也就是每个具体工厂类生产的是抽象产品，没有细化到具体产品；</p>
<blockquote>
<p> 好处：避免了工厂方法模式在产品较多是要创建许多工厂类的复杂性。</p>
</blockquote>
<blockquote>
<p>缺点：对于新增一个工厂类是方便的，但是新增一个产品等级的时候，需要更改每个工厂的代码。</p>
</blockquote>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式适合创建对象实例时传入参数较多（超过4个），且有些参数是可选的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Computer</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu=builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.ram=builder.ram;</span><br><span class="line">        <span class="built_in">this</span>.usbCount=builder.usbCount;</span><br><span class="line">        <span class="built_in">this</span>.keyboard=builder.keyboard;</span><br><span class="line">        <span class="built_in">this</span>.display=builder.display;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">        <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(String cup,String ram)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu=cup;</span><br><span class="line">            <span class="built_in">this</span>.ram=ram;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setUsbCount</span><span class="params">(<span class="type">int</span> usbCount)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.usbCount = usbCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setKeyboard</span><span class="params">(String keyboard)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.keyboard = keyboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setDisplay</span><span class="params">(String display)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//省略getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Computer computer=<span class="keyword">new</span> <span class="title class_">Computer</span>.Builder(<span class="string">&quot;因特尔&quot;</span>,<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">                .setDisplay(<span class="string">&quot;三星24寸&quot;</span>)</span><br><span class="line">                .setKeyboard(<span class="string">&quot;罗技&quot;</span>)</span><br><span class="line">                .setUsbCount(<span class="number">2</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>

<p>emos项目的R对象应用了这个模式？</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>让两个不兼容的接口，能够一起工作</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>通过代理类的接口，使用被代理类的功能。</p>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>减少对象的创建，如一些池化技术，字符串常量池，线程池，数据库连接池等；还有Integer对于-128~127的对象的缓存。</p>
<p>优点：</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>定义一系列的算法，把他们封装成一个策略类Strategy，使他们能够相互替换，提供给操作策略的上下文类Context进行选择。</p>
<blockquote>
<p> 优点：避免使用大量的条件判断，代码更容易维护</p>
</blockquote>
<blockquote>
<p>缺点：使用的时候要知道所有的策略类，并自行选择</p>
</blockquote>
<h1 id="设计模式的应用"><a href="#设计模式的应用" class="headerlink" title="设计模式的应用"></a>设计模式的应用</h1><p>单例模式</p>
<blockquote>
<p>1.网站计数器：不用每次都刷新到数据库，可以用一个单例对象缓存起来</p>
<p>2.应用程序的日志应用</p>
<p>3.Spring Bean默认都是单例的</p>
</blockquote>
<p>简单工厂模式</p>
<blockquote>
<p>Java的Calender类，通过传入不同参数返回想要的对象</p>
</blockquote>
<p>工厂方法模式</p>
<blockquote>
<p>Collection接口的Iterator的实现，Collection接口的不同实现类得到Iterator对象有自己的方式。</p>
</blockquote>
<p>抽象工厂模式</p>
<blockquote>
<p>Spring框架中的BeanFactory</p>
</blockquote>
<p>代理模式</p>
<blockquote>
<p>Spring AOP</p>
</blockquote>
<p>适配器模式</p>
<blockquote>
<p>Spring MVC适配Controller</p>
</blockquote>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/12/28/5%E5%85%AB%E8%82%A1_MySQL/</url>
    <content><![CDATA[<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p>1.连接器</p>
<p>管理客户端连接，验证登陆权限</p>
<p>2.缓存查询</p>
<p>对用户的查询内容进行缓存，缓存命中则不必走存储引擎。但是再MySQL8.0之后移除了这一功能，因为：</p>
<span id="more"></span>

<ul>
<li>命中率不高，要求SQL语句要完全相同;</li>
<li>表结构有任何变化，则缓存全部失效。</li>
<li>因此额外开销较大，弊大于利</li>
</ul>
<p>3.分析器</p>
<ul>
<li>分析SQL语法，解析SQL语义，知道这个SQL要干嘛</li>
</ul>
<p>4.优化器</p>
<ul>
<li>选择索引，表连接顺序，生成执行计划</li>
</ul>
<p>5.执行器</p>
<ul>
<li>调用存储引擎接口，返回结果</li>
</ul>
<p>6.存储引擎</p>
<ul>
<li>插件式存储引擎，负责数据的读写。</li>
</ul>
<h2 id="一个SQL语句，有几次权限验证？"><a href="#一个SQL语句，有几次权限验证？" class="headerlink" title="一个SQL语句，有几次权限验证？"></a>一个SQL语句，有几次权限验证？</h2><p>3次。</p>
<p>第一次：连接器阶段，验证用户对于数据库的权限；</p>
<p>第二次：分析器解析完SQL语义的时候，有一个precheck, 判断对表有没有这个操作权限；</p>
<p>第三次：执行器阶段，还会有对表的权限的判断。因为执行时可能会涉及到其他表，比如设置了触发器操作。</p>
<h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p>InnoDB和MyISAM的区别</p>
<p>5.5.5版本之后，InnoDB取代MyISAM成为MySQL的默认存储引擎。</p>
<ol>
<li>事务</li>
<li>崩溃恢复</li>
<li>行锁</li>
<li>MVCC</li>
<li>数据文件和索引文件的存储结构</li>
</ol>
<p>​					InnoDB的数据文件存在主键索引树的叶子节点，而MyISAM的数据文件和索引是分开的。</p>
<ol start="6">
<li>外键</li>
</ol>
<p>​					InnoDB是支持外键的，但是外键在阿里巴巴java开发手册里规定，项目生产里，外键禁止使用，要在业务代码里进行约束，外键会对性能带来损耗。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<h2 id="事务的四个性质ACID"><a href="#事务的四个性质ACID" class="headerlink" title="事务的四个性质ACID"></a>事务的四个性质ACID</h2><p>Atomic 原子性</p>
<p>Consistent 一致性</p>
<p>Isolation 隔离性</p>
<p>Durable 持久性</p>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>​		事务隔离的4个级别？</p>
<ol>
<li>读未提交 <strong>READ-UNCOMMITTED</strong> RU ：允许读到未提交的数据</li>
<li>读已提交 <strong>READ-COMMITTED</strong> RC ：事务能读到其他事务已经提交的事务</li>
<li>可重复读 **REPEATABLE-READ **RR ：一个事务内多次读取数据，都和事务的一致性视图一致。</li>
<li>串行化 <strong>SERIALIZABLE</strong> ：事务按照顺序执行，不支持并发事务</li>
</ol>
<p>默认的事务隔离级别是 ：可重复读  REPEATABLE-READ</p>
<h2 id="MySQL事务隔离级别都是基于锁实现的吗？"><a href="#MySQL事务隔离级别都是基于锁实现的吗？" class="headerlink" title="MySQL事务隔离级别都是基于锁实现的吗？"></a>MySQL事务隔离级别都是基于锁实现的吗？</h2><p>串行化隔离级别是通过锁实现的，而可重复读和读已提交级别下，MVCC和锁都有用到，如果是快照读，用的是MVCC，但是两者生成一致性视图的时刻是不同的，如果 是当前读，比如写操作(update insert delete)，或者加锁读（For update &#x2F; lock in share mode）那么是依赖读写锁的。</p>
<h2 id="并发事务带来的问题？"><a href="#并发事务带来的问题？" class="headerlink" title="并发事务带来的问题？"></a>并发事务带来的问题？</h2><ol>
<li><p>脏读：指事务读到了其他事务尚未读到的数据，RU会有脏读现象</p>
</li>
<li><p>不可重复读：不可重复度是指事务中前后两次对同一数据读到的值可能不一致，RU,RC都会有这个现象，可重复读隔离级别解决了这个事情</p>
</li>
<li><p>幻读：指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
</li>
</ol>
<h3 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h3><p>   首先普通的查询是快照读，由于MVCC一致性视图的存在，是不会出现幻读的；</p>
<p>   但是如果是当前读的话，它会加行锁，所以其他事务的update和delete是会被阻塞的，但是Insert是可以插入新纪录的，新纪录是没有行锁的嘛，所以会产生幻读。</p>
<p>   那么为了解决可重复读隔离级别下的幻读问题，MySQL引入了间隙锁，间隙锁能锁住两行记录间的间隙，防止其他事务插入，间隙锁+行锁合成为next-key lock，来解决幻读的问题。</p>
<h3 id="next-key-lock锁的范围"><a href="#next-key-lock锁的范围" class="headerlink" title="next-key lock锁的范围"></a>next-key lock锁的范围</h3><p>范围： 左开右闭的区间，并且只有查询过程中真正访问到的对象才会加锁。</p>
<p>优化：1.如果是唯一索引上的等值查找，那么加锁时next-key lock会退化为行锁；</p>
<p>​			2.如果是非唯一索引上的等值查找，那么向右遍历访问到索引上第一个不符合条件的值时，会退化为间隙锁。</p>
<h2 id="如何对并发事务进行控制？"><a href="#如何对并发事务进行控制？" class="headerlink" title="如何对并发事务进行控制？"></a>如何对并发事务进行控制？</h2><ol>
<li>通过读写锁</li>
<li>MVCC</li>
</ol>
<h2 id="开启事务的指令"><a href="#开启事务的指令" class="headerlink" title="开启事务的指令"></a>开启事务的指令</h2><p>1.显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</p>
<p>2.<set autocommit=1>参数，每次执行语句会自动开启事务和提交事务。</p>
<h2 id="长事务有什么后果？"><a href="#长事务有什么后果？" class="headerlink" title="长事务有什么后果？"></a>长事务有什么后果？</h2><ol>
<li><p>长时间占用锁资源，会影响性能；</p>
</li>
<li><p>会导致主从延迟</p>
</li>
<li><p>还会导致大量的undo log占用存储空间，因为undo log清理的判断依据是，看如果没有比该事务的更早的一致性视图了，才会被清理，所以说长事务还会影响它后面事务的undo log的清理。</p>
</li>
<li><p>长事务还会影响修改表结构，长事务给表加MDL读锁，之后要有修改表结构的操作，会请求MDL写锁，而MDL队列中写锁优先级高于读锁，所以修改表结构的事务后边的CRUD操作也会被阻塞。</p>
</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>Flush tables with read lock (FTWRL)，使整个库都处于一个只读的状态。</p>
<p>使用场景：做全库逻辑备份。逻辑备份时要保持整个过程数据要保持一致性；当然这只适用于不支持事务的存储引擎，对于InnoDB存储引擎来说，可以通过MVCC拿到一致性视图来进行全库备份，而不需要使用全局锁，造成全库只读。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ol>
<li>表锁：表锁是针对表中数据的，读操作加读锁，写操作加写锁；需要显示命令&lt;lock tables … read&#x2F;write&gt;;在没有出现行锁的时候，表锁是控制并发的方式。</li>
<li>meta data lock (MDL): 元数据锁是针对修改表结构的，在修改表结构的时候，会加MDL写锁，CRUD操作的时候加的是MDL读锁，读锁共享；MDL锁是隐式自动加的。</li>
</ol>
<h2 id="如何安全的给小表加字段（或者说修改表结构）？"><a href="#如何安全的给小表加字段（或者说修改表结构）？" class="headerlink" title="如何安全的给小表加字段（或者说修改表结构）？"></a>如何安全的给小表加字段（或者说修改表结构）？</h2><p>​		由于meta data lock (MDL)的存在，如果在修改表结构之前，有一个长事务存在，会占据MDL写锁，此时修改表结构的事务申请MDL写锁会被阻塞，并且由于申请MDL锁的队列是写锁优先的，所以再后面的CRUD操作也会被阻塞。</p>
<p>那么如何安全的修改表结构呢？</p>
<ol>
<li><p>首先要先清理掉长事务，会让后面的修改表结构操作长时间拿不到MDL写锁；</p>
</li>
<li><p>其次是可以给修改表结构的指令加上一个超时时间，保证不会阻塞后续语句太久。</p>
</li>
</ol>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>InnoDB引擎才支持行锁。</p>
<p>普通读是加读锁，是共享锁(S 锁)；增删改操作加的是行锁，是排他锁(X 锁)。</p>
<h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p>事务中的锁是在需要的时候才上锁的，但是要等到事务提交或者回滚了之后才会释放。</p>
<p>所以说事务中容易造成锁冲突的语句尽量放在事务最后，这样可以减少事务时间的锁等待，增加并发度。</p>
<blockquote>
<p>为什么要两阶段锁呢？</p>
<p>如果写操作完事之后没等事务提交就立马释放，那么其他事务如果快照读还好，有一致性视图，但是如果执行当前读的操作时，就会<strong>脏读</strong>了。</p>
</blockquote>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>间隙锁是为了解决幻读的，只有在可重复读的隔离级级别下才有。因为如果只有行锁，那么插入新纪录的时候不会被上锁，在一个事务中，对于同一个范围内的两次查询，后一次的查询可能会出现新的结果，也就是幻读现象。</p>
<p>Next-key lock 临键锁</p>
<p>为了解决幻读现象，就有了next-key lock，行锁+间隙锁结合就叫做next-key lock  </p>
<p>范围： 左开右闭的区间，并且只有查询过程中真正访问到的对象才会加锁。</p>
<p>优化：1.如果是唯一索引上的等值查找，那么加锁时next-key lock会退化为行锁；</p>
<p>​			2.如果是非唯一索引上的等值查找，那么向右遍历访问到索引上第一个不符合条件的值时，会退化为间隙锁。</p>
<h1 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h1><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB；</p>
<p>redo log是循环写的，有两个指针 write pos和check point，分别指向当前写的位置和要擦除的位置。只要redo log被记录了，那么mysql崩溃后，就可根据check point回放，来恢复数据</p>
<img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png?wh=1142*639" alt="img" style="zoom: 67%;" />

<h3 id="redo-log-刷盘时机"><a href="#redo-log-刷盘时机" class="headerlink" title="redo log 刷盘时机"></a>redo log 刷盘时机</h3><p>事务执行过程中，redo log只写到redo log buffer中，但是要在事务提交，执行commit指令时，才</p>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次<strong>事务提交时</strong>，redo log只停留在redo log buffer</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次<strong>事务提交时</strong>都将持久化到磁盘（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次<strong>事务提交时</strong>都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<blockquote>
<p>如果设置为1，只要事务提交，redo log一定落盘成功；如果事务执行期间MySQL挂了或者宕机，那么事务没提交，redo log不记录也正常。</p>
<p>如果设置为0，如果MySQL挂了或者宕机，则会损失1秒中内的数据</p>
<p>如果设置为2，每次事务都会write文件系统的page cache中，那么MySQL挂了不会有数据损失，但是如果宕机了，就会损失1秒内数据。</p>
</blockquote>
<h3 id="没提交的redo-log为什么会从redo-log-buffer-刷新到磁盘？"><a href="#没提交的redo-log为什么会从redo-log-buffer-刷新到磁盘？" class="headerlink" title="没提交的redo log为什么会从redo log buffer 刷新到磁盘？"></a>没提交的redo log为什么会从redo log buffer 刷新到磁盘？</h3><ol>
<li>后台线程每隔一秒的轮询操作，会将redo log buffer同步到磁盘</li>
<li>redo log buffer的内存空间达到总空间的一半时，会将redo log buffer中的内容write到page cache中</li>
<li>并发事务时，多个事务共享一个redo log buffer，如果redo log刷盘时机的参数选为1，那么有一个事务提交时，把整个redo log buffer全部提交，能够实现组提交，减少磁盘IO。【binlog也有组提交机制】</li>
</ol>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。redo log是循环写</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。binlog是追加写。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<h3 id="binlog格式"><a href="#binlog格式" class="headerlink" title="binlog格式"></a>binlog格式</h3><ul>
<li><strong>statement</strong></li>
</ul>
<p>statement格式的Binlog记录的是每个事务的SQL语句，缺点是从库用来同步的时候可能造成主从不一致，如：一个写操作，加了limit，但是可能走了不同的索引，导致主从不一致</p>
<ul>
<li><strong>row</strong></li>
</ul>
<p>row格式binlog的记录对应到每一行，因此不会出现主从数据不一致的情况，但是这种格式的Binlog文件占用空间会比较大。</p>
<ul>
<li><strong>mixed</strong></li>
</ul>
<p>综合以上两种格式，先判断一个SQL语句是否会造成主从不一致，不会的话用statement格式，否则用row格式</p>
<h3 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h3><p>在事务执行过程中，binlog写入内存中的 binlog cache，事务提交的时候才会刷新到磁盘</p>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<p>sync_binlog&#x3D;0 的时候，表示每次提交事务都只 write到page cache，不 fsync到磁盘；</p>
<p>sync_binlog&#x3D;1 的时候，表示每次提交事务都会执行 fsync到磁盘；</p>
<p>sync_binlog&#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p>
<img src="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png?wh=1142*748" alt="img" style="zoom: 50%;" />

<h3 id="为什么Binlog不能实现崩溃恢复？"><a href="#为什么Binlog不能实现崩溃恢复？" class="headerlink" title="为什么Binlog不能实现崩溃恢复？"></a>为什么Binlog不能实现崩溃恢复？</h3><p>我认为主要是因为binlog没有check point指针，binlog和redo log都是WAL机制（预先写日志），redo log在回放数据的时候，根据check point指针，来恢复数据，check point能保证它之前的数据是全部已经落盘的数据;而Binlog没有这样的机制，binlog只能判断事务是否执行完成了，但是由于WAL机制，事务完成了，数据可能还没有刷盘，因此也就无法判断哪些需要恢复。</p>
<h2 id="redo-log和binlog的两阶段提交？"><a href="#redo-log和binlog的两阶段提交？" class="headerlink" title="redo log和binlog的两阶段提交？"></a>redo log和binlog的两阶段提交？</h2><p>目的：保证两份日志文件的一致性。因为binlog会用作创建备库或者恢复临时库（库被误删了），操作是拿到最近一次的整库备份，加上对应时间节点的Binlog进行恢复。如果redo log和binlog不一致，那么就会导致备库与原库不一致。</p>
<img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png?wh=1142*1522" alt="img" style="zoom: 33%;" />

<p>一个更新语句的流程：【上图从写redolog开始都是执行事务提交指令COMMIT后的操作】</p>
<ol>
<li>先看数据是否在内存buffer pool中，不在的话先将数据从磁盘读到内存中；</li>
<li>修改内存中的数据</li>
<li>写redo log，写完之后标记redo log为prepare状态</li>
<li>写binlog</li>
<li>提交事务时（commit指令），将redo log标记为commit状态</li>
</ol>
<blockquote>
<p>如果不采用两阶段提交，那么如果在写两份日志之间发生崩溃，会导致两份日志数据不一致</p>
</blockquote>
<p>为什么binlog不能支持崩溃恢复</p>
<h2 id="mysql崩溃后，如何恢复数据？"><a href="#mysql崩溃后，如何恢复数据？" class="headerlink" title="mysql崩溃后，如何恢复数据？"></a>mysql崩溃后，如何恢复数据？</h2><p>崩溃恢复的时候，会按照顺序从check point开始扫描redo log</p>
<p>如果这条事务的redo log标记为commit状态，则认为该事务有效，进行提交。</p>
<p>如果redo log是prepare状态，这是需要判断binlog是否完整，如果完整就提交事务，不完整就回滚事务。</p>
<blockquote>
<p>如何判断binlog是否完整？</p>
<p>答：一个事务的binlog有格式的，如果是statement格式，完整的Binlog最后会有commit标志，如果是row格式，最后会有一个XID event。</p>
</blockquote>
<blockquote>
<p>一个事务的Binlog 和redo log是如何关联在一起的？</p>
<p>答: 二者有一个公共字段 XID</p>
</blockquote>
<h2 id="MySQL如何保证数据不丢失？"><a href="#MySQL如何保证数据不丢失？" class="headerlink" title="MySQL如何保证数据不丢失？"></a>MySQL如何保证数据不丢失？</h2><blockquote>
<p>mysql通过write-ahead logging WAL 预先写日志机制，内从中数据修改不用马上去刷新磁盘，用redo log和binlog保证数据不丢失，提高mysql的并行能力。</p>
<p>WAL机制主要得益于两个方面：</p>
<ol>
<li>binlog和redo log顺序写，比数据写磁盘时的随机写要快得多；</li>
<li>组提交机制，可以减少了IO次数，提高了IO性能。</li>
</ol>
</blockquote>
<h2 id="MySQL如何保证原子性？"><a href="#MySQL如何保证原子性？" class="headerlink" title="MySQL如何保证原子性？"></a>MySQL如何保证原子性？</h2><p>通过回滚日志，mysql在开启事务之后，每一个sql语句的逆逻辑都会记录在回滚日志中，当事务没执行完，中途出现异常，或者主动通过rollback指令，就会根据回滚日志将数据恢复到事务开启之前的状态。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>回滚日志记录的是我们事务执行的倒序逻辑，1. 用来事务的回滚； 2. MVCC的实现。</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h2 id="一致性视图"><a href="#一致性视图" class="headerlink" title="一致性视图"></a>一致性视图</h2><p>一致性视图相当于给整库拍了一个快照，保存当前的状态，在RC下每执行一个语句会创建一个一致性视图，RR隔离级别下，在事务启动时开启一致性视图，整个事务使用同一个一致性视图。</p>
<p>读提交RC和可重复读RR的一致性视图的区别？</p>
<p>RC隔离级别下的每执行一个语句就会创建一个一致性视图，而RR隔离级别下，是在开启事务的时候创建的，直到事务提交之前一直使用这一个一致性视图。</p>
<h2 id="如何实现可重复读"><a href="#如何实现可重复读" class="headerlink" title="如何实现可重复读"></a>如何实现可重复读</h2><ol>
<li><p>InnoDB存储引擎的为每行数据提供了隐藏字段，其中的事务Id字段记录了更新该行数据的事务Id，用于表示这行数据的版本；</p>
</li>
<li><p>每个事务在开启一致性视图时会创建一个视图数组，用于记录启动事务瞬间正在活跃的所有事务的id；</p>
</li>
<li><p>事务在查询数据时，通过undo log从数据当前值开始向前查找，比对数据的版本号，也就是更新这条记录的事务Id，</p>
<p>a. 如果id比视图数组的低水位小，表示是在开启一致性视图之前创建的，那么这条事务可见；</p>
<p>b. 如果Id比视图数组的高水位大，表示是后创建的视图修改的数据，那么这条事务不可见，继续根据undo log向前查找;</p>
<p>c. 如果id落在视图数组的高水位和低水位之间，如果视图数组中存在该事务Id，那么就是未提交的事务修改的，不可见，如果不存在，就是已提交事务的修改的，是可见的；</p>
</li>
<li><p>就这样根据undo log回滚视图不断查找，直到找到第一个可见数据。</p>
</li>
</ol>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h2><ol>
<li><p>哈希索引</p>
<p> 时间复杂度接近O(1)，结构简单，缺点是只适合等值查找，不支持范围查找，范围查找要走全表扫描。</p>
</li>
<li><p>有序数组<br> 可以二分查找，时间复杂度log(n)，但是插入新数据时，后边的都需要向后移动，成本较高。</p>
</li>
<li><p>二叉搜索树<br> 查找的时间复杂度为log(n)，但是二叉树每层的节点数太少了，树高会很高，每次查找读磁盘次数都会很多，又会减少查询速度 。</p>
</li>
<li><p>N叉树</p>
<p> N叉树的出现就是来解决访问页面过多的问题，以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。</p>
</li>
</ol>
<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><p>采用B+树，是一种平衡 多叉 搜索 树<br>非叶子节点只存放key，而叶子节点存放key和数据，叶子节点通过双向指针形成链表。</p>
<p>B树与B+树有哪些区别？<br>    B树所有节点都能存放key和数据，每个节点之间是独立的，查找时可能走不到叶子节点就结束了;<br>    而B+树的数据只存在在叶子节点，并且通过链表连接，每次查找都要走到叶子节点;</p>
<p>B+树的优点：</p>
<ol>
<li>由于B树每个节点都存储key和数据，导致每个页面内存储的索引更少，整个索引树的树高会更高，查找时需要更多次读磁盘；</li>
<li>范围查询时，B+树查找到两个端点就可以了，然后通过链表的指针进行遍历即可；而B树要遍历更多节点；</li>
</ol>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>聚簇索引：索引结构和数据存放在一起的索引，InnoDB的主键索引就是聚簇索引</p>
<p>非聚簇索引：索引结构和数据是分开存放的，InnoDB的二级索引就是非聚簇索引，叶子节点存储的是主键值。而MyISAM都是非聚簇索引。</p>
<h2 id="单列索引和联合索引"><a href="#单列索引和联合索引" class="headerlink" title="单列索引和联合索引"></a>单列索引和联合索引</h2><p>单列索引：单个字段做索引；  联合索引：多个字段做索引</p>
<h2 id="主键索引与二级索引"><a href="#主键索引与二级索引" class="headerlink" title="主键索引与二级索引"></a>主键索引与二级索引</h2><p>主键索引：一张表只能有一个主键索引，索引字段要满足不能重复，不为null；主键索引叶子节点存储的是数据。</p>
<p>如果没有显示指定主键字段，则InnoDB自动检查看有没有一个字段能满足主键索引的条件，没有的话会创建一个不可见的6Byte的自增主键。</p>
<p>二级索引：一张表可以有多个二级索引，二级索引叶子节点存储的是主键值。通过二级索引查找到主键值之后，需要根据主键值回表，到主键索引查找到对应数据。</p>
<h2 id="索引的三大特性"><a href="#索引的三大特性" class="headerlink" title="索引的三大特性"></a>索引的三大特性</h2><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>当通过非聚簇索引树查询时，在非聚簇索引树上就有想查询的数据时，就没必要回表了，比如：</p>
<ol>
<li>通过某个普通索引，想查询主键ID字段；</li>
<li>或者联合索引，联合索引有最左匹配原则，当想通过索引中左边的字段查询右侧字段的数据时，也不需要回表。</li>
</ol>
<h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><p>在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配。匹配完成或者遇到范围查询（如&gt; &lt; between）无法继续匹配时，匹配结束。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>如果是联合索引，遇到无法继续匹配的情况了，比如范围查找，那么其他查询条件如果在索引中能找到，会先做判断，不满足的就不用回表了，减少回表次数。</p>
<h2 id="怎么给字符串字段加索引？"><a href="#怎么给字符串字段加索引？" class="headerlink" title="怎么给字符串字段加索引？"></a>怎么给字符串字段加索引？</h2><p>场景1：邮箱登录；</p>
<p>给邮箱字段加索引。 <a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#x67;&#x73;&#x73;&#x78;&#x79;&#x7a;&#x40;&#120;&#120;&#120;&#46;&#99;&#x6f;&#x6d;">&#x7a;&#104;&#x61;&#x6e;&#x67;&#x73;&#x73;&#x78;&#x79;&#x7a;&#x40;&#120;&#120;&#120;&#46;&#99;&#x6f;&#x6d;</a>；问题：字段太长，占据空间太大</p>
<p><strong>前缀索引</strong>，取前几个字符做索引，最左匹配原则。使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</p>
<p>前缀索引的问题是会增加一些扫描行数，牺牲了一些匹配精确度。并且前缀索引依赖于区分度。</p>
<p>场景2：身份证号</p>
<p>身份证号的前缀区分度不高；因此可采用</p>
<p><strong>倒序存储</strong> ， 之后再取前6位做前缀索引，每次需要调用reverse函数</p>
<p><strong>添加hash字段</strong>：为表添加一个hash字段，作为索引。每次插入通过哈希函数计算出身份证号的hash值；hash索引的匹配精度高，会增加一个额外字段空间，一般四个字节就够了；可能会哈希冲突，还要和id联合判断是否完全相同，但是冲突几率比较低；</p>
<p>总体来说hash字段索引查询效率要更高一些。地址空间hash字段可能更多，但是如果前缀区分度低，要更长长度，也会增加额外地址空间。</p>
<h2 id="什么时候不走索引（导致索引失效的原因）？"><a href="#什么时候不走索引（导致索引失效的原因）？" class="headerlink" title="什么时候不走索引（导致索引失效的原因）？"></a>什么时候不走索引（导致索引失效的原因）？</h2><ol>
<li>对索引字段进行了函数计算</li>
</ol>
<blockquote>
<p> select * from t where year(date) &#x3D; 2020 索引上有函数运算</p>
<p>select * from t where id+1&#x3D;1000  写成where id &#x3D; 1000 - 1 就行了</p>
</blockquote>
<ol start="2">
<li>隐式类型转换</li>
</ol>
<blockquote>
<p>首先明确，mysql 中 select “10” &gt; 9 ，字符串和数字做比较的话，是将字符串转换成数字。</p>
<p>select * from tradelog where tradeid&#x3D;110717 相当于  select * from tradelog where  CAST(tradid AS signed int) &#x3D; 110717</p>
<p>所以相当于对索引字段进行了隐式的函数计算，会导致不走索引</p>
</blockquote>
<ol start="3">
<li>隐式字符编码转换</li>
</ol>
<blockquote>
<p>如果两个关联表的字符集不同，也可能不走索引；比如表1字符集是utf8mb3，表2字符集是utf8mb4，由于uft8mb4是超集，范围更大，会将utf8mb3字符的字段转换为utf8mb4的字符进行关联比较。</p>
</blockquote>
<h1 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h1><h2 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h2><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h2 id="分库库表"><a href="#分库库表" class="headerlink" title="分库库表"></a>分库库表</h2><h2 id="高可用性和高可靠性"><a href="#高可用性和高可靠性" class="headerlink" title="高可用性和高可靠性"></a>高可用性和高可靠性</h2><h1 id="零散问题"><a href="#零散问题" class="headerlink" title="零散问题"></a>零散问题</h1><h2 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h2><p>对于二级索引树的数据页通常是无序的，每次读取要进行随机磁盘IO，那么为了避免读磁盘，就将对二级索引树的写操作缓存在change buffer中，等下次要访问这个数据页的时候，再将change buffer中的操作执行。</p>
<blockquote>
<p>对于唯一索引，由于每次要进行唯一性检查，所以每次都要读进内存，所以不走change buffer</p>
</blockquote>
<h2 id="刷脏页"><a href="#刷脏页" class="headerlink" title="刷脏页"></a>刷脏页</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>mysql为每个线程分配一个用于排序的内存区域sort buffer;</p>
<blockquote>
<p>全字段排序：将要查询的内容全部放进sort buffer，更具order by字段进行快排，如果超过sort buffer size，则需要借助临时磁盘文件，进行归并排序；</p>
<p>row id 排序：如果查询内容的每行字节数太大，受sort buffer size限制，如果借用磁盘文件可能数量太多，则采用另一种排序方式,row id排序；   </p>
<p>​				将排序字段和对应的主键放入sort buffer进行排序，之后再根据主键进行一次回表，解决了内存不足问题，但是多了一次磁盘回表操作，因此全字段排序作为默认方式。但是如果是对内存临时表进行排序，回表也不用到磁盘中查，因此采用row id排序。</p>
</blockquote>
<h2 id="随机显示数据"><a href="#随机显示数据" class="headerlink" title="随机显示数据"></a>随机显示数据</h2><p>join</p>
<p>临时表</p>
<h2 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h2><blockquote>
<p>第一范式：每个列都是不可拆分的</p>
<p>第二范式：每个表只做一件事</p>
<p>第三范式：不存在对非主键列的传递依赖</p>
<p>目的：<strong>减少数据耦合</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器</title>
    <url>/2023/01/14/8%E5%85%AB%E8%82%A1_Tomcat&amp;Nginx/</url>
    <content><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="什么是web容器？"><a href="#什么是web容器？" class="headerlink" title="什么是web容器？"></a>什么是web容器？</h2><p>早期的HTTP服务器主要用于返回静态资源，如Apache,Nginx服务器都是静态服务器，像浏览器返回静态html,浏览器负责解析html页面；</p>
<p>servlet技术提供了HTTP服务器动态访问应用程序的能力（根据url执行某个方法），但是servlet不能独立运行，没有main方法，需要借助容器来运行，如tomcat,jetty等servlet容器，由容器管理servlet。</p>
<p>tomcat就是一个常用的servlet容器，为了方便使用，他也同时具备了HTTP服务器的功能，因此叫做web容器。（tomcat就是一个java程序，servlet由这个java程序创建）</p>
<span id="more"></span>

<p>最初的模式，一个项目有多个servlet，每个servlet有一个对应的url，一个servlet有一个service方法；</p>
<blockquote>
<p>即一个web-app就是一堆servlet，然后实现servlet的service方法，给每个servlet绑定一个url，</p>
</blockquote>
<p>SpringMVC模式下，一个项目有一个dispatcherServlet，通过url中的项目名找到dispatcherServlet，然后dispatcherServlet在根据url分发给controller去执行相应方法；servlet实例是由容器程序创建的。</p>
<blockquote>
<p>即一个SpringMVC模式web-app就是一个dispatcherServlet，和一堆Controller，Controller中有很多方法，每个Controller中的方法有一个单独的url，dispatcherServlet根据url，分发请求，执行对应的方法。dispatcherServlet是由容器项目创建的。</p>
</blockquote>
<p>也就是说每个项目web-app由一个dispatcherServlet来分发请求，这个servlet是一个实例对象，由tomcat（容器）创建，tomcat是一个java程序，由main入口，运行在它的JVM里。</p>
<blockquote>
<p>由于SpringBoot内嵌了Tomcat，所以SpringBoot项目可以像正常程序那样启动，有main方法。</p>
</blockquote>
<p>简单来说，tomcat是一个http服务器+servlet容器：</p>
<blockquote>
<p> http服务器：完成网络通信，处理http请求，并返回http响应。具体来说是处理socket连接（解析应用层协议，tcp&#x2F;udp），负责网络IO的字节流与request, response对象的转化。这时tomcat连接器实现的功能</p>
<p>servlet容器：加载和管理servlet对象。http服务器将请求交给servlet处理，servlet容器将请求分发到具体的servlet，调用service()方法去执行业务代码。</p>
</blockquote>
<blockquote>
<p>一个web容器可以放多个web程序，将程序放在webapps目录下即可；对于一个springmvc项目有一个DispatchServlet，一个web容器中放多个web程序就会有多个servlet。</p>
</blockquote>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Servlet指的是任何实现了Servlet接口的类，由servlet容器创建并管理，用于处理客户端传来的http请求，执行具体的业务代码，再返回响应。最主要的方式是service()方法，具体的业务代码逻辑在service()方法中实现。</p>
<blockquote>
<p>Servlet是一个Java接口，是实现Web技术的核心。我们平时说的Tomcat容器中的servlet是一个实例，由Tomcat容器创建，servlet的核心执行方法是service()，客户端传来的Http请求，会被Tomcat封装成ServletRequest对象，servlet的响应则被封装到ServletResponse对象中，通过这种请求&#x2F;响应模型，来实现客户端与服务端的交互。</p>
</blockquote>
<blockquote>
<p>HttpServlet是一个抽象类，它实现了Servlet接口，对Servlet功能进行了扩展。</p>
</blockquote>
<p>servlet是单例的，在第一次访问的时候被tomcat创建，会出现并发问题，如何解决？</p>
<blockquote>
<ol>
<li>尽量避免使用静态变量和成员变量</li>
<li>如果必须要用，要对静态变量和成员变量线程不安全方法声明锁。</li>
</ol>
</blockquote>
<h2 id="tomcat如何创建servlet的？"><a href="#tomcat如何创建servlet的？" class="headerlink" title="tomcat如何创建servlet的？"></a>tomcat如何创建servlet的？</h2><p>当tomcat容器启动的时候，会读取webapps文件目录下所有web应用的web.xml文件，读取servlet的注册信息。</p>
<p>默认情况当servlet第一次被请求时，通过反射进行实例化，每个servlet是单例的。</p>
<h2 id="SpringMCV中的Servlet"><a href="#SpringMCV中的Servlet" class="headerlink" title="SpringMCV中的Servlet"></a>SpringMCV中的Servlet</h2><p><img src="https://github.com/WayV5/imgs/blob/main/tomcat/p1.png?raw=true" alt="p1.png"></p>
<p>1.客户端的请求先到DispatcherServlet，DispatcherServlet是Servlet接口的一个实现类；</p>
<p>2.通过HandlerMapping，根据uri路径信息寻找Handler(Controller)，找到Handler之后生成适配器HandlerAdapter，DispatcherServlet就能通过适配器执行Handler的方法了；</p>
<p>3.Handler执行完毕，将响应结果返回给DispatcherServlet，web容器再把他封装成response返回给客户端。</p>
<h2 id="Servlet线程池"><a href="#Servlet线程池" class="headerlink" title="Servlet线程池"></a>Servlet线程池</h2><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>用处：1. 做静态服务器 2. 反向代理 3.负载均衡</p>
<p><strong>Nginx</strong>特点是占有内存少， 并发能力强，且Nginx处理静态页面的效率远高于tomcat，分离部署就是通过nginx（或apache等）来处理用户端请求的静态资源，tomcat（或weblogic）处理动态资源，从而达到动静页面访问时由不同的容器来处理。</p>
<h2 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h2><blockquote>
<p>1.做静态web服务器，直接存储原始静态资源；记得使用gzip压缩静态资源，减少网络传输资源。</p>
<p>2.做静态缓存服务器，反向代理原始服务器，缓存原始服务器的静态资源。</p>
</blockquote>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>Nginx能做反向代理服务器。反向代理的“反向”指的是代理的是服务端，客户端传来的请求发送到代理服务器，由代理服务器转发，决定使用哪台原始服务器处理请求。</p>
<p>反向代理向客户端隐藏了原始服务器，nginx配置反向代理，能够实现服务端的负载均衡。</p>
<blockquote>
<p>正向代理：代理的是客户端，一般通过VPN，由VPN代理客户端向服务端发送请求，服务端不知道原始客户端是谁。</p>
</blockquote>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>如果一台服务器，处理不过来客户端发来的请求，一个简单的解决办法就是增加服务器的数量做集群部署，这时需要某种和规则来向服务器集群，均匀的分配请求，这种规则就叫做<strong>负载均衡</strong>策略。</p>
<p>nginx就具备这样一种功能，通过反向代理，实现负载均衡。</p>
<blockquote>
<p>除此之外，nginx还具备<strong>健康检查</strong>（服务器心跳检查）功能，定期向服务器集群的各服务器发送心跳检查请求，来检测是否有服务器处于异常状态。</p>
</blockquote>
<h3 id="Nginx为什么适合做负载均衡？"><a href="#Nginx为什么适合做负载均衡？" class="headerlink" title="Nginx为什么适合做负载均衡？"></a>Nginx为什么适合做负载均衡？</h3><blockquote>
<p>1.nginx属于软件负载均衡，相比于硬件负载均衡，成本更低。一个低配置的服务器就能实现。</p>
<p>2.占用内存低，对高并发友好。Nginx单机支持10万以上的并发连接。</p>
<p>3.自带健康检查（心跳检查）功能</p>
<p>4.支持热部署，可以在不间断服务情况下，升级nginx。</p>
<p>5.支持多种负载均衡策略：轮询，IP哈希，最小连接数。</p>
</blockquote>
<h3 id="Nginx的负载均衡策略"><a href="#Nginx的负载均衡策略" class="headerlink" title="Nginx的负载均衡策略"></a>Nginx的负载均衡策略</h3><ol>
<li><p>轮询（默认方式）</p>
<blockquote>
<p>按照请求的时间顺序向各个服务器分配请求，可以设置权重</p>
</blockquote>
</li>
<li><p>ip哈希</p>
<blockquote>
<p>按照请求的客户端的ip地址进行哈希，来分配请求，可以设置权重;</p>
<p>相同hash的客户端总是会请求到下相同服务器，在一定程度上解决了session不共享的问题。</p>
</blockquote>
</li>
<li><p>最小连接数</p>
<blockquote>
<p>将新的请求分配给当前活跃连接数最少的服务器</p>
</blockquote>
</li>
</ol>
<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>内容分发网络。要给DNS域名解析后台添加CDN解析记录，让用户根据域名解析到原服务器的Ip地址后，不是直接访问原服务器的Ip，而是先访问CDN负载均衡服务器，CDN能够根据请求IP地址来选择分发请求到哪个最近的CDN服务器，CDN服务器有着原服务器的缓存，如果查不到缓存，再一层层查询直到原服务器。</p>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>netty是对NIO网络模型的一种封装，并且对传统NIO模型进行了优化 ，支持多种通信协议（http,websocket）;</p>
<p>netty相比于直接使用jdk自带的NIOapi更加方便，并且性能更好，便于实现多线程reactor模型，很多中间件都用到了netty（zookeeper,rocketMQ,Dubbo）；</p>
<p>目的就是更好的解决提高服务端吞吐量问题，本质上和NIO是相同的；</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Servlet</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/2023/01/06/7%E5%85%AB%E8%82%A1_Spring%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Spring概念"><a href="#Spring概念" class="headerlink" title="Spring概念"></a>Spring概念</h1><p>Spring是一个轻量级Java开发框架，里面包含了许多模块，能够简化Java开发工作</p>
<p>主要模块：</p>
<p>Core Container: spring-core, spring-beans, spring-context, spring-expression</p>
<span id="more"></span>

<p>AOP</p>
<p>Data Access&#x2F;Integration</p>
<p> Spring Web: spring-web, spring-webmvc, spring-websocket</p>
<p>Test</p>
<h2 id="Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间什么关系?"></a>Spring,Spring MVC,Spring Boot 之间什么关系?</h2><p>Spring框架有很多个模块，其中最核心的就是core模块提供的IoC功能，其他模块比如Spring MVC都要依赖于这个模块；</p>
<p>Spring MVC模块主要实现了快速构建Web程序的能力，核心思想就是Model层，View层，Controller层分离，来组织代码。</p>
<p>Spring开发时，许多配置要通过XML文件或者Java语句进行显式的配置，为了简化配置，SpringBoot 框架应运而生。</p>
<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，将原来程序中创建对象的控制权交给Spring框架去操管理。</p>
<p>好处是：我们创建一个对象的时候，可能依赖于很多其他对象，代码就会很繁琐。将对象的依赖关系交给Spring IoC容器去管理，并由IoC容器完成对象的注入。只需提前配置好，用的时候直接调用就可以了，能够大大简化开发。</p>
<h2 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h2><p>Spring Bean就是由IoC容器进行管理的对象。可以通过XML文件，注解，java配置类等方式，告诉IoC容器要管理哪些对象。</p>
<h2 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些?"></a>将一个类声明为 Bean 的注解有哪些?</h2><ul>
<li>@Component  通用注解，下边的注解都会间接引用该注解，如果不知道该类是哪个层，就用这个</li>
<li>@Repository 对应持久层</li>
<li>@Service 业务逻辑层</li>
<li>@Controller 控制层</li>
</ul>
<h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ul>
<li>@Component 注解作用于类，而@Bean注解作用于方法。</li>
<li>@Bean通常和@Component注解一起使用，@Component作用在类上，表示这个类作为配置类使用，相当于一个XML文件，而类中方法的@Bean注解，相当于配置信息，将方法的返回对象加入到IoC容器中。</li>
</ul>
<blockquote>
<p>@Configuration注解注入的是将某类的代理类加入到IoC容器中，通常和@Bean一起使用，来作为配置类使用，代理xml的配置方式。</p>
</blockquote>
<h2 id="注入-Bean-的注解有哪些？"><a href="#注入-Bean-的注解有哪些？" class="headerlink" title="注入 Bean 的注解有哪些？"></a>注入 Bean 的注解有哪些？</h2><ul>
<li>@Autowired 默认通过类型注入</li>
<li>@Resource 默认通过名字注入</li>
</ul>
<h2 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h2><ul>
<li>singleton ：Spring bean默认是单例的，单例模式的应用。</li>
<li>prototype : 每次获取bean都会创建一个新的bean</li>
<li>request ：每次HTTP请求，创建一个新的bean，（请求bean）</li>
<li>session：每次有一个新的session传来HTTP请求，创建一个新的bean，（会话bean）</li>
<li>application&#x2F;global-session：每个 Web 应用在启动时创建一个 Bean（应用 Bean）</li>
<li>websocket <strong>：</strong>每一次 WebSocket 会话产生一个新的 bean</li>
</ul>
<h2 id="单例-Bean-的线程安全问题了解吗？"><a href="#单例-Bean-的线程安全问题了解吗？" class="headerlink" title="单例 Bean 的线程安全问题了解吗？"></a>单例 Bean 的线程安全问题了解吗？</h2><p>大多数bean都是无状态的（没有成员变量），都是用他的方法，比如dao,service，就线程安全的；</p>
<p>如果用到涉及成员变量的bean,可以通过以下方式解决线程安全问题：</p>
<ol>
<li>在bean中尽量避免定义可变的成员变量；</li>
<li>如果必须需要可变的成员变量，就定义一个ThreadLocal成员变量，保存在ThreadLocal中。</li>
</ol>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><blockquote>
<p>实例化 —&gt; 设置属性 —&gt; 自定义初始化方法 —&gt; bean的使用 —&gt; 自定义销毁方法</p>
</blockquote>
<blockquote>
<p>实例化：通过反射，默认调用无参构造函数，实例化对象</p>
<p>设置属性：通过反射，调用set方法设置属性参数</p>
<p>自定义初始化方法init</p>
<p>自定义的销毁方法destory</p>
</blockquote>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP(Aspect Oriented Programming)是一种面向切面的编程思想，将影响多个类的行为，集成到一个模块中去，减少代码的重复度，降低模块间的耦合。</p>
<p>Spring AOP 就是基于动态代理的，有两种动态代理模式JDK动态代理和Cglib动态代理；如果被代理的对象实现了某个接口，则采用JDK动态代理，采用接口方式实现代理；如果被代理的对象没有接口，则采用Cglib动态代理，生成一个被代理类的子类，来作为代理。</p>
<h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。</p>
<h2 id="AspectJ-定义的通知类型有哪些？"><a href="#AspectJ-定义的通知类型有哪些？" class="headerlink" title="AspectJ 定义的通知类型有哪些？"></a>AspectJ 定义的通知类型有哪些？</h2><ul>
<li>Before 前置通知</li>
<li>After 后置通知</li>
<li>AfterReturning 返回通知</li>
<li>AfterThrowing 抛异常通知</li>
<li>Around 环绕通知</li>
</ul>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="SpringMCV工作原理"><a href="#SpringMCV工作原理" class="headerlink" title="SpringMCV工作原理"></a>SpringMCV工作原理</h2><p><img src="https://github.com/WayV5/imgs/blob/main/tomcat/p1.png?raw=true" alt="p1"></p>
<p>1.客户端的请求先到DispatcherServlet，DispatcherServlet是Servlet接口的一个实现类；</p>
<p>2.通过HandlerMapping，根据uri路径信息寻找Handler(Controller)，找到Handler之后生成适配器HandlerAdapter，DispatcherServlet就能通过适配器执行Handler的方法了；</p>
<p>3.Handler执行完毕，将响应结果返回给DispatcherServlet，web容器再把他封装成response返回给客户端。</p>
<h1 id="Spring框架用了哪些设计模式"><a href="#Spring框架用了哪些设计模式" class="headerlink" title="Spring框架用了哪些设计模式"></a>Spring框架用了哪些设计模式</h1><p>工厂设计模式：Spring bean对象是通过BeanFactory创建的(BeanFactory是接口，具体实现类是各种Application Context)</p>
<p>代理模式：AOP的实现</p>
<p>单例模式：Spring bean默认是单例模式</p>
<p>适配器模式：spring MVC中DispatcherServlet通过适配器，适配各种Controller</p>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><p>Spring可以通过显示编程 或 注解方式开启事务</p>
<ol>
<li>通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务</li>
<li>通过@Transactional注解（通过AOP实现）,可作用于类或方法，作用于类时类中所有public方法都开启事务。</li>
</ol>
<h2 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h2><p>默认与数据库的隔离级别一致。一共有四种：RU,RC,RR,Serival</p>
<h2 id="Transactional-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</h2><p>@Transactional注解的rollbackFor如果不配置，默认发生RuntimeException才发生回滚，配置成Exception.class，发生所有异常都会回滚。</p>
<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2023/02/03/9%E5%85%AB%E8%82%A1_SptringBoot/</url>
    <content><![CDATA[<h1 id="为什么要有SpringBoot？"><a href="#为什么要有SpringBoot？" class="headerlink" title="为什么要有SpringBoot？"></a>为什么要有SpringBoot？</h1><p>SpringBoot旨在减少配置文件，方便Spring框架开发。</p>
<span id="more"></span>

<h1 id="简单介绍一下Spring，有什么缺点？"><a href="#简单介绍一下Spring，有什么缺点？" class="headerlink" title="简单介绍一下Spring，有什么缺点？"></a>简单介绍一下Spring，有什么缺点？</h1><p>spring是轻量级开发框架，集成了很多模块，如Ioc,Aop等，能够减少重复代码，提高开发效率。</p>
<p>缺点是:需要大量的XML配置文件，比较繁琐。</p>
<h1 id="Spring-boot-starters是什么？"><a href="#Spring-boot-starters是什么？" class="headerlink" title="Spring-boot-starters是什么？"></a>Spring-boot-starters是什么？</h1><p>Spring-boot-starters是一系列依赖关系的集合，它能够让我们项目的依赖配置更加简单。</p>
<p>在没有Spring-boot-starters之前，开发一个web应用要引入spring-mvc，tomcat,jackson时，要分别配置，还要考虑他们之间的版本支持关系；但是如果使用一个依赖Spring-boot-starter-web就可以将他们集成一体化配置了，里边包含了web开发服务的所有依赖。</p>
<h1 id="Spring支持哪些内嵌web容器"><a href="#Spring支持哪些内嵌web容器" class="headerlink" title="Spring支持哪些内嵌web容器"></a>Spring支持哪些内嵌web容器</h1><p>默认使用tomcat,还可以用jetty【在pom.xml中先移除tomcat，再添加jetty】</p>
<h1 id="介绍一下-SpringBootApplication注解"><a href="#介绍一下-SpringBootApplication注解" class="headerlink" title="介绍一下@SpringBootApplication注解"></a>介绍一下@SpringBootApplication注解</h1><p>@SpringBootApplication是项目启动注解，他可以看作@EnableAutoConfiguration @ComponentScan @Configration注解的集合。</p>
<blockquote>
<p>@EnableAutoConfiguration: 启用springboot的自动配置功能</p>
<p>@ComponentScan：扫描被@Component（@Controller）等注解注释的类，将他们以bean的形式注入到ioc容器。</p>
<p>​				@ComponentScan默认扫描路径为同级包及其子包；</p>
<p>@Configration允许在上下文中注入额外的bean和其他配置类</p>
</blockquote>
<h1 id="开发RESTful-Web服务常用的注解有哪些？"><a href="#开发RESTful-Web服务常用的注解有哪些？" class="headerlink" title="开发RESTful Web服务常用的注解有哪些？"></a>开发RESTful Web服务常用的注解有哪些？</h1><h2 id="Spring-Bean相关"><a href="#Spring-Bean相关" class="headerlink" title="Spring Bean相关"></a>Spring Bean相关</h2><h3 id="标记为ioc容器管理"><a href="#标记为ioc容器管理" class="headerlink" title="标记为ioc容器管理"></a>标记为ioc容器管理</h3><ul>
<li>@Component @Repository @Service @Controller</li>
</ul>
<h3 id="装配bean"><a href="#装配bean" class="headerlink" title="装配bean"></a>装配bean</h3><ul>
<li>@Autowired @Resource</li>
</ul>
<h3 id="HTTP请求类型"><a href="#HTTP请求类型" class="headerlink" title="HTTP请求类型"></a>HTTP请求类型</h3><ul>
<li>@GetMapping @PostMapping @PutMapping @DeleteMapping</li>
</ul>
<h3 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h3><blockquote>
<p>@RequestParam 用于?传参</p>
<p>@PathVariable用于url路径传参</p>
<p>@RequestBody用于读取Request请求的body部分以json格式传递的数据，将json字符串解析成java对象。</p>
</blockquote>
<blockquote>
<p>一个请求方法只可以有一个@RequestBody，但是可以有多个@RequestParam，@PathVariable</p>
</blockquote>
<blockquote>
<p>@RequestParam，@PathVariable通常用于get请求，get请求一般不用于传递json，硬传递的话要在url中添加json字符串，但是Url有长度限制。</p>
<p>@RequestBody多用于post,put,delete请求，传递json</p>
</blockquote>
<h1 id="Springboot常用的两种配置文件"><a href="#Springboot常用的两种配置文件" class="headerlink" title="Springboot常用的两种配置文件"></a>Springboot常用的两种配置文件</h1><p>properties文件和yml文件。yml配置更加简单，看起来更有层次性（冒号后边的空格不要忘记）</p>
<p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息</p>
<h1 id="Springboot后端请求参数验证"><a href="#Springboot后端请求参数验证" class="headerlink" title="Springboot后端请求参数验证"></a>Springboot后端请求参数验证</h1><p>即使前端做了请求参数验证，后端还是要进行参数验证，为了避免用户绕过浏览器通过http工具请求违法数据。</p>
<blockquote>
<p>对于requestbody请求参数，传入表单类通过框架注解进行参数限制，web方法请求参数前加@Valid</p>
</blockquote>
<blockquote>
<p>对于RequestParam和PathVariable请求参数，请求方法加@valid和@Notnull等限制，在controller类上必须加@Validated注解</p>
</blockquote>
<h1 id="SpringBoot全局异常处理"><a href="#SpringBoot全局异常处理" class="headerlink" title="SpringBoot全局异常处理"></a>SpringBoot全局异常处理</h1><p>通过@ControllerAdvice注解 + @ResponseBody注解修饰配置类，@ExceptionHandler设置特定异常的处理方式。</p>
<p>通过AOP实现，@ControllerAdvice注解会为controller类织入抛异常通知，具体的执行要看下边的配置。</p>
<h1 id="SpringBoot定时任务"><a href="#SpringBoot定时任务" class="headerlink" title="SpringBoot定时任务"></a>SpringBoot定时任务</h1><p>通过@Scheduled修饰定时方法，并在启动类@EnableScheduling</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
