<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/10%E5%85%AB%E8%82%A1_IO/</url>
    <content><![CDATA[<h1 id="IO概念"><a href="#IO概念" class="headerlink" title="IO概念"></a>IO概念</h1><p>I&#x2F;O就是输入输出，指的是计算机内存空间与外部设备之间的通信过程。</p>
<p>常见的IO通信：磁盘IO[内存与磁盘],   网络IO[内存与网卡]</p>
<p>操作系统的内存空间分为：内核空间和用户空间。内核空间独立于用户进程，为操作系统内核所属。</p>
<p>涉及到资源有关的操作（如内存管理，文件管理，进程调度等）要在内核空间执行，用户进程无法访问内核空间，因此用户程序要想IO操作时，需要发起IO操作的系统调用，由操作系统内核来执行具体的IO操作。</p>
<h2 id="有哪些常见的-IO-模型"><a href="#有哪些常见的-IO-模型" class="headerlink" title="有哪些常见的 IO 模型?"></a>有哪些常见的 IO 模型?</h2><p>UNIX 系统下， IO 模型一共有 5 种：<strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p>
<blockquote>
<p>同步&#x2F;异步：在操作系统角度看，是看数据在系统内核在准备就绪之后，往用户空间拷贝的时候，用户进行是否要等待。</p>
<p>阻塞&#x2F;非阻塞：看用户进程发起系统调用后，是否需要一直阻塞等待到数据传输完成。</p>
</blockquote>
<p>用户进程进行网络IO需要经过以下步骤：</p>
<ol>
<li>用户进程向操作系统发起IO系统调用；</li>
<li>操作系统内核将网卡数据读取到内核缓冲区；</li>
<li>内核缓冲区的数据拷贝到用户缓冲区。</li>
</ol>
<img src="https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslh5ztLkXZ5fVqN6amgPdVfFibGEyfeWKsQz0PnouU1YTdKpVoUMVVSoIC7a7r3xKsYB2XgAPZgZ2QA/640?wx_fmt=png&wxfrom=13&tp=wxpic" alt="图片" style="zoom:67%;" />

<h1 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h1><blockquote>
<p>当服务端accept到一个客户端请求时，会建立一个socket，生成一个对应的文件描述符fd；<br>一个http请求–&gt; 一个socket连接  –&gt; 操作系统生成一个文件描述符fd，作为访问一个socket相关内存数据的句柄；</p>
</blockquote>
<h2 id="BIO-Blocking-I-x2F-O-同步阻塞I-x2F-O"><a href="#BIO-Blocking-I-x2F-O-同步阻塞I-x2F-O" class="headerlink" title="BIO (Blocking I&#x2F;O) 同步阻塞I&#x2F;O"></a>BIO (Blocking I&#x2F;O) 同步阻塞I&#x2F;O</h2><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom: 67%;" />

<p>用户线程发起IO系统调用（recvfrom）后，会一直阻塞，直到内核将数据拷贝到用户空间才返回。</p>
<p>所以一个服务端线程只能同时处理一个请求，面对大量连接时，只能创建多个线程，开销很大。</p>
<blockquote>
<p>优点：当数据没准备好，用户线程让出CPU，进入休眠；等到数据拷贝好了，再通过中断唤醒用户线程。</p>
</blockquote>
<blockquote>
<p>缺点：对于单个线程，面对多个请求时，前面的阻塞，后面的也会阻塞，效率低，适合并发量低的场景。</p>
</blockquote>
<h2 id="NIO-Non-blocking-x2F-New-I-x2F-O"><a href="#NIO-Non-blocking-x2F-New-I-x2F-O" class="headerlink" title="NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>NIO (Non-blocking&#x2F;New I&#x2F;O)</h2><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。</p>
<p>它是支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。【也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型(<strong>×</strong>错的)。】</p>
<p>那么比较以下二者区别：</p>
<h3 id="同步非阻塞-IO-模型"><a href="#同步非阻塞-IO-模型" class="headerlink" title="同步非阻塞 IO 模型"></a><strong>同步非阻塞 IO 模型</strong></h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom: 67%;" />

<p>在同步非阻塞IO模型中，用户进程发起IO系统调用后，如果内核中数据没准备就绪，会立即返回，不会阻塞；过段时间再次系统调用，看数据是否就绪；第一次系统调用后开始向内核空间读取数据，因此后续的多次系统调用浪费了CPU资源</p>
<p>直到某次系统调用，数据在内核空间就绪了，再进行数据拷贝，此时用户进程是阻塞的。</p>
<p>当服务端accept一个请求后，对应请求的socket对象会在操作系统生成一个文件描述符fd，fd会加入到处理该请求的线程的文件描述符集合fds中去；<br>这个线程没过一段时间，会轮询一遍fds集合，非阻塞地对每个fd进行一次recv系统调用，对于每个fd来说，如果内核空间的数据没就绪，就会返回一个错误，准备好了就会进行数据拷贝（阻塞）</p>
<blockquote>
<p>优点：避免用户线程阻塞，一个线程能同时处理多个请求；</p>
</blockquote>
<blockquote>
<p>缺点：多次轮询的系统调用要消耗大量CPU资源。</p>
</blockquote>
<h3 id="I-x2F-O-多路复用模型"><a href="#I-x2F-O-多路复用模型" class="headerlink" title="I&#x2F;O 多路复用模型"></a><strong>I&#x2F;O 多路复用模型</strong></h3><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:67%;" />

<p>IO多路复用模型，为一个服务端线程配置了一个选择器selector，能够处理多个客户端连接；<br>当服务端accept一个客户端请求，操作系统会为建立连接的socket对象创建一个文件描述符fd，这个文件描述符会注册到用户服务端线程的集合fds当中,也就是将socket注册到线程的selector；<br>服务端线程会一定频率的执行select&#x2F;poll&#x2F;epoll 等系统调用获取 fd 列表，轮询的检查集合中每个fd对应的数据是否准备就绪，其中有一个就绪了，select就会返回，通知线程为对应的fd通道发起数据拷贝的系统调用。</p>
<blockquote>
<p>如果同时有10000个请求过来，BIO就需要10000个线程才能并发处理，而NIO一个线程能通过处理多个请求，只需要50或100个线程（简单理解）就行了。</p>
<p>同步非阻塞IO，每隔一段时间执行一次系统调用，不管fds集合中有没有相应的数据准备好，都会返回；</p>
<p>IO多路复用，每隔一段时间执行一次select&#x2F;poll&#x2F;epoll，有fds的数据准备好才会返回，没准备好的时候会一直轮询，避免了多次系统调用，也避免CPU空转。</p>
</blockquote>
<h3 id="select-x2F-poll-x2F-epoll的区别"><a href="#select-x2F-poll-x2F-epoll的区别" class="headerlink" title="select&#x2F;poll&#x2F;epoll的区别"></a>select&#x2F;poll&#x2F;epoll的区别</h3><blockquote>
<p>select的文件描述符集合fds是通过数组方式实现的，数组大小默认1024，有上限；</p>
<p>1先将fds从用户空间拷贝到内核空间；2内核去遍历判断是否有socket数据准备就绪，更改状态；3将fds从内核空间拷贝到用户空间；4用户线程遍历fds状态。   要两次拷贝，两次遍历。</p>
</blockquote>
<blockquote>
<p>poll和select的区别就是poll的文件描述符集合fds是通过链表实现的，没有上限，当然会受制于操作系统文件描述符上限；select和poll都需要线性遍历，时间复杂度O（n）;</p>
</blockquote>
<blockquote>
<p>epoll内核会创建红黑树存储事件，通过事件和回调机制，只会返回有事件发生的文件描述符，</p>
<p>时间复杂度O（n）；epoll通过内核和 ⽤户空间共享⼀块内存来实现的，无需select的两次拷贝。</p>
<p>epoll是Linux特有的，而select是所有操作系统都有的。</p>
</blockquote>
<h1 id="AIO-Asynchronous-I-x2F-O"><a href="#AIO-Asynchronous-I-x2F-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h1><p>异步IO基于事件和回调机制，应用进程发起系统调用后，会直接得到返回结果，等系统内核从内核空间向用户空间拷贝好之后，再通知用户进程。</p>
<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>
]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/11%E5%85%AB%E8%82%A1_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/sort1.png" alt="十大排序算法"></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>每次循环把最大值挪到最后，最小值逐渐向前挪（冒泡）。</p>
<p>时间复杂度：最好O(n)，最坏O(n2)，平均O(n2);</p>
<p>空间复杂度：O(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>每次循环，选择最小的，放到前边</p>
<p>时间复杂度：最好O(n2)，最坏O(n2)，平均O(n2);</p>
<p>空间复杂度：O(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minValIdx</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minValIdx]) &#123;</span><br><span class="line">                    minValIdx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minValIdx != i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[minValIdx];</span><br><span class="line">                arr[minValIdx] = arr[i];</span><br><span class="line">                arr[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>分治思想</strong>。</p>
<p>为了避免每次递归都创建一个新数组，事先创建一个O(n)的数组，用起止坐标控制；</p>
<p>每次递归，将左右两个数组借助临时数组进行排序。【后序遍历】</p>
<p>时间复杂度：最好O(nlogn)，最坏O(nlogn)，平均O(nlogn);</p>
<p>空间复杂度：O(n);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length, temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, mid, temp);</span><br><span class="line">        mergeSort(arr, mid, right, temp);</span><br><span class="line">        merge(arr, left, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid, idx = left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[idx++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[idx++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; mid) &#123;</span><br><span class="line">            temp[idx++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right) &#123;</span><br><span class="line">            temp[idx++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt; right; k++) &#123;</span><br><span class="line">            arr[k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>分治思想</strong>。</p>
<ol>
<li>从序列中随便选取一个元素，作为基准pivot，【一般取最后一个】</li>
<li>分区操作(partition)：然基准前的元素都小于基准，基准后的元素都大于基准；</li>
<li>以基准为分界线，递归进行分区操作。【前序遍历】</li>
</ol>
<p>时间复杂度：最好O(nlogn)，最坏O(nlogn)，平均O(nlogn);</p>
<p>空间复杂度：O(nlogn);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">povitIdx</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, povitIdx - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, povitIdx + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[right]) &#123;</span><br><span class="line">                swap(arr, i, pointer);</span><br><span class="line">                pointer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pointer, right);</span><br><span class="line">        <span class="keyword">return</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>并不是真的用堆的数据结构，而是看作堆。升序排列用大顶堆方便操作。</p>
<ol>
<li><p>先建立起大顶堆；</p>
<blockquote>
<p>heapify()方法，将某一个节点进行大顶堆化操作；i节点的左子节点索引为2i+1,右子节点索引为2i+2，在左右节点索引没超过heapLen前提下，比较找出三个节点中最大的，变成头节点；如果交换了节点，还要递归向下heapify()。</p>
</blockquote>
<blockquote>
<p>从最后一个非叶子节点（len &#x2F; 2 - 1）开始，到头节点，每个都要执行heapify()；这算是个剪枝操作，从最后一个节点开始也可以，但是叶子节点无需heapify()，因此可剪枝。</p>
</blockquote>
</li>
<li><p>依次将堆顶与最后一个对调，然后将剩余元素再建立大顶堆，heapLen减1；</p>
</li>
</ol>
<p>时间复杂度：最好O(nlogn)，最坏O(nlogn)，平均O(nlogn);</p>
<p>空间复杂度：O(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> heapLen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        heapLen = arr.length;</span><br><span class="line">        buildMaxHeap(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            heapLen--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * idx + <span class="number">1</span>, right = <span class="number">2</span> * idx + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapLen &amp;&amp; arr[left] &gt; arr[maxValIdx]) &#123;</span><br><span class="line">            maxValIdx = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapLen &amp;&amp; arr[right] &gt; arr[maxValIdx]) &#123;</span><br><span class="line">            maxValIdx = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxValIdx != idx) &#123;</span><br><span class="line">            swap(arr, maxValIdx, idx);</span><br><span class="line">            heapify(arr, maxValIdx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/0%E5%85%AB%E8%82%A1_Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="为什么重写equals方法还要重写hashCode方法？"><a href="#为什么重写equals方法还要重写hashCode方法？" class="headerlink" title="为什么重写equals方法还要重写hashCode方法？"></a>为什么重写equals方法还要重写hashCode方法？</h2><ul>
<li>首先，从判断两个对象相等的逻辑意义上来讲，从源码来看，在这两个方法都不重写时，equals用&#x3D;&#x3D;比较是内存地址，而hashCode也是通过对象的内存地址进行计算得到的。所以要判断两个对象逻辑上相等，既要保证equals相等，也要保证他们的hashCode相等</li>
<li>其次，是hashCode在应用层面，特别是在HashMap，HashSet的集合实现上，都是根据key对象的hashCode进行散列寻址的；所以如果只重写equals不重写hashCode，会造成equals判断相等的两个对象，对应HashMap中两个不同的节点，这会产生逻辑上的矛盾。</li>
</ul>
<h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><p>重写是针对父类或者接口的方法的覆盖，方法的名称，入参，返回值必须是完全相同的。</p>
<p>而重载是针对同一个类中，同一个名字方法的不同种实现，</p>
<p>重载的判断条件有两个：1、重载的两个方法名必须相同；2、传入参数的数量和种类不能完全相同。</p>
<p>至于重载的方法，它的权限public&#x2F;private，是否是静态方法static，返回值int&#x2F;void类型是否相同，不做要求，都可以。</p>
<blockquote>
<p><strong><code>如果问继续问说出java的一个返回值类型不同的重载方法？</code></strong></p>
<p>我想到了一个最近用过的一个工具类，CountDownLatch，他是JUC并发包下的，用于线程的并发流程控制。</p>
<p>我们new 一个 CountDownLatch实例的时候，会创建一个计时器并设置计数值，每有一个线程调用countDown()方法，计数值减一；</p>
<p>主线程会调用CountDownLatch实例的await方法，阻塞等待计时器被清零才会被唤醒；</p>
<p>如果直接调用await，不传入参数，那么表示这个等待永不超时；</p>
<p>如果await传入超时时间，那么它有一个boolean类型的返回值，判断这个唤醒是因为超时，还是计数器清零。</p>
<p>所以说这个类的await方法两个重载返回值类型不同。</p>
</blockquote>
<h2 id="IO密集型和CPU密集型？"><a href="#IO密集型和CPU密集型？" class="headerlink" title="IO密集型和CPU密集型？"></a>IO密集型和CPU密集型？</h2><p>IO密集型是指，系统的任务中，含有大量的数据传输，数据保存等IO工作，因此IO设备成为了限制系统性能的瓶颈；如网络通讯等web服务器。</p>
<p>而CPU密集型是指，系统的任务中，含有大量的CPU计算的工作，因此CPU性能和数量称为限制系统性能的瓶颈。如图像处理，数据加解密，对象序列化等任务。</p>
<h2 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h2><p>Function 函数  :一个输入，一个输出<br>Predicate 断言 ：一个输入，输出boolean<br>Supplier 供给 ：没输入，有输出<br>Consumer 消费 : 有输入，没输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有一个方法，并有@FunctionalInterface注解的接口;</p>
<p>通常是用匿名内部类实现这些接口，并且都能方便的写成lambda表达式的形式，简化编程代码。</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何<em>CRUD</em>。</p>
<p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p>
<p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">23</span>, <span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;c&quot;</span>, <span class="number">18</span>, <span class="string">&quot;suzhou&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>, <span class="number">29</span>, <span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>, <span class="number">35</span>, <span class="string">&quot;hangzhou&quot;</span>);</span><br><span class="line">        User[] users = <span class="keyword">new</span> <span class="title class_">User</span>[]&#123;u1,u2,u3,u4&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.stream(users)</span><br><span class="line">                .peek(user -&gt; user.setName(user.getName().toUpperCase()))</span><br><span class="line">                .filter(user -&gt; user.getAge() &lt; <span class="number">30</span>)</span><br><span class="line">                <span class="comment">//.map(User::getName)</span></span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((a,b) -&gt; b.getCity().compareTo(a.getCity()))</span><br><span class="line">                .forEach(user -&gt; list.add(user.getCity()));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;User&gt; users1 = Stream.of(users); <span class="comment">//还可以先通过Stream.of获取到流对象，再进行操作</span></span><br><span class="line">users1.forEach(System.out::println);    <span class="comment">//.forEach(user -&gt; System.out.println(user));</span></span><br></pre></td></tr></table></figure>

<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ol>
<li>修饰类 -&gt; 不可继承</li>
<li>修饰方法 -&gt; 不能被重写</li>
<li>修饰变量 -&gt;<br>   a. 基本数据类型，表示不可修改；<br>   b. 修饰引用类型，该引用不可指向其他对象；<br>   final修饰的变量必须初始化赋值；<br>   并且final在修饰一个类的静态变量时，它的赋值动作会提前到类加载的准备阶段；如果没被final修饰的话，在准备阶段是赋默认值，在初始化阶段才赋给用户代码设定的值。</li>
</ol>
<h2 id="Exception和Error"><a href="#Exception和Error" class="headerlink" title="Exception和Error"></a>Exception和Error</h2>]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/13%E5%85%AB%E8%82%A1_Redis_mongoDB/</url>
    <content><![CDATA[<h1 id="Redis基础概念"><a href="#Redis基础概念" class="headerlink" title="Redis基础概念"></a>Redis基础概念</h1><p>Redis是一种基于内存的数据库，读写速度快，常用于缓存；他是非关系型数据库nosql，数据采用键值对关系存储。</p>
<p>采用NIO的IO多路复用模型。默认一共有16个库。redis服务进程是单线程的。</p>
<blockquote>
<p>关系型数据库:像mysql数据库，表中的每条记录都有字段关系的约束。</p>
</blockquote>
<h1 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>最基本的数据类型，可以存储字符串，整数，浮点数，jpg，序列化的对象等等。最大512MB</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>可以看成一个map容器，一个容器可以存储多个键值对。&lt;key,&lt;key1,value&gt;&gt;</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>双向链表结构</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序不可重复集合</p>
<h2 id="Zset-Sorted-set"><a href="#Zset-Sorted-set" class="headerlink" title="Zset(Sorted set)"></a>Zset(Sorted set)</h2><p>有序不可重复集合；每个元素有一个分数（score），默认按照分数从小到大排序</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB持久化（全量同步）（默认开启）"><a href="#RDB持久化（全量同步）（默认开启）" class="headerlink" title="RDB持久化（全量同步）（默认开启）"></a>RDB持久化（全量同步）（默认开启）</h2><p>周期性的将redis数据以snapshot形式存储到二进制文件，一般一个小时一次；</p>
<p>redis通过fork一个子线程来定时生成rdb文件，避免影响redis服务进程的执行效率。</p>
<h2 id="AOF持久化（增量同步）"><a href="#AOF持久化（增量同步）" class="headerlink" title="AOF持久化（增量同步）"></a>AOF持久化（增量同步）</h2><p>AOF文件记录的是redis的增删改操作；</p>
<p>AOF同步策略：1. 每秒同步 2.每个增删改操作同步 3.不同步</p>
<blockquote>
<ol>
<li>RDB存储的是压缩过的二进制文件，占用空间小；AOF占用空间大；因此RDB更适合做备份，并且RDB是存储的快照，恢复大量数据时速度比较快。</li>
<li>AOF文件可以做到秒级备份，安全性更高。</li>
<li>如果对于数据丢失安全性要求不高，只用RDB就行了；如果对安全性要求较高，可以RDB和AOF混用。</li>
</ol>
</blockquote>
<h1 id="Redis缓存的好处"><a href="#Redis缓存的好处" class="headerlink" title="Redis缓存的好处"></a>Redis缓存的好处</h1><p>因此磁盘的访问速度远低于内存的访问速度，常用的数据缓存到内存中，能保证系统的高可用性和并发性。</p>
<h1 id="Redis的三种缓存读写（更新）策略"><a href="#Redis的三种缓存读写（更新）策略" class="headerlink" title="Redis的三种缓存读写（更新）策略"></a>Redis的三种缓存读写（更新）策略</h1><h2 id="旁路缓存"><a href="#旁路缓存" class="headerlink" title="旁路缓存"></a>旁路缓存</h2><p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-write.png" alt="img"></p>
<p><strong>读</strong>的时候：1.先到redis中读取 2.如果没有数据，就去数据库中读 并返回3. 再把数据放到redis中；</p>
<p><strong>写</strong>的时候：1.先更新数据库 2.然后直接删除缓存中对应的数据</p>
<blockquote>
<p>必须先更新db，再删除cache; 否则如果先删除cache再更新db，会造成cache和db数据不一致</p>
</blockquote>
<h2 id="读写穿透"><a href="#读写穿透" class="headerlink" title="读写穿透"></a>读写穿透</h2><p>读的时候：1.先到redis中读取 2.如果没有数据，就去数据库加载数据到redis 3.redis返回数据</p>
<p>写的时候：1.先查cache，cache不存在，直接更新db；2.如果查到cache,直接更新cache,然后由redis更新db；</p>
<h2 id="异步缓存写入"><a href="#异步缓存写入" class="headerlink" title="异步缓存写入"></a>异步缓存写入</h2><p>与读写穿透相似，都是由redis来更新db，但是这个更新是批量异步更新的。这点和mysql的批量同步机制类似。</p>
<h1 id="除了缓存Redis还能干什么"><a href="#除了缓存Redis还能干什么" class="headerlink" title="除了缓存Redis还能干什么"></a>除了缓存Redis还能干什么</h1><ol>
<li>消息队列</li>
<li>分布式锁</li>
<li>限流</li>
</ol>
<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>redis事务比较鸡肋，应用较少，不能保证原子性；且事务中的每个命令都要redis服务器进行一次交互，比较浪费网络资源。</p>
<p>为了解决redis事务的缺陷，提出了Lua脚本，可以批量的原子性的执行redis命令，减少网络开销。</p>
<p>Lua脚本在执行过程中不会有其他Lua脚本和redis执行同时执行；但是Lua脚本如果执行到一半出现崩溃，后面的不会执行，执行过的也不会回滚。</p>
<h1 id="Redis生产问题"><a href="#Redis生产问题" class="headerlink" title="Redis生产问题"></a>Redis生产问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>频繁的使用大量不存在的key进行查询，导致缓存无法命中，给数据造成很大压力。</p>
<p>解决方案：</p>
<ol>
<li>缓存无效的key【没太大用，因为黑客攻击会使用大量不同的key】</li>
<li>对客户端限流，限制请求频率。</li>
<li>布隆过滤器【将所有可能存在的请求的值都放在布隆过滤器中，请求来了之后先用布隆过滤器判断，如果请求无效，直接返回错误参数给客户端。】</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>热点key的过期问题。热key过期瞬间会有大量请求打到数据库，给数据库造成压力。</p>
<p>解决方案：</p>
<ol>
<li>设置热key永不过期，或设置一个比较长的过期时间。</li>
<li>在秒杀场景下，对热key提前预热，设置在秒杀结束之前不过期。</li>
<li>请求数据库写到缓存的这个操作，加互斥锁，保证只有一个请求到达数据库。</li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>在同一时间有大量key同时失效，导致大量请求都打到数据库上。</p>
<p>解决方法：</p>
<ol>
<li>失效时间都加一个随机值；</li>
<li>集群部署redis</li>
<li>设置所有Key永不过期【笨方法】</li>
</ol>
<h1 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h1><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>在用到key的时候，再对数据进行过期检查，删除过期数据，这样对CPU友好</p>
<h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><p>每隔一段时间对过期数据进行删除，这样对内存友好；</p>
<blockquote>
<p>redis采用 惰性删除 + 定期删除的策略</p>
</blockquote>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>如果用单点redis，那么redis挂了之后全部请求都打在db，给数据库带来很大压力。</p>
<p>主从复制就是建立一个redis主节点master，可以有多个从节点来同步主节点的数据，从而实现主节点写，从节点读；当主节点宕机了，可以从从节点中选择一个作为主节点来实现故障转移。保证redis的高可用性。</p>
<h2 id="主从复制下，从节点数据过期怎么处理？"><a href="#主从复制下，从节点数据过期怎么处理？" class="headerlink" title="主从复制下，从节点数据过期怎么处理？"></a>主从复制下，从节点数据过期怎么处理？</h2><p>从节点数据过期的话，会删除过期数据，并返回空值；</p>
<h2 id="主从过期时间不一致问题？"><a href="#主从过期时间不一致问题？" class="headerlink" title="主从过期时间不一致问题？"></a>主从过期时间不一致问题？</h2><p>由于主从同步时，网络传输原因，可能造成过期时间不一致，因为如果采用EXPIRE设置过期时间，是按照命令执行时间开始计时过期时间的；因此可以采用设置UNIX时间戳的过期时间设置方式，但要注意主从节点的时区设置一致。</p>
<h2 id="如何实现主从同步？"><a href="#如何实现主从同步？" class="headerlink" title="如何实现主从同步？"></a>如何实现主从同步？</h2><ol>
<li>首次主从连接的时候，采用全量同步，用主节点的RDB文件来给从节点进行同步；</li>
<li>后续操作，采用增量同步，根据主节点的AOF文件，主节点根据从节点的offset偏移量，讲偏移量后的数据同步到从节点</li>
</ol>
<h2 id="主从复制的缺陷"><a href="#主从复制的缺陷" class="headerlink" title="主从复制的缺陷"></a>主从复制的缺陷</h2><p>如果主节点宕机，需要人工选取一个从节点来作为新的主节点，进行配置，不能够自动完成。这时就需要哨兵机制了。</p>
<h1 id="Sentinal"><a href="#Sentinal" class="headerlink" title="Sentinal"></a>Sentinal</h1><p>Sentinal（哨兵）模式是一种redis的运行方式，在主从复制的基础上，多了哨兵角色，来监控redis节点运行状态，自动完成故障转移。</p>
<p>想要保证高可用性，sentinal数量应大于等于3且为单数。防止sentinal误判。</p>
<blockquote>
<ol>
<li>sentinal会检测集群中所有节点的运行状态</li>
<li>当主节点故障，且判断出主节点故障的哨兵数量大于预设阈值，则判定主节点下线；</li>
<li>判定主节点下线后，采取故障转移，把一个从节点升级为主节点，并完成相应主从关系的配置。</li>
</ol>
</blockquote>
<blockquote>
<p>每隔sentinal每隔一段时间会向集群中所有节点发送ping命令，如果收到回复超时，则单个sentinal会判断某个redis节点的<strong>主观下线</strong>；当判断某个节点的sentinal数量大于预设阈值时，则判断该节点<strong>客观下线</strong>。</p>
</blockquote>
<h2 id="sentinal如何选举新的master"><a href="#sentinal如何选举新的master" class="headerlink" title="sentinal如何选举新的master"></a>sentinal如何选举新的master</h2><ol>
<li>首先看从节点的优先级replica-priority，挑优先级最高的从节点选做master；（最高优先级是1，最低是100；0表示永不被升级）</li>
<li>优先级相同，则看哪个节点的数据偏移量，偏移量越大说明同步到的原主节点数据越多，则优先被选为master；</li>
<li>最后看runid；每个redis启动时都会生成一个40位的随机数作为runid，选取runid最小的升级。</li>
</ol>
<h1 id="Cluster集群"><a href="#Cluster集群" class="headerlink" title="Cluster集群"></a>Cluster集群</h1><h2 id="为什么需要Cluster集群"><a href="#为什么需要Cluster集群" class="headerlink" title="为什么需要Cluster集群"></a>为什么需要Cluster集群</h2><p>传统的主从复制和哨兵集群只有一个master，每个节点都保存全部数据，通过故障转移策略，来保证高可用性，和<strong>读</strong>吞吐量；但是无法解决数据总量过大带来的缓存压力和<strong>写</strong>压力。</p>
<p>因此有了Cluster集群，能够配置多个master节点，每个master节点可以有一个或多个从节点；</p>
<p>存储数据根据key值进行负载均衡，分别存储在各个主从节点；Cluster集群是去（无）中心化的，每个主节点都可以作为集群入口，根据查找的key值不同，根据路由原则，讲请求分发到对应的master。</p>
<p>通过横向扩展可以根据需求方便的进行集群动态扩容和缩容；</p>
<h2 id="一个最基本的cluster集群"><a href="#一个最基本的cluster集群" class="headerlink" title="一个最基本的cluster集群"></a>一个最基本的cluster集群</h2><p>为了保证高可用性，最基本的cluster集群要3个master，每个master配有一个slave，当一个master挂掉，由它的从节点代替成为master。</p>
<h2 id="哈希槽slots"><a href="#哈希槽slots" class="headerlink" title="哈希槽slots"></a>哈希槽slots</h2><p>一个cluster集群有16384 &#x3D; 2^14 &#x3D; 16K个哈希槽，根据key值，对数据进行哈希，分配到每个哈希槽，每个主节点及其从节点负责一定数量的哈希槽的数据存储与访问；</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>如果当前访问的key对应的哈希槽与redis节点不对应，则请求会被重定向到相应节点。</p>
<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>一种非关系型数据库，为快速开发web应用而生，灵活性更强；</p>
<p>其数据模型是面向文档的，所谓文档是一种类似JSON的结构，称为BSON，可以存储比较复杂的数据类型。</p>
<h2 id="MongoDB的存储结构"><a href="#MongoDB的存储结构" class="headerlink" title="MongoDB的存储结构"></a>MongoDB的存储结构</h2><ul>
<li>文档：由BSON键值对组成，类似于关系型数据库的行；BSON（Binary JSON 二进制JSON，遍历速度优于JSON）</li>
<li>集合：一个集合可以包含多个文档，类似于关系型数据库的表；集合没有固定的结构，但是集合中存放的文档往往是有一定联系的。</li>
<li>数据库：一个数据库可以包含多个文档</li>
</ul>
<h2 id="MongoDB的特点"><a href="#MongoDB的特点" class="headerlink" title="MongoDB的特点"></a>MongoDB的特点</h2><ul>
<li>数据记录为文档格式，具体来说是BSON文档，类似于JSON的结构；</li>
<li>模式自由：文档存放在集合中，集合相当于关系型数据库表的概念，但是没有固定的表结构，比较灵活。</li>
<li>支持事务：虽然是NoSQL,但是支持事务</li>
<li>支持索引：索引类型多样</li>
<li>支持分片集群</li>
<li>支持存储大文件</li>
</ul>
<h2 id="MongoDB的适合应用场景"><a href="#MongoDB的适合应用场景" class="headerlink" title="MongoDB的适合应用场景"></a>MongoDB的适合应用场景</h2><p>MongDB的优势在于其数据模型灵活，便于扩展。</p>
]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/14%E5%85%AB%E8%82%A1_%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList基于动态数组实现，当使用无参构造函数创建一个ArrayList对象时，初始化一个空数组，当第一次往里面add值得时候，数组扩容为10，之后每次当容量满的时候，扩容为原来的1.5倍。扩容时先创建一个新容量的数组，然后将原数据拷贝过去。</p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>在JDK1.8之前，基于<strong>数组</strong>+<strong>链表</strong>实现，JDK1.8之后，基于<strong>数组</strong>+链表+<strong>红黑树</strong>；</p>
<h2 id="寻址算法"><a href="#寻址算法" class="headerlink" title="寻址算法"></a>寻址算法</h2><p>HashMap时根据key对象的hashCode进行散列的，首先要对key对象的hashCode进行一个扰动函数处理，扰动函数的目的是散列效果更好，减小哈希冲突。</p>
<blockquote>
<p>JDK1.8的扰动函数hash()      (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p>
<p>将hashCode有符号右移16位，然后和原来的hashCode异或，得到哈希值</p>
</blockquote>
<p>寻址： hash &amp; (n - 1)  n位数组长度</p>
<h2 id="为什么HashMap的数组长度要是2的整数次方？"><a href="#为什么HashMap的数组长度要是2的整数次方？" class="headerlink" title="为什么HashMap的数组长度要是2的整数次方？"></a>为什么HashMap的数组长度要是2的整数次方？</h2><p>这要从HashMap的寻址算法说起了，寻址的思想就是对key的哈希值对数组长度进行取模运算，但是计算机取模运算速度比较慢，因此HashMap用与运算来代替取模，采用hash &amp; (n - 1)的方式进行寻址，提高计算速度。</p>
<p> 这样计算的原理是：n是2的次方，那么n-1的二进制表示就都是1，和哈希值相与的话，比n大的二进制位就都变成了0，其效果和取模运算是相同的；如果数组长度不是2的整数次方，还使用这种寻址方式的话，那么n-1低位就不都是1了，与运算得到的散列效果就不会连续的了，哈希冲突概率提高。</p>
<h2 id="HashMap如何解决哈希冲突"><a href="#HashMap如何解决哈希冲突" class="headerlink" title="HashMap如何解决哈希冲突"></a>HashMap如何解决哈希冲突</h2><p>HashMap通过拉链法解决哈希冲突，如果有key寻址到数组的相同位置，那么就通过链表的方式存储后添加进来的元素。JDK1.8之前采用头插法，之后采用尾插法。</p>
<p>当链表长度大于转换阈值（默认是8）的时候，如果数组长度＞64，会优先进行扩容，如果数组长度≥64，链表会转化成红黑树；如果红黑树的节点数≤6，红黑树会退化成链表。</p>
<h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><p>通过无参构造函数new一个HashMap对象时，会创建一个空的数组，第一次put值的时候，初始化一个长度为16的数组。</p>
<p>当HashMap中的<strong>节点数量</strong>（k-v数量）＞数组长度<em>负载因子（默认为0.75）时（初始为16</em> x 0.75 &#x3D; 12），数组容量扩容为原来的2倍，并进行resize()，扩容时会创建新的数组，并对原有的链表和红黑树结构的元素数据进行重新哈希分配rehash</p>
<h2 id="为什么链表到红黑树的转化因子是8？"><a href="#为什么链表到红黑树的转化因子是8？" class="headerlink" title="为什么链表到红黑树的转化因子是8？"></a>为什么链表到红黑树的转化因子是8？</h2><p>在理想条件下，使用随机hashCode进行寻址，每个节点在桶中出现的概率是遵循泊松分布的，当我们的负载因子选用0.75时，一个桶中出现链表长度大于8的概率不超过千万分之一。</p>
<h2 id="为什么要引入红黑树"><a href="#为什么要引入红黑树" class="headerlink" title="为什么要引入红黑树"></a>为什么要引入红黑树</h2><p>因为链表的搜索时间复杂度时O（n），当链表长度过长时，搜索效率大大降低；红黑树是log(n)，但是红黑树的空间占用大（链表的2倍）；因此在节点数较少时，红黑树的搜索时间复杂度并不比链表高多少，采用链表，当节点数多时才转换成红黑树。</p>
<blockquote>
<p>红黑树：自动平衡，自动排序。</p>
</blockquote>
<h2 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h2><h3 id="Iterator迭代器—EntrySet"><a href="#Iterator迭代器—EntrySet" class="headerlink" title="Iterator迭代器—EntrySet"></a>Iterator迭代器—EntrySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">	Map.Entry&lt;Integer, Integer&gt; entry = it.next();</span><br><span class="line">	<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">	<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iterator迭代器—KeySet"><a href="#Iterator迭代器—KeySet" class="headerlink" title="Iterator迭代器—KeySet"></a>Iterator迭代器—KeySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; it = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> it.next();</span><br><span class="line">	<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> map.get(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Foreach—EntrySet"><a href="#Foreach—EntrySet" class="headerlink" title="Foreach—EntrySet"></a>Foreach—EntrySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">	<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Foreach—KeySet"><a href="#Foreach—KeySet" class="headerlink" title="Foreach—KeySet"></a>Foreach—KeySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Streams-API-单线程"><a href="#Streams-API-单线程" class="headerlink" title="Streams API 单线程"></a>Streams API 单线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Streams-API-多线程"><a href="#Streams-API-多线程" class="headerlink" title="Streams API 多线程"></a>Streams API 多线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="速度比较"><a href="#速度比较" class="headerlink" title="速度比较"></a>速度比较</h3><p>1.迭代器EntrySet 2.foreach EntrySet 3.foreach KeySey 4. 迭代器KeySet 5.Lambda 6.Streams API</p>
<p><strong><code>entrySet</code> 的性能比 <code>keySet</code> 的性能高出了一倍之多，因此我们应该尽量使用 <code>entrySet</code> 来实现 Map 集合的遍历</strong>。</p>
<h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>不能在遍历map时，通过map.remove()方法来删除元素，这是不安全的操作；但是可以用迭代器，通过迭代器的iterator.remove()来安全的删除元素。</p>
<p>同样的我们也可以使用 Lambda 中的 <code>removeIf</code> 来提前删除数据，或者是使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 <code>for</code> 循环前删除数据在遍历也是线程安全的。</p>
]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/4%E5%85%AB%E8%82%A1_JUC/</url>
    <content><![CDATA[<h1 id="JUC基本概念"><a href="#JUC基本概念" class="headerlink" title="JUC基本概念"></a><strong>JUC基本概念</strong></h1><h2 id="JUC是什么"><a href="#JUC是什么" class="headerlink" title="JUC是什么"></a>JUC是什么</h2><p>使用java.util.concurrent包编程，完成多线程并发编程。</p>
<p>并发编程的目的：充分利用CPU资源，提高cpu执行效率</p>
<p>并发编程可能带来的问题：内存泄漏、死锁、线程不安全等</p>
<h2 id="JVM能直接开启线程吗"><a href="#JVM能直接开启线程吗" class="headerlink" title="JVM能直接开启线程吗"></a>JVM能直接开启线程吗</h2><p>java只能通过native本地方法去调用，来和操作系统之间进行交互，Java不能直接操控系统底层</p>
<h2 id="并行-并发"><a href="#并行-并发" class="headerlink" title="并行 并发"></a>并行 并发</h2><blockquote>
<p>并行：微观上线程同时进行，多核技术  ；  并发：微观上交替进行，宏观上同时进行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object类的wait-notify-notifyAll"><a href="#Object类的wait-notify-notifyAll" class="headerlink" title="Object类的wait(), notify(),  notifyAll()"></a>Object类的wait(), notify(),  notifyAll()</h2><p>都是C语言编写的本地native代码</p>
<blockquote>
<p>执行这几个方法的线程都必须先获得某个对象的锁，因此必须在synchronized作用的语句块或方法中调用</p>
</blockquote>
<p><strong>wait</strong>() : 调用该方法的线程，释放掉某一对象的锁，进入等待池</p>
<p><strong>notify</strong>():唤醒处在等待该对象的线程，等待池中的线程开始争夺这个对象锁。</p>
<blockquote>
<p>notify()：等待池中的线程被随机唤醒，但Hotspot虚拟机是顺序唤醒的</p>
<p>notifyAll():默认情况是最后进入的会先被唤起来,即LIFO的策略</p>
</blockquote>
<p><strong>notify()或者notifyAll()调用时并不会真正释放对象锁, 必须等到synchronized方法或者语法块执行完才真正释放锁.</strong></p>
<h2 id="java线程的6个状态"><a href="#java线程的6个状态" class="headerlink" title="java线程的6个状态"></a>java线程的6个状态</h2><p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" alt="Java 线程状态变迁图"></p>
<ol>
<li><p>new初始  </p>
</li>
<li><p>runnable运行  </p>
<p>相当于操作系统进程的<strong>就绪态</strong>+<strong>运行态</strong> </p>
<p>就绪态：获得了除CPU外的一切资源</p>
</li>
<li><p>blocked阻塞</p>
<p>线程由于请求的资源（java对象）被锁住了而等待，具体来说是等待请求对象Object的monitor lock，Object通过监视器monitor来保证自身的线程安全，拿到监视器锁的线程才能访问该对象。</p>
</li>
<li><p>waiting等待  </p>
<p>表示线程处于无限期的等待状态，要等到其他线程的notify()或notifyAll(),或者该线程join的线程终止。</p>
</li>
<li><p>timed_waiting有限时间等待</p>
<p>表示线程处于有限期的等待状态，可能是该线程使用了sleep方法，或者调用了有限时间的Object.wait()方法，或有限时间的Thread.join()方法</p>
<blockquote>
<p>join方法，在一个线程t1中调用t2.join(),表示t1线程主动进入等待状态，等待t2线程终结才能重新运行。</p>
<p>往往适用于t1线程需要等待t2线程的结果，要等待t2执行完毕再去运行</p>
</blockquote>
</li>
<li><p>terminated终止</p>
</li>
</ol>
<h2 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep() 和 wait()的区别"></a>sleep() 和 wait()的区别</h2><ol>
<li>来自不同的类，sleep是Thread的一个本地静态方法，wait()是Object的本地普通方法。</li>
<li>是否释放锁</li>
</ol>
<ul>
<li>sleep()方法，线程进入休眠，但不会释放锁</li>
<li>wait()方法，释放锁，线程进入等待池，等待notify唤醒</li>
</ul>
<ol start="3">
<li>适用范围</li>
</ol>
<ul>
<li>wait只能用在同步代码块中，sleep在线程代码任意地方都能用</li>
</ul>
<h2 id="可以直接调用Thread的run方法吗？"><a href="#可以直接调用Thread的run方法吗？" class="headerlink" title="可以直接调用Thread的run方法吗？"></a>可以直接调用Thread的run方法吗？</h2><p>可以的，但是如果直接调用Thread的run方法，会当作main线程下的普通方法去执行，并不是多线程工作；</p>
<p>调用Thread的start方法，才是开启多线程执行，自动执行run方法。</p>
<h2 id="线程上下文切换？"><a href="#线程上下文切换？" class="headerlink" title="线程上下文切换？"></a>线程上下文切换？</h2><p>当发生以下情况时，会发生进程的上下文切换：</p>
<ol>
<li>当一个线程时间片用完了</li>
<li>线程中调用了sleep wait方法，主动让出CPU</li>
<li>线程运行中请求了阻塞型的系统调用，如请求IO</li>
</ol>
<p>当线程退出CPU使用时，会保存当前的程序计数器，栈信息等，当线程重新获得CPU使用权时，再恢复现场。</p>
<blockquote>
<p>由于上下文切换时，保存和恢复现场也需要占据一定的CPU时间，因此频繁上下文切换会降低CPU利用率。</p>
</blockquote>
<h2 id="Runnable-和-Callable"><a href="#Runnable-和-Callable" class="headerlink" title="Runnable 和 Callable"></a>Runnable 和 Callable</h2><p>创建线程： new Thread(Runnable target)，传入一个Runnable实现类</p>
<p>Runnable是一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask是Runnable的实现类，可作为Callable的适配类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">System.out.println(futureTask.get());  <span class="comment">//获取call()的返回值</span></span><br></pre></td></tr></table></figure>

<p>callable接口类似于runnable，但是call()方法能够有返回值，需要抛异常。</p>
<p>callable的返回结果可以通过FutureTask.get()方法获取，返回结果有缓存，可能阻塞【放到代码最后，或者异步方式获取】</p>
<h1 id="java锁"><a href="#java锁" class="headerlink" title="java锁"></a><strong>java锁</strong></h1><blockquote>
<p> java锁的实现方式有synchronized关键字和Lock接口</p>
</blockquote>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized是java内置关键字，在java早期版本，synchronized是重量级锁，因为监视器锁依赖于底层操作系统的<strong>Mutex Lock</strong>实现，Java线程是映射到操作系统的原生线程上的，线程切换需要用户态与核心态之间转换，时间成本较高。</p>
<p>在Java6之后，对synchronized进行了优化，较少了锁的开销，因此现在很多开源框架使用synchronized</p>
<blockquote>
<p>synchronized如何使用？</p>
<ol>
<li>修饰实例方法：锁实例对象</li>
<li>修饰静态方法：锁当前类的Class对象</li>
<li>修饰代码块，锁代码块括号里配置的对象。</li>
</ol>
</blockquote>
<p>普通方法不受锁的影响，在main线程被调用。</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock接口，具体实现类有ReentrantLock, </p>
<p>使用方法：</p>
<ol>
<li>Lock l &#x3D; …</li>
<li>l.lock();  &#x2F;&#x2F;上锁</li>
<li>try{&#x2F;&#x2F;执行业务代码}  finally{l.unlock() &#x2F;&#x2F;解锁}</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) System.out.println(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock接口的实现是通过聚合了一个<strong>队列同步器(AbstractQueuedSynchronizer)AQS</strong>的子类来实现的。</p>
<p>锁是面向锁的使用者，隐藏了实现细节；</p>
<p>同步器是面向锁的实现者，简化了锁的实现方式，屏蔽了底层操作系统的一些细节。</p>
<h3 id="什么是可重入锁？"><a href="#什么是可重入锁？" class="headerlink" title="什么是可重入锁？"></a>什么是可重入锁？</h3><p>可重入是指当一个线程拥有了某一个资源的锁之后，可以再次上锁。</p>
<p>比如一个线程调用了一个对象的同步方法，对这个对象上了一次锁，在这个方法里还需再调用该对象的另一个同步方法，那么可重入锁是支持再次上锁的。不可重入锁就会被自己阻塞。</p>
<p>ReentrantLock和synchronized都是可重入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span>  &#123;</span><br><span class="line">        B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="synchronized和Lock的区别？"><a href="#synchronized和Lock的区别？" class="headerlink" title="synchronized和Lock的区别？"></a>synchronized和Lock的区别？</h2><p>主要区别：</p>
<ol>
<li>synchronized是关键字，Lock是一个接口</li>
<li>synchronized会自动释放锁，lock必须手动释放锁</li>
</ol>
<p>Lock的具备的优点：</p>
<ol>
<li>能够通过tryLock()方法，<strong>尝试非阻塞的获取锁</strong></li>
<li>获取到锁的线程，<strong>能够被中断</strong>，线程被中断后抛出终端异常，同时锁被释放；</li>
<li>获取锁有超时机制，到达截止时间还获取不到锁会直接返回。</li>
</ol>
<p>因此Lock锁的可操作性更强。</p>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a>synchronized实现</h3><p>资源类的操作方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(判断条件) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait(); <span class="comment">//等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">    <span class="built_in">this</span>.notifyAll();  <span class="comment">//通知其他线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>资源类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= <span class="number">5</span>) &#123;     <span class="comment">//5 是仓库最大容量</span></span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;     <span class="comment">//业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Producer  &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + num);</span><br><span class="line">        <span class="comment">//通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer  &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + num);</span><br><span class="line">        <span class="comment">//通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><blockquote>
<p>资源类操作方法中，如果判断等待条件要用while,如果用if，在多生产者、消费者时，会出现<strong>虚假唤醒</strong> ，造成逻辑越界，也就是超过我们设定的容量范围</p>
</blockquote>
<p><strong>产生原因</strong>：</p>
<p>虚假唤醒是因为，当我们notify的时候，唤醒了所有等待的线程，由于是If判断，被唤醒的线程在拿到资源对象的监视器锁之后，会直接运行wait()方法后面的业务代码，不会再管此时的判断条件，就会导致业务逻辑上的越界。</p>
<p>虚假唤醒是因为：</p>
<ul>
<li><p>我们一个线程notify的时候，唤醒了所有等待的线程；</p>
</li>
<li><p>并且如果是if条件判断，被唤醒的线程如果拿到监视器锁，就会接着上次wait的代码继续执行，就不管这个if约束了；</p>
</li>
<li><p>最先获得监视器锁的线程，执行业务逻辑是没有问题的，但是后续获得监视器锁的其他线程，如果继续执行业务代码时，就可能导致逻辑上的越界。</p>
<p>ps:某一时刻，资源为0，所有消费者进程进入等待，生产者生产了一些资源，唤醒了消费者进程，之后的一段时间内，消费者消费的速度大于生产速度（cpu时间片分配的更多），第一个获得锁的消费者1执行了一段时间代码，cpu时间片用光了，消费者2获得锁，也要执行业务代码，就可能导致资源小于0了。</p>
</li>
</ul>
<p><strong>解决方式</strong>：</p>
<p>将if换成while，那么一个线程被唤醒的时候，会再判断以下逻辑条件，如果不满足则再次进入等待。</p>
<h3 id="JUC-Lock实现"><a href="#JUC-Lock实现" class="headerlink" title="JUC Lock实现"></a>JUC Lock实现</h3><p>JUC.Lock接口 替换synchronized关键字</p>
<p>JUC.Condition接口 替换Object监视器锁的wait和notify方法</p>
<blockquote>
<p>Condition.await() -&gt; Object.wait()</p>
<p>Condition.signal() -&gt; Object.nofity()</p>
<p>Condition.signalAll() -&gt; Object.notifyAll()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data2</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data2.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data2.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data2.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data2.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();        <span class="comment">//Lock接口  替代了synchronized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();     <span class="comment">//Condition接口  替代了Object监视器的wait,notify方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= <span class="number">5</span>) &#123;     <span class="comment">//5是最大容量</span></span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;     <span class="comment">//业务</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Producer  &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + num);</span><br><span class="line">            <span class="comment">//通知其他线程</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">0</span>) &#123;     <span class="comment">//5是最大容量</span></span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num--;     <span class="comment">//业务</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Producer  &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + num);</span><br><span class="line">            <span class="comment">//通知其他线程</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JUC-Lock-x2F-Condition实现方式的优点"><a href="#JUC-Lock-x2F-Condition实现方式的优点" class="headerlink" title="JUC Lock&#x2F;Condition实现方式的优点"></a>JUC Lock&#x2F;Condition实现方式的优点</h4><blockquote>
<p>JUC.Condition能够实现精准的<strong>通知</strong>某个线程唤醒，将资源类创建多个condition，不同方法锁不同condition，通知的时候调用指定的condition.notify()</p>
</blockquote>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock是一个接口，ReentrantReadWriteLock是它的实现类，在ReentrantLock上实现了更高粒度的锁。</p>
<p>readWriteLock.readLock();加读锁</p>
<p>readWriteLock.writeLock();加写锁</p>
<p>读-读共享，写-写互斥，读-写互斥。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">readWriteLock.readLock();</span><br><span class="line">readWriteLock.writeLock();</span><br></pre></td></tr></table></figure>

<h1 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a><strong>并发集合</strong>类</h1><p>Java普通集合进行并发写操作，可能会报ConcurrentModificationException并发修改异常。</p>
<h2 id="ArrayList的并发问题"><a href="#ArrayList的并发问题" class="headerlink" title="ArrayList的并发问题"></a>ArrayList的并发问题</h2><ol>
<li>List<String> list &#x3D; new Vector&lt;&gt;();</li>
<li>List<String> list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</li>
<li>List<String> list &#x3D; new CopyOnWriteArrayList&lt;&gt;() ;</li>
</ol>
<p>1.Vector的添加和删除方法都有synchronized关键字作用，都是同步方法；</p>
<p>2.Collections工具类的synchronizedList方法，能够将容器变为线程安全的，也是基于synchronized关键字的。</p>
<p>3.CopyOnWriteArrayList在JUC并发包下的一个类，通过ReentrantLock+写时复制+volatile关键字保证并发安全。</p>
<blockquote>
<p>读操作不加锁，写操作时先加ReentrantLock锁，</p>
</blockquote>
<blockquote>
<p>然后利用写时复制（COW），复制原数据数组，然后在新数组上进行写操作，写操作完成之后，将新数组的引用赋给容器。最后解锁。</p>
</blockquote>
<blockquote>
<p>并通过volatile关键字保证可见性，让其他线程能立刻感知到。</p>
</blockquote>
<p>优点：相比于synchronized关键字，更加轻量化，并发效率更高。</p>
<h2 id="HashSet-并发问题"><a href="#HashSet-并发问题" class="headerlink" title="HashSet 并发问题"></a>HashSet 并发问题</h2><ol>
<li>List<String> list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</li>
<li>List<String> list &#x3D; new <strong>CopyOnWriteArraySet</strong>&lt;&gt;()</li>
</ol>
<h2 id="HashMap并发问题"><a href="#HashMap并发问题" class="headerlink" title="HashMap并发问题"></a>HashMap并发问题</h2><ol>
<li>Collections.synchronizedMap();</li>
<li>HashTable  &#x2F;&#x2F;基于synchronized关键字</li>
<li>ConcurrentHashMap</li>
</ol>
<h3 id="ConcurrentHashMap-底层实现原理"><a href="#ConcurrentHashMap-底层实现原理" class="headerlink" title="ConcurrentHashMap  底层实现原理"></a>ConcurrentHashMap  底层实现原理</h3><p><a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#concurrenthashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB">Java集合常见面试题总结(下) | JavaGuide(Java面试+学习指南)</a></p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>非阻塞的线程安全的队列，采用循环CAS方式实现</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列BlockingQueue,是一个线程安全接口，</p>
<p>之所以阻塞，是因为队列有<strong>容量</strong>，容量满了添加就会阻塞，容量为0读取元素也会阻塞。</p>
<p>主要api有4组类型，与线程不安全的队列相比，多了后边两组。</p>
<p><img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230421195340584.png" alt="image-20230421195340584"></p>
<p>主要实现类:</p>
<ul>
<li>ArrayBlockingQueue  :数组实现</li>
<li>LinkedBlockingQueue ：链表实现</li>
<li>PriorityBlockingQueue : 支持优先级排序</li>
<li>SynchronousQueue: 是一个不存储元素(可理解为容量为0，或理解为时刻都保持full)的阻塞队列，作用是起一个传递作用。使用时，一般只用put和take操作，一个线程put之后阻塞，然后等待另一个线程的take操作。</li>
</ul>
<h1 id="JUC并发工具类"><a href="#JUC并发工具类" class="headerlink" title="JUC并发工具类"></a>JUC并发工具类</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><blockquote>
<p>我们new 一个 CountDownLatch实例的时候，会创建一个计时器并设置计数值，</p>
<p>每有一个线程调用countDown()方法，计数值减一；</p>
<p>主线程会调用CountDownLatch实例的await方法，阻塞等待计时器被清零才会被唤醒,或者等到超时时间；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行完毕&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> countDownLatch.await(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;6个线程全部执行结束&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束时计数器是否被置0 : &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用途：某线程如果需要等待其他多个线程的结果才能执行，可以使用CountDownLatch实现这种线程通信。</p>
<h3 id="join也能实现，为什么还要用CountDownLatch？"><a href="#join也能实现，为什么还要用CountDownLatch？" class="headerlink" title="join也能实现，为什么还要用CountDownLatch？"></a>join也能实现，为什么还要用CountDownLatch？</h3><p>​		join是让当前执行线程等待Join线程是否结束，判断依据是看join线程是否存活，而CountDownLatch不必等到join线程结束，只要有线程完成了跟主线程相关的逻辑，就可以调用countdown方法，计数器就会减一；而Join还需要等后续代码执行完毕，所以说CountDownLatch更加灵活，能够使主线程的等待时间更短。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><blockquote>
<p>创建CyclicBarrier实例时，传入一个屏障数量参数，每个线程调用await方法后，告诉CyclicBarrier我已经到达，然后进入阻塞；</p>
<p>当到达的线程达到设定的屏障数量时，所有到达的线程都被唤醒。</p>
<p>之后CyclicBarrier重置计数，等待新的线程到达。</p>
</blockquote>
<p>CyclicBarrier还有一个更加高级的构造方法，传入参数时可以传入一个Runnable实现类，表示线程到达数量到设定值时，优先执行传入的Runnable实现类中的行为动作。</p>
<h2 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h2><ol>
<li><p>CountDownLatch计数器只能用一次，CyclicBarrier计数可以循环使用。</p>
</li>
<li><p>CountDownLatch是等待多个线程完成，阻塞的是等待线程，有一个逻辑上的先后关系；</p>
<p>CyclicBarrier是控制一组线程全都完成才放行，阻塞的是这组里先到达的线程，这组里的线程是一个并列的关系，谁先执行要看cpu分配。</p>
</li>
</ol>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>​		Semaphore可用作并发线程数控制，即流量控制。</p>
<blockquote>
<p>Semaphore semaphore &#x3D; new Semaphore(5);  &#x2F;&#x2F;传入最大并发线程数</p>
<p>线程中调用semaphore.acquire(), 获得许可证</p>
<p>线程结束时调用semaphore.release()，释放许可证</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the permit!&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; released the permit!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java的13个原子操作类"><a href="#Java的13个原子操作类" class="headerlink" title="Java的13个原子操作类"></a>Java的13个原子操作类</h1><p>从JDK1.5开始，提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了简单、高效、线程安全地更新变量的方式。</p>
<p>包括 原子更新基本类型类，原子更新数组，原子更新引用类型，原子字段类型（每个里又有Integer,Long,Boolean类型）共13种。</p>
<p>原子类通过Unsafe类来实现，底层使用<strong>CAS</strong>操作，能够直接操作内存中的值。</p>
<h2 id="synchronized，ReentrantLock，CAS的区别"><a href="#synchronized，ReentrantLock，CAS的区别" class="headerlink" title="synchronized，ReentrantLock，CAS的区别"></a>synchronized，ReentrantLock，CAS的区别</h2><p>synchronized是一种悲观锁，它是独占的，当一个线程获得到锁时，其他请求线程会进入阻塞态,就会涉及到上下文切换，浪费cpu资源；</p>
<p>ReentrantLock也是一种悲观锁，不过跟synchronized不同的是，它有一个tryLock方法，能尝试非阻塞的获取锁，返回一个布尔值，我们可以在代码逻辑上实现一个非阻塞获取锁。</p>
<p>CAS是系统原语，是一种乐观锁。它采用自旋的方式，循环比较判断，会一直占用cpu，因此不会发生上下文切换。</p>
<p>在系统任务并发量较小时，采用CAS开销更小；如果并发量较大，CAS会长时间循环，CPU资源反而消耗更大。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><blockquote>
<p>池化技术：事先准备好资源，并能重复利用，<strong>降低创建和销毁的资源消耗</strong>，提高响应速度，还能够对资源进行统一管理分配，<strong>提高可管理性</strong>。</p>
</blockquote>
<h2 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h2><blockquote>
<p>主线程执行ThreadPoolExecutor的execute后，线程池的处理流程是怎样的？</p>
</blockquote>
<ol>
<li>如果当前运行线程数小于corePoolSize**,创建**新线程来执行；（目的是先把核心线程池允许的最大线程都创建出来，但是如果线程池调用了presstartAllCoreThreads()方法，线程池会提前创建好核心线程池中的所有线程，并启动）</li>
<li>当运行的线程大于等于corePoolSize，则将任务(Runnable实现类)加入到阻塞队列BlockingQueue;</li>
<li>如果BlockingQueue队列已经满了，并且当前线程数小于maximumPoolSize，则<strong>创建</strong>新的<strong>非核心线程</strong>来处理<strong>当前</strong>进来的任务【这里不是优先处理队列中的，而是后进来的】</li>
<li>如果BlockingQueue队列已经满了，并且当前线程数大于等于maximumPoolSize，那么就交给饱和策略来处理。</li>
</ol>
<blockquote>
<p> 其中步骤1和步骤3，由于需要创建新线程，所以需要获得全局锁；</p>
<p>在线程池完成预热（执行线程数大于等于corePoolSize）后，几乎所有execute方法调用都是执行步骤2，无需获取全局锁。</p>
</blockquote>
<blockquote>
<p>线程池的线程执行任务分为两种情况：</p>
<ol>
<li>上述步骤1 和 步骤3，由于直接新建了线程，则立刻由新建的线程执行该任务；</li>
<li>线程池中的线程执行完原有任务后，会返回从BlockingQueue中获取任务来执行.</li>
</ol>
</blockquote>
<blockquote>
<p>核心线程一旦创建，会一直存活，执行完一个任务后，会反复从BlockingQueue中获取任务来执行。</p>
<p>非核心线程，也就是核心线程池外的线程，如果阻塞队列空了，它就会空闲(idle)，超过keepAliveTime时，就会被终结。</p>
</blockquote>
<h2 id="线程池7大核心参数"><a href="#线程池7大核心参数" class="headerlink" title="线程池7大核心参数"></a>线程池7大核心参数</h2><p>ThreadPoolExecutor的构造方法(前5个参数是必须的)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>int corePoolSize ：核心线程数</li>
<li>int maximumPoolSize ：线程池最大线程数</li>
<li>long keepAliveTime ：非核心线程的空闲存活时间</li>
<li>TimeUnit unit ：keepAliveTime 的单位</li>
<li>BlockingQueue<Runnable> workQueue : 阻塞队列</li>
<li>ThreadFactory threadFactory：制造线程的工厂</li>
<li>RejectedExecutionHandler handler ：决绝策略（饱和策略）</li>
</ol>
<h3 id="4个拒绝策略"><a href="#4个拒绝策略" class="headerlink" title="4个拒绝策略"></a>4个拒绝策略</h3><p>当有新任务传进线程池，如果阻塞队列已满，并且当前运行线程数大于等于maximumPoolSize，就会执行拒绝策略。</p>
<img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230422165554721.png" alt="image-20230422165554721" style="zoom:50%;" />

<p>AbortPolicy</p>
<p>直接拒绝，并抛异常</p>
<p>CallerRunsPolicy</p>
<p>哪个线程调用该线程池的execute方法，哪个线程就去执行这个任务</p>
<p>DiscardPolicy</p>
<p>直接拒绝，不抛异常</p>
<p>DiscardOldestPolicy</p>
<p>丢弃队列中最久没被执行的任务【poll队首】，然后再重新调用execute方法执行该任务【再执行execute方法也不见得直接就有位置加到BlockingQueue的队尾了，有可能这个时候有其他任务又给填满了，那么就需要再次poll队首任务，再execute这个任务，直到给它加入到阻塞队列当中去】</p>
<h3 id="如何配置线程池参数"><a href="#如何配置线程池参数" class="headerlink" title="如何配置线程池参数"></a>如何配置线程池参数</h3><p>根据任务性质的不同，可以用不同规模的线程池分开处理。</p>
<p>对于CPU密集型任务，尽可能配置小的线程数，如配置最大线程数为N<em>cpu</em> + 1;</p>
<p>对于IO密集型任务，由于每个任务的CPU耗时不是很长，则应配置尽可能多的线程，如2<em>N</em>cpu*。</p>
<p><em>N</em>cpu是指设备的逻辑处理个数，在代码中配置，可通过以下代码获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()  <span class="comment">//获取当前设备的逻辑处理器个数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>CPU密集型与IO密集型？  说的是什么是系统性能的<strong>瓶颈</strong></p>
<p>CPU密集型：计算任务比较繁重的任务，如图像处理，数据加解密这些；每个任务占用CPU时间较长，当CPU全部被占用了之后，再分配线程也无济于事，因此线程数配置少一点。</p>
<p>IO密集型：数据传输、数据存储之类的工作较多，因此瓶颈在系统的IO设备【网卡，磁盘】上。由于时间花费在IO上比较多，而系统处理IO时，线程是阻塞的不占据CPU的，因此可以配置多一点的线程数。</p>
</blockquote>
<h2 id="Executors工厂类"><a href="#Executors工厂类" class="headerlink" title="Executors工厂类"></a>Executors工厂类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>Executors框架下提供的线程池类：</p>
<p>FixedThreadPool</p>
<p>可设置固定核心线程数，阻塞队列LinkedBlockingQueue容量为Integer.MAX_VALUE;</p>
<p>SingleThreadPool</p>
<p>核心线程数为1，阻塞队列为LinkedBlockingQueue，阻塞队列容量为Integer.MAX_VALUE;</p>
<p>CachedThreadPool</p>
<p>核心线程数为0，最大线程数为Integer.MAX_VALUE，阻塞队列为SynchronousQueue，同步队列的容量为0，只转发任务。（来多少都转发，来一个创建一个线程，可能导致OOM）</p>
<p>ScheduledThreadPool</p>
<p>上边的是核心三大类，而ScheduledThreadPool额外实现了ScheduledExectorService,能够对任务进行延迟执行，或定期执行。核心线程数可设置，但是最大线程数为Integer.MAX_VALUE，阻塞队列采用DelayedWorkQueue</p>
<h3 id="线程池不允许使用Executors创建？"><a href="#线程池不允许使用Executors创建？" class="headerlink" title="线程池不允许使用Executors创建？"></a>线程池不允许使用Executors创建？</h3><p>以下是阿里巴巴Java开发手册写的</p>
<img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230421212603178.png" alt="image-20230421212603178" style="zoom:45%;" />

<h1 id="Fork-x2F-Join框架"><a href="#Fork-x2F-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h1><p>Fork&#x2F;Join是一个<strong>并行</strong>执行任务的框架，把一个大任务分割成若干小任务，最终汇总每个小任务结果，得到大任务结果。</p>
<h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>将大任务拆分成若干互不依赖的子任务，将这些子任务放到不同的队列，然后每个队列创建一个单独线程去执行；</p>
<p>但是有的线程执行结束了，有的线程还没结束，这时干完的线程能够去没干完的线程的队列中去窃取任务去做，因此任务队列采用双端队列，这样就可以从队列另一头去拿任务执行。</p>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>java内存模型是抽象出来的，方便对线程间通信进行规定，控制 的模型。</p>
<p>JMM规定：线程之间的共享变量存储在主内存，每个线程又有一个本地内存，存储主内存中的共享变量的副本用于读写。</p>
<p>JMM的主内存对应着实际内存中实例对象，静态变量这些共享资源的内存区域，而本地内存则主要是指执行该线程的CPU的高速缓存Cache.</p>
<p>必须要保证的两点:</p>
<ol>
<li>一个线程对它本地内存的某个变量副本进行写操作时，必须刷新到主内存；</li>
<li>这个刷新操作对其他线程是可见的。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote>
<ol>
<li>可见性：保证多处理器开发中，共享变量的可见性。可见性是指当一个线程修改一个共享变量的时候，其他线程能够读到这个修改的值。</li>
<li>有序性：禁止指令重排</li>
<li>不能保证原子性</li>
</ol>
</blockquote>
<p>synchronized三个都能保证。volatile只能修饰变量</p>
<h3 id="volatile如何保证可见性"><a href="#volatile如何保证可见性" class="headerlink" title="volatile如何保证可见性"></a>volatile如何保证可见性</h3><p>某个线程对带有volatile修饰的共享变量进行写操作时，JVM会向执行该线程的处理器发送一个LOCK信号，这个LOCK信号会触发处理器将缓存写回到内存中去，并且通过锁总线或者“缓存锁定”，确保不会同时有两个缓存同时刷新到内存区域。</p>
<p>而每个处理器通过嗅探，能够知道这一操作，那么其他处理器对于这个共享变量的缓存失效，需要重新到内存中读取数据填充缓冲行。</p>
<h3 id="volatile为什么不能保证原子性"><a href="#volatile为什么不能保证原子性" class="headerlink" title="volatile为什么不能保证原子性"></a>volatile为什么不能保证原子性</h3><p>synchronized保证有一个线程读改写某个共享资源时，就对这个对象上锁了，然后通过锁总线或者“缓存锁定”的方式，阻止其他线程对这个资源缓存的操作。</p>
<p>而volatile只能让其他线程的缓存失效，保持缓存中的一致性，但它并不能阻止其他线程读的操作，如果其他线程的CPU已经将这个缓存数据读到了寄存器里，进行运算了，这个时候即使有线程完成了写操作，让别人的缓存失效也没有用了，人家已经执行了后续步骤了，已经计算得到中间值了，那么最开始的数据被清空了也不会影响继续运行，因此不能保证原子性。</p>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>源代码到实际执行，编译器和处理器会分别对代码进行重排序优化。这些重排序在单线程下运行是没有问题的，但是多线程运行可能会产生问题。</p>
<p>Java编译器在编译的时候，会插入内存屏障指令，来禁止特定类型的处理重排序。</p>
<blockquote>
<p>synchronized能保证有序性，是保证不同线程加锁执行结果的有序性，简单说即串行。但不能禁止指令重排</p>
<p>volatile通过插入内存屏障指令，禁止指令重排，来保证有序性</p>
</blockquote>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>用处：ThreadLocal是解决多线程并发问题的一种思路，我们可以将共享数据放在ThreadLocal中，当有多个线程来访问数据时，就会创建一个变量副本，保存在自己的线程中，每个线程对各自的变量副本进行操作，避免了并发问题。</p>
<p>实现原理：每个线程内部都有一个ThreadLocalMap，ThreadLocalMap内部有一个Entry数组，每个Entry的key是对公共的ThreadLocal的弱引用，value是ThreadLocal中存放的共享数据；因为是弱引用关系，所以在下一次GC时，弱引用关系就会消失，key就变成了Null，无法通过key找到value，而value是强引用的，所以只要线程不终止，就不会被回收；那么此时value既不会被回收，又无法被访问，也就是内存泄漏。</p>
<p>【每个线程内部ThreadLocalMap是有公共的ThreadLocal去维护的，由ThreadLocal去设置值，删除值。】</p>
<p>线程每次调用set(),get()方法，就会给key为null的Entry的value设置为null，这样下次GC的时候value的内存空间就会被回收；但是很有可能线程执行过程中都不调用set,get()方法，因此每次用完还是都要记得调用remove()方法。</p>
<img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230512163458182.png" alt="image-20230512163458182" style="zoom: 33%;" />

<img src="C:\Users\19946\AppData\Roaming\Typora\typora-user-images\image-20230530202046016.png" alt="image-20230530202046016" style="zoom:35%;" />

<blockquote>
<p>ThreadLocalMap 的key设置成弱引用，是为了防止new ThreadLocal对象的那个强引用消失后，还有其他线程的ThreadLocalMap存在对ThreadLocal的强引用，导致ThreadLocal对象无法被回收。【考虑的是ThreadLocal的回收问题】</p>
</blockquote>
<p>但是通常我们把ThreadLocal定义成静态变量的方式，他一直被class对象强引用，不会被GC</p>
<p>应用场景：用ThreadLocal保存格式化日期格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; local = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy:MM:ddHHmm&quot;</span>));</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/7%E5%85%AB%E8%82%A1_Spring%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Spring概念"><a href="#Spring概念" class="headerlink" title="Spring概念"></a>Spring概念</h1><p>Spring是一个轻量级Java开发框架，里面包含了许多模块，能够简化Java开发工作</p>
<p>主要模块：</p>
<p>Core Container: spring-core, spring-beans, spring-context, spring-expression</p>
<p>AOP</p>
<p>Data Access&#x2F;Integration</p>
<p> Spring Web: spring-web, spring-webmvc, spring-websocket</p>
<p>Test</p>
<h2 id="Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间什么关系?"></a>Spring,Spring MVC,Spring Boot 之间什么关系?</h2><p>Spring框架有很多个模块，其中最核心的就是core模块提供的IoC功能，其他模块比如Spring MVC都要依赖于这个模块；</p>
<p>Spring MVC模块主要实现了快速构建Web程序的能力，核心思想就是Model层，View层，Controller层分离，来组织代码。</p>
<p>Spring开发时，许多配置要通过XML文件或者Java语句进行显式的配置，为了简化配置，SpringBoot 框架应运而生。</p>
<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，将原来程序中创建对象的控制权交给Spring框架去操管理。</p>
<p>好处是：我们创建一个对象的时候，可能依赖于很多其他对象，代码就会很繁琐。将对象的依赖关系交给Spring IoC容器去管理，并由IoC容器完成对象的注入。只需提前配置好，用的时候直接调用就可以了，能够大大简化开发。</p>
<h2 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h2><p>Spring Bean就是由IoC容器进行管理的对象。可以通过XML文件，注解，java配置类等方式，告诉IoC容器要管理哪些对象。</p>
<h2 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些?"></a>将一个类声明为 Bean 的注解有哪些?</h2><ul>
<li>@Component  通用注解，下边的注解都会间接引用该注解，如果不知道该类是哪个层，就用这个</li>
<li>@Repository 对应持久层</li>
<li>@Service 业务逻辑层</li>
<li>@Controller 控制层</li>
</ul>
<h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ul>
<li>@Component 注解作用于类，而@Bean注解作用于方法。</li>
<li>@Bean通常和@Component注解一起使用，@Component作用在类上，表示这个类作为配置类使用，相当于一个XML文件，而类中方法的@Bean注解，相当于配置信息，将方法的返回对象加入到IoC容器中。</li>
</ul>
<blockquote>
<p>@Configuration注解注入的是将某类的代理类加入到IoC容器中，通常和@Bean一起使用，来作为配置类使用，代理xml的配置方式。</p>
</blockquote>
<h2 id="注入-Bean-的注解有哪些？"><a href="#注入-Bean-的注解有哪些？" class="headerlink" title="注入 Bean 的注解有哪些？"></a>注入 Bean 的注解有哪些？</h2><ul>
<li>@Autowired 默认通过类型注入</li>
<li>@Resource 默认通过名字注入</li>
</ul>
<h2 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h2><ul>
<li>singleton ：Spring bean默认是单例的，单例模式的应用。</li>
<li>prototype : 每次获取bean都会创建一个新的bean</li>
<li>request ：每次HTTP请求，创建一个新的bean，（请求bean）</li>
<li>session：每次有一个新的session传来HTTP请求，创建一个新的bean，（会话bean）</li>
<li>application&#x2F;global-session：每个 Web 应用在启动时创建一个 Bean（应用 Bean）</li>
<li>websocket <strong>：</strong>每一次 WebSocket 会话产生一个新的 bean</li>
</ul>
<h2 id="单例-Bean-的线程安全问题了解吗？"><a href="#单例-Bean-的线程安全问题了解吗？" class="headerlink" title="单例 Bean 的线程安全问题了解吗？"></a>单例 Bean 的线程安全问题了解吗？</h2><p>大多数bean都是无状态的（没有成员变量），都是用他的方法，比如dao,service，就线程安全的；</p>
<p>如果用到涉及成员变量的bean,可以通过以下方式解决线程安全问题：</p>
<ol>
<li>在bean中尽量避免定义可变的成员变量；</li>
<li>如果必须需要可变的成员变量，就定义一个ThreadLocal成员变量，保存在ThreadLocal中。</li>
</ol>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><blockquote>
<p>实例化 —&gt; 设置属性 —&gt; 自定义初始化方法 —&gt; bean的使用 —&gt; 自定义销毁方法</p>
</blockquote>
<blockquote>
<p>实例化：通过反射，默认调用无参构造函数，实例化对象</p>
<p>设置属性：通过反射，调用set方法设置属性参数</p>
<p>自定义初始化方法init</p>
<p>自定义的销毁方法destory</p>
</blockquote>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP(Aspect Oriented Programming)是一种面向切面的编程思想，将影响多个类的行为，集成到一个模块中去，减少代码的重复度，降低模块间的耦合。</p>
<p>Spring AOP 就是基于动态代理的，有两种动态代理模式JDK动态代理和Cglib动态代理；如果被代理的对象实现了某个接口，则采用JDK动态代理，采用接口方式实现代理；如果被代理的对象没有接口，则采用Cglib动态代理，生成一个被代理类的子类，来作为代理。</p>
<h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。</p>
<h2 id="AspectJ-定义的通知类型有哪些？"><a href="#AspectJ-定义的通知类型有哪些？" class="headerlink" title="AspectJ 定义的通知类型有哪些？"></a>AspectJ 定义的通知类型有哪些？</h2><ul>
<li>Before 前置通知</li>
<li>After 后置通知</li>
<li>AfterReturning 返回通知</li>
<li>AfterThrowing 抛异常通知</li>
<li>Around 环绕通知</li>
</ul>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="SpringMCV工作原理"><a href="#SpringMCV工作原理" class="headerlink" title="SpringMCV工作原理"></a>SpringMCV工作原理</h2><p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png" alt="img"></p>
<p>1.客户端的请求先到DispatcherServlet，DispatcherServlet是Servlet接口的一个实现类；</p>
<p>2.通过HandlerMapping，根据uri路径信息寻找Handler(Controller)，找到Handler之后生成适配器HandlerAdapter，DispatcherServlet就能通过适配器执行Handler的方法了；</p>
<p>3.Handler执行完毕，将响应结果返回给DispatcherServlet，web容器再把他封装成response返回给客户端。</p>
<h1 id="Spring框架用了哪些设计模式"><a href="#Spring框架用了哪些设计模式" class="headerlink" title="Spring框架用了哪些设计模式"></a>Spring框架用了哪些设计模式</h1><p>工厂设计模式：Spring bean对象是通过BeanFactory创建的(BeanFactory是接口，具体实现类是各种Application Context)</p>
<p>代理模式：AOP的实现</p>
<p>单例模式：Spring bean默认是单例模式</p>
<p>适配器模式：spring MVC中DispatcherServlet通过适配器，适配各种Controller</p>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><p>Spring可以通过显示编程 或 注解方式开启事务</p>
<ol>
<li>通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务</li>
<li>通过@Transactional注解（通过AOP实现）,可作用于类或方法，作用于类时类中所有public方法都开启事务。</li>
</ol>
<h2 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h2><p>默认与数据库的隔离级别一致。一共有四种：RU,RC,RR,Serival</p>
<h2 id="Transactional-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</h2><p>@Transactional注解的rollbackFor如果不配置，默认发生RuntimeException才发生回滚，配置成Exception.class，发生所有异常都会回滚。</p>
<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1>]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/5%E5%85%AB%E8%82%A1_MySQL/</url>
    <content><![CDATA[<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p>1.连接器</p>
<p>管理客户端连接，验证登陆权限</p>
<p>2.缓存查询</p>
<p>对用户的查询内容进行缓存，缓存命中则不必走存储引擎。但是再MySQL8.0之后移除了这一功能，因为：</p>
<ul>
<li>命中率不高，要求SQL语句要完全相同;</li>
<li>表结构有任何变化，则缓存全部失效。</li>
<li>因此额外开销较大，弊大于利</li>
</ul>
<p>3.分析器</p>
<ul>
<li>分析SQL语法，解析SQL语义，知道这个SQL要干嘛</li>
</ul>
<p>4.优化器</p>
<ul>
<li>选择索引，表连接顺序，生成执行计划</li>
</ul>
<p>5.执行器</p>
<ul>
<li>调用存储引擎接口，返回结果</li>
</ul>
<p>6.存储引擎</p>
<ul>
<li>插件式存储引擎，负责数据的读写。</li>
</ul>
<h2 id="一个SQL语句，有几次权限验证？"><a href="#一个SQL语句，有几次权限验证？" class="headerlink" title="一个SQL语句，有几次权限验证？"></a>一个SQL语句，有几次权限验证？</h2><p>3次。</p>
<p>第一次：连接器阶段，验证用户对于数据库的权限；</p>
<p>第二次：分析器解析完SQL语义的时候，有一个precheck, 判断对表有没有这个操作权限；</p>
<p>第三次：执行器阶段，还会有对表的权限的判断。因为执行时可能会涉及到其他表，比如设置了触发器操作。</p>
<h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p>InnoDB和MyISAM的区别</p>
<p>5.5.5版本之后，InnoDB取代MyISAM成为MySQL的默认存储引擎。</p>
<ol>
<li>事务</li>
<li>崩溃恢复</li>
<li>行锁</li>
<li>MVCC</li>
<li>数据文件和索引文件的存储结构</li>
</ol>
<p>​					InnoDB的数据文件存在主键索引树的叶子节点，而MyISAM的数据文件和索引是分开的。</p>
<ol start="6">
<li>外键</li>
</ol>
<p>​					InnoDB是支持外键的，但是外键在阿里巴巴java开发手册里规定，项目生产里，外键禁止使用，要在业务代码里进行约束，外键会对性能带来损耗。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<h2 id="事务的四个性质ACID"><a href="#事务的四个性质ACID" class="headerlink" title="事务的四个性质ACID"></a>事务的四个性质ACID</h2><p>Atomic 原子性</p>
<p>Consistent 一致性</p>
<p>Isolation 隔离性</p>
<p>Durable 持久性</p>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>​		事务隔离的4个级别？</p>
<ol>
<li>读未提交 <strong>READ-UNCOMMITTED</strong> RU ：允许读到未提交的数据</li>
<li>读已提交 <strong>READ-COMMITTED</strong> RC ：事务能读到其他事务已经提交的事务</li>
<li>可重复读 **REPEATABLE-READ **RR ：一个事务内多次读取数据，都和事务的一致性视图一致。</li>
<li>串行化 <strong>SERIALIZABLE</strong> ：事务按照顺序执行，不支持并发事务</li>
</ol>
<p>默认的事务隔离级别是 ：可重复读  REPEATABLE-READ</p>
<h2 id="MySQL事务隔离级别都是基于锁实现的吗？"><a href="#MySQL事务隔离级别都是基于锁实现的吗？" class="headerlink" title="MySQL事务隔离级别都是基于锁实现的吗？"></a>MySQL事务隔离级别都是基于锁实现的吗？</h2><p>串行化隔离级别是通过锁实现的，而可重复读和读已提交级别下，MVCC和锁都有用到，如果是快照读，用的是MVCC，但是两者生成一致性视图的时刻是不同的，如果 是当前读，比如写操作(update insert delete)，或者加锁读（For update &#x2F; lock in share mode）那么是依赖读写锁的。</p>
<h2 id="并发事务带来的问题？"><a href="#并发事务带来的问题？" class="headerlink" title="并发事务带来的问题？"></a>并发事务带来的问题？</h2><ol>
<li><p>脏读：指事务读到了其他事务尚未读到的数据，RU会有脏读现象</p>
</li>
<li><p>不可重复读：不可重复度是指事务中前后两次对同一数据读到的值可能不一致，RU,RC都会有这个现象，可重复读隔离级别解决了这个事情</p>
</li>
<li><p>幻读：指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
</li>
</ol>
<h3 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h3><p>   首先普通的查询是快照读，由于MVCC一致性视图的存在，是不会出现幻读的；</p>
<p>   但是如果是当前读的话，它会加行锁，所以其他事务的update和delete是会被阻塞的，但是Insert是可以插入新纪录的，新纪录是没有行锁的嘛，所以会产生幻读。</p>
<p>   那么为了解决可重复读隔离级别下的幻读问题，MySQL引入了间隙锁，间隙锁能锁住两行记录间的间隙，防止其他事务插入，间隙锁+行锁合成为next-key lock，来解决幻读的问题。</p>
<h3 id="next-key-lock锁的范围"><a href="#next-key-lock锁的范围" class="headerlink" title="next-key lock锁的范围"></a>next-key lock锁的范围</h3><p>范围： 左开右闭的区间，并且只有查询过程中真正访问到的对象才会加锁。</p>
<p>优化：1.如果是唯一索引上的等值查找，那么加锁时next-key lock会退化为行锁；</p>
<p>​			2.如果是非唯一索引上的等值查找，那么向右遍历访问到索引上第一个不符合条件的值时，会退化为间隙锁。</p>
<h2 id="如何对并发事务进行控制？"><a href="#如何对并发事务进行控制？" class="headerlink" title="如何对并发事务进行控制？"></a>如何对并发事务进行控制？</h2><ol>
<li>通过读写锁</li>
<li>MVCC</li>
</ol>
<h2 id="开启事务的指令"><a href="#开启事务的指令" class="headerlink" title="开启事务的指令"></a>开启事务的指令</h2><p>1.显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</p>
<p>2.<set autocommit=1>参数，每次执行语句会自动开启事务和提交事务。</p>
<h2 id="长事务有什么后果？"><a href="#长事务有什么后果？" class="headerlink" title="长事务有什么后果？"></a>长事务有什么后果？</h2><ol>
<li><p>长时间占用锁资源，会影响性能；</p>
</li>
<li><p>会导致主从延迟</p>
</li>
<li><p>还会导致大量的undo log占用存储空间，因为undo log清理的判断依据是，看如果没有比该事务的更早的一致性视图了，才会被清理，所以说长事务还会影响它后面事务的undo log的清理。</p>
</li>
<li><p>长事务还会影响修改表结构，长事务给表加MDL读锁，之后要有修改表结构的操作，会请求MDL写锁，而MDL队列中写锁优先级高于读锁，所以修改表结构的事务后边的CRUD操作也会被阻塞。</p>
</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>Flush tables with read lock (FTWRL)，使整个库都处于一个只读的状态。</p>
<p>使用场景：做全库逻辑备份。逻辑备份时要保持整个过程数据要保持一致性；当然这只适用于不支持事务的存储引擎，对于InnoDB存储引擎来说，可以通过MVCC拿到一致性视图来进行全库备份，而不需要使用全局锁，造成全库只读。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ol>
<li>表锁：表锁是针对表中数据的，读操作加读锁，写操作加写锁；需要显示命令&lt;lock tables … read&#x2F;write&gt;;在没有出现行锁的时候，表锁是控制并发的方式。</li>
<li>meta data lock (MDL): 元数据锁是针对修改表结构的，在修改表结构的时候，会加MDL写锁，CRUD操作的时候加的是MDL读锁，读锁共享；MDL锁是隐式自动加的。</li>
</ol>
<h2 id="如何安全的给小表加字段（或者说修改表结构）？"><a href="#如何安全的给小表加字段（或者说修改表结构）？" class="headerlink" title="如何安全的给小表加字段（或者说修改表结构）？"></a>如何安全的给小表加字段（或者说修改表结构）？</h2><p>​		由于meta data lock (MDL)的存在，如果在修改表结构之前，有一个长事务存在，会占据MDL写锁，此时修改表结构的事务申请MDL写锁会被阻塞，并且由于申请MDL锁的队列是写锁优先的，所以再后面的CRUD操作也会被阻塞。</p>
<p>那么如何安全的修改表结构呢？</p>
<ol>
<li><p>首先要先清理掉长事务，会让后面的修改表结构操作长时间拿不到MDL写锁；</p>
</li>
<li><p>其次是可以给修改表结构的指令加上一个超时时间，保证不会阻塞后续语句太久。</p>
</li>
</ol>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>InnoDB引擎才支持行锁。</p>
<p>普通读是加读锁，是共享锁(S 锁)；增删改操作加的是行锁，是排他锁(X 锁)。</p>
<h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p>事务中的锁是在需要的时候才上锁的，但是要等到事务提交或者回滚了之后才会释放。</p>
<p>所以说事务中容易造成锁冲突的语句尽量放在事务最后，这样可以减少事务时间的锁等待，增加并发度。</p>
<blockquote>
<p>为什么要两阶段锁呢？</p>
<p>如果写操作完事之后没等事务提交就立马释放，那么其他事务如果快照读还好，有一致性视图，但是如果执行当前读的操作时，就会<strong>脏读</strong>了。</p>
</blockquote>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>间隙锁是为了解决幻读的，只有在可重复读的隔离级级别下才有。因为如果只有行锁，那么插入新纪录的时候不会被上锁，在一个事务中，对于同一个范围内的两次查询，后一次的查询可能会出现新的结果，也就是幻读现象。</p>
<p>Next-key lock 临键锁</p>
<p>为了解决幻读现象，就有了next-key lock，行锁+间隙锁结合就叫做next-key lock  </p>
<p>范围： 左开右闭的区间，并且只有查询过程中真正访问到的对象才会加锁。</p>
<p>优化：1.如果是唯一索引上的等值查找，那么加锁时next-key lock会退化为行锁；</p>
<p>​			2.如果是非唯一索引上的等值查找，那么向右遍历访问到索引上第一个不符合条件的值时，会退化为间隙锁。</p>
<h1 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h1><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB；</p>
<p>redo log是循环写的，有两个指针 write pos和check point，分别指向当前写的位置和要擦除的位置。只要redo log被记录了，那么mysql崩溃后，就可根据check point回放，来恢复数据</p>
<img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png?wh=1142*639" alt="img" style="zoom: 67%;" />

<h3 id="redo-log-刷盘时机"><a href="#redo-log-刷盘时机" class="headerlink" title="redo log 刷盘时机"></a>redo log 刷盘时机</h3><p>事务执行过程中，redo log只写到redo log buffer中，但是要在事务提交，执行commit指令时，才</p>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次<strong>事务提交时</strong>，redo log只停留在redo log buffer</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次<strong>事务提交时</strong>都将持久化到磁盘（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次<strong>事务提交时</strong>都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<blockquote>
<p>如果设置为1，只要事务提交，redo log一定落盘成功；如果事务执行期间MySQL挂了或者宕机，那么事务没提交，redo log不记录也正常。</p>
<p>如果设置为0，如果MySQL挂了或者宕机，则会损失1秒中内的数据</p>
<p>如果设置为2，每次事务都会write文件系统的page cache中，那么MySQL挂了不会有数据损失，但是如果宕机了，就会损失1秒内数据。</p>
</blockquote>
<h3 id="没提交的redo-log为什么会从redo-log-buffer-刷新到磁盘？"><a href="#没提交的redo-log为什么会从redo-log-buffer-刷新到磁盘？" class="headerlink" title="没提交的redo log为什么会从redo log buffer 刷新到磁盘？"></a>没提交的redo log为什么会从redo log buffer 刷新到磁盘？</h3><ol>
<li>后台线程每隔一秒的轮询操作，会将redo log buffer同步到磁盘</li>
<li>redo log buffer的内存空间达到总空间的一半时，会将redo log buffer中的内容write到page cache中</li>
<li>并发事务时，多个事务共享一个redo log buffer，如果redo log刷盘时机的参数选为1，那么有一个事务提交时，把整个redo log buffer全部提交，能够实现组提交，减少磁盘IO。【binlog也有组提交机制】</li>
</ol>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。redo log是循环写</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。binlog是追加写。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<h3 id="binlog格式"><a href="#binlog格式" class="headerlink" title="binlog格式"></a>binlog格式</h3><ul>
<li><strong>statement</strong></li>
</ul>
<p>statement格式的Binlog记录的是每个事务的SQL语句，缺点是从库用来同步的时候可能造成主从不一致，如：一个写操作，加了limit，但是可能走了不同的索引，导致主从不一致</p>
<ul>
<li><strong>row</strong></li>
</ul>
<p>row格式binlog的记录对应到每一行，因此不会出现主从数据不一致的情况，但是这种格式的Binlog文件占用空间会比较大。</p>
<ul>
<li><strong>mixed</strong></li>
</ul>
<p>综合以上两种格式，先判断一个SQL语句是否会造成主从不一致，不会的话用statement格式，否则用row格式</p>
<h3 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h3><p>在事务执行过程中，binlog写入内存中的 binlog cache，事务提交的时候才会刷新到磁盘</p>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<p>sync_binlog&#x3D;0 的时候，表示每次提交事务都只 write到page cache，不 fsync到磁盘；</p>
<p>sync_binlog&#x3D;1 的时候，表示每次提交事务都会执行 fsync到磁盘；</p>
<p>sync_binlog&#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p>
<img src="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png?wh=1142*748" alt="img" style="zoom: 50%;" />

<h3 id="为什么Binlog不能实现崩溃恢复？"><a href="#为什么Binlog不能实现崩溃恢复？" class="headerlink" title="为什么Binlog不能实现崩溃恢复？"></a>为什么Binlog不能实现崩溃恢复？</h3><p>我认为主要是因为binlog没有check point指针，binlog和redo log都是WAL机制（预先写日志），redo log在回放数据的时候，根据check point指针，来恢复数据，check point能保证它之前的数据是全部已经落盘的数据;而Binlog没有这样的机制，binlog只能判断事务是否执行完成了，但是由于WAL机制，事务完成了，数据可能还没有刷盘，因此也就无法判断哪些需要恢复。</p>
<h2 id="redo-log和binlog的两阶段提交？"><a href="#redo-log和binlog的两阶段提交？" class="headerlink" title="redo log和binlog的两阶段提交？"></a>redo log和binlog的两阶段提交？</h2><p>目的：保证两份日志文件的一致性。因为binlog会用作创建备库或者恢复临时库（库被误删了），操作是拿到最近一次的整库备份，加上对应时间节点的Binlog进行恢复。如果redo log和binlog不一致，那么就会导致备库与原库不一致。</p>
<img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png?wh=1142*1522" alt="img" style="zoom: 33%;" />

<p>一个更新语句的流程：【上图从写redolog开始都是执行事务提交指令COMMIT后的操作】</p>
<ol>
<li>先看数据是否在内存buffer pool中，不在的话先将数据从磁盘读到内存中；</li>
<li>修改内存中的数据</li>
<li>写redo log，写完之后标记redo log为prepare状态</li>
<li>写binlog</li>
<li>提交事务时（commit指令），将redo log标记为commit状态</li>
</ol>
<blockquote>
<p>如果不采用两阶段提交，那么如果在写两份日志之间发生崩溃，会导致两份日志数据不一致</p>
</blockquote>
<p>为什么binlog不能支持崩溃恢复</p>
<h2 id="mysql崩溃后，如何恢复数据？"><a href="#mysql崩溃后，如何恢复数据？" class="headerlink" title="mysql崩溃后，如何恢复数据？"></a>mysql崩溃后，如何恢复数据？</h2><p>崩溃恢复的时候，会按照顺序从check point开始扫描redo log</p>
<p>如果这条事务的redo log标记为commit状态，则认为该事务有效，进行提交。</p>
<p>如果redo log是prepare状态，这是需要判断binlog是否完整，如果完整就提交事务，不完整就回滚事务。</p>
<blockquote>
<p>如何判断binlog是否完整？</p>
<p>答：一个事务的binlog有格式的，如果是statement格式，完整的Binlog最后会有commit标志，如果是row格式，最后会有一个XID event。</p>
</blockquote>
<blockquote>
<p>一个事务的Binlog 和redo log是如何关联在一起的？</p>
<p>答: 二者有一个公共字段 XID</p>
</blockquote>
<h2 id="MySQL如何保证数据不丢失？"><a href="#MySQL如何保证数据不丢失？" class="headerlink" title="MySQL如何保证数据不丢失？"></a>MySQL如何保证数据不丢失？</h2><blockquote>
<p>mysql通过write-ahead logging WAL 预先写日志机制，内从中数据修改不用马上去刷新磁盘，用redo log和binlog保证数据不丢失，提高mysql的并行能力。</p>
<p>WAL机制主要得益于两个方面：</p>
<ol>
<li>binlog和redo log顺序写，比数据写磁盘时的随机写要快得多；</li>
<li>组提交机制，可以减少了IO次数，提高了IO性能。</li>
</ol>
</blockquote>
<h2 id="MySQL如何保证原子性？"><a href="#MySQL如何保证原子性？" class="headerlink" title="MySQL如何保证原子性？"></a>MySQL如何保证原子性？</h2><p>通过回滚日志，mysql在开启事务之后，每一个sql语句的逆逻辑都会记录在回滚日志中，当事务没执行完，中途出现异常，或者主动通过rollback指令，就会根据回滚日志将数据恢复到事务开启之前的状态。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>回滚日志记录的是我们事务执行的倒序逻辑，1. 用来事务的回滚； 2. MVCC的实现。</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h2 id="一致性视图"><a href="#一致性视图" class="headerlink" title="一致性视图"></a>一致性视图</h2><p>一致性视图相当于给整库拍了一个快照，保存当前的状态，在RC下每执行一个语句会创建一个一致性视图，RR隔离级别下，在事务启动时开启一致性视图，整个事务使用同一个一致性视图。</p>
<p>读提交RC和可重复读RR的一致性视图的区别？</p>
<p>RC隔离级别下的每执行一个语句就会创建一个一致性视图，而RR隔离级别下，是在开启事务的时候创建的，直到事务提交之前一直使用这一个一致性视图。</p>
<h2 id="如何实现可重复读"><a href="#如何实现可重复读" class="headerlink" title="如何实现可重复读"></a>如何实现可重复读</h2><ol>
<li><p>InnoDB存储引擎的为每行数据提供了隐藏字段，其中的事务Id字段记录了更新该行数据的事务Id，用于表示这行数据的版本；</p>
</li>
<li><p>每个事务在开启一致性视图时会创建一个视图数组，用于记录启动事务瞬间正在活跃的所有事务的id；</p>
</li>
<li><p>事务在查询数据时，通过undo log从数据当前值开始向前查找，比对数据的版本号，也就是更新这条记录的事务Id，</p>
<p>a. 如果id比视图数组的低水位小，表示是在开启一致性视图之前创建的，那么这条事务可见；</p>
<p>b. 如果Id比视图数组的高水位大，表示是后创建的视图修改的数据，那么这条事务不可见，继续根据undo log向前查找;</p>
<p>c. 如果id落在视图数组的高水位和低水位之间，如果视图数组中存在该事务Id，那么就是未提交的事务修改的，不可见，如果不存在，就是已提交事务的修改的，是可见的；</p>
</li>
<li><p>就这样根据undo log回滚视图不断查找，直到找到第一个可见数据。</p>
</li>
</ol>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h2><ol>
<li><p>哈希索引</p>
<p> 时间复杂度接近O(1)，结构简单，缺点是只适合等值查找，不支持范围查找，范围查找要走全表扫描。</p>
</li>
<li><p>有序数组<br> 可以二分查找，时间复杂度log(n)，但是插入新数据时，后边的都需要向后移动，成本较高。</p>
</li>
<li><p>二叉搜索树<br> 查找的时间复杂度为log(n)，但是二叉树每层的节点数太少了，树高会很高，每次查找读磁盘次数都会很多，又会减少查询速度 。</p>
</li>
<li><p>N叉树</p>
<p> N叉树的出现就是来解决访问页面过多的问题，以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。</p>
</li>
</ol>
<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><p>采用B+树，是一种平衡 多叉 搜索 树<br>非叶子节点只存放key，而叶子节点存放key和数据，叶子节点通过双向指针形成链表。</p>
<p>B树与B+树有哪些区别？<br>    B树所有节点都能存放key和数据，每个节点之间是独立的，查找时可能走不到叶子节点就结束了;<br>    而B+树的数据只存在在叶子节点，并且通过链表连接，每次查找都要走到叶子节点;</p>
<p>B+树的优点：</p>
<ol>
<li>由于B树每个节点都存储key和数据，导致每个页面内存储的索引更少，整个索引树的树高会更高，查找时需要更多次读磁盘；</li>
<li>范围查询时，B+树查找到两个端点就可以了，然后通过链表的指针进行遍历即可；而B树要遍历更多节点；</li>
</ol>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>聚簇索引：索引结构和数据存放在一起的索引，InnoDB的主键索引就是聚簇索引</p>
<p>非聚簇索引：索引结构和数据是分开存放的，InnoDB的二级索引就是非聚簇索引，叶子节点存储的是主键值。而MyISAM都是非聚簇索引。</p>
<h2 id="单列索引和联合索引"><a href="#单列索引和联合索引" class="headerlink" title="单列索引和联合索引"></a>单列索引和联合索引</h2><p>单列索引：单个字段做索引；  联合索引：多个字段做索引</p>
<h2 id="主键索引与二级索引"><a href="#主键索引与二级索引" class="headerlink" title="主键索引与二级索引"></a>主键索引与二级索引</h2><p>主键索引：一张表只能有一个主键索引，索引字段要满足不能重复，不为null；主键索引叶子节点存储的是数据。</p>
<p>如果没有显示指定主键字段，则InnoDB自动检查看有没有一个字段能满足主键索引的条件，没有的话会创建一个不可见的6Byte的自增主键。</p>
<p>二级索引：一张表可以有多个二级索引，二级索引叶子节点存储的是主键值。通过二级索引查找到主键值之后，需要根据主键值回表，到主键索引查找到对应数据。</p>
<h2 id="索引的三大特性"><a href="#索引的三大特性" class="headerlink" title="索引的三大特性"></a>索引的三大特性</h2><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>当通过非聚簇索引树查询时，在非聚簇索引树上就有想查询的数据时，就没必要回表了，比如：</p>
<ol>
<li>通过某个普通索引，想查询主键ID字段；</li>
<li>或者联合索引，联合索引有最左匹配原则，当想通过索引中左边的字段查询右侧字段的数据时，也不需要回表。</li>
</ol>
<h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><p>在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配。匹配完成或者遇到范围查询（如&gt; &lt; between）无法继续匹配时，匹配结束。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>如果是联合索引，遇到无法继续匹配的情况了，比如范围查找，那么其他查询条件如果在索引中能找到，会先做判断，不满足的就不用回表了，减少回表次数。</p>
<h2 id="怎么给字符串字段加索引？"><a href="#怎么给字符串字段加索引？" class="headerlink" title="怎么给字符串字段加索引？"></a>怎么给字符串字段加索引？</h2><p>场景1：邮箱登录；</p>
<p>给邮箱字段加索引。 <a href="mailto:&#122;&#104;&#x61;&#110;&#x67;&#x73;&#115;&#x78;&#121;&#122;&#x40;&#120;&#120;&#x78;&#x2e;&#99;&#x6f;&#x6d;">&#122;&#104;&#x61;&#110;&#x67;&#x73;&#115;&#x78;&#121;&#122;&#x40;&#120;&#120;&#x78;&#x2e;&#99;&#x6f;&#x6d;</a>；问题：字段太长，占据空间太大</p>
<p><strong>前缀索引</strong>，取前几个字符做索引，最左匹配原则。使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</p>
<p>前缀索引的问题是会增加一些扫描行数，牺牲了一些匹配精确度。并且前缀索引依赖于区分度。</p>
<p>场景2：身份证号</p>
<p>身份证号的前缀区分度不高；因此可采用</p>
<p><strong>倒序存储</strong> ， 之后再取前6位做前缀索引，每次需要调用reverse函数</p>
<p><strong>添加hash字段</strong>：为表添加一个hash字段，作为索引。每次插入通过哈希函数计算出身份证号的hash值；hash索引的匹配精度高，会增加一个额外字段空间，一般四个字节就够了；可能会哈希冲突，还要和id联合判断是否完全相同，但是冲突几率比较低；</p>
<p>总体来说hash字段索引查询效率要更高一些。地址空间hash字段可能更多，但是如果前缀区分度低，要更长长度，也会增加额外地址空间。</p>
<h2 id="什么时候不走索引（导致索引失效的原因）？"><a href="#什么时候不走索引（导致索引失效的原因）？" class="headerlink" title="什么时候不走索引（导致索引失效的原因）？"></a>什么时候不走索引（导致索引失效的原因）？</h2><ol>
<li>对索引字段进行了函数计算</li>
</ol>
<blockquote>
<p> select * from t where year(date) &#x3D; 2020 索引上有函数运算</p>
<p>select * from t where id+1&#x3D;1000  写成where id &#x3D; 1000 - 1 就行了</p>
</blockquote>
<ol start="2">
<li>隐式类型转换</li>
</ol>
<blockquote>
<p>首先明确，mysql 中 select “10” &gt; 9 ，字符串和数字做比较的话，是将字符串转换成数字。</p>
<p>select * from tradelog where tradeid&#x3D;110717 相当于  select * from tradelog where  CAST(tradid AS signed int) &#x3D; 110717</p>
<p>所以相当于对索引字段进行了隐式的函数计算，会导致不走索引</p>
</blockquote>
<ol start="3">
<li>隐式字符编码转换</li>
</ol>
<blockquote>
<p>如果两个关联表的字符集不同，也可能不走索引；比如表1字符集是utf8mb3，表2字符集是utf8mb4，由于uft8mb4是超集，范围更大，会将utf8mb3字符的字段转换为utf8mb4的字符进行关联比较。</p>
</blockquote>
<h1 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h1><h2 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h2><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h2 id="分库库表"><a href="#分库库表" class="headerlink" title="分库库表"></a>分库库表</h2><h2 id="高可用性和高可靠性"><a href="#高可用性和高可靠性" class="headerlink" title="高可用性和高可靠性"></a>高可用性和高可靠性</h2><h1 id="零散问题"><a href="#零散问题" class="headerlink" title="零散问题"></a>零散问题</h1><h2 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h2><p>对于二级索引树的数据页通常是无序的，每次读取要进行随机磁盘IO，那么为了避免读磁盘，就将对二级索引树的写操作缓存在change buffer中，等下次要访问这个数据页的时候，再将change buffer中的操作执行。</p>
<blockquote>
<p>对于唯一索引，由于每次要进行唯一性检查，所以每次都要读进内存，所以不走change buffer</p>
</blockquote>
<h2 id="刷脏页"><a href="#刷脏页" class="headerlink" title="刷脏页"></a>刷脏页</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>mysql为每个线程分配一个用于排序的内存区域sort buffer;</p>
<blockquote>
<p>全字段排序：将要查询的内容全部放进sort buffer，更具order by字段进行快排，如果超过sort buffer size，则需要借助临时磁盘文件，进行归并排序；</p>
<p>row id 排序：如果查询内容的每行字节数太大，受sort buffer size限制，如果借用磁盘文件可能数量太多，则采用另一种排序方式,row id排序；   </p>
<p>​				将排序字段和对应的主键放入sort buffer进行排序，之后再根据主键进行一次回表，解决了内存不足问题，但是多了一次磁盘回表操作，因此全字段排序作为默认方式。但是如果是对内存临时表进行排序，回表也不用到磁盘中查，因此采用row id排序。</p>
</blockquote>
<h2 id="随机显示数据"><a href="#随机显示数据" class="headerlink" title="随机显示数据"></a>随机显示数据</h2><p>join</p>
<p>临时表</p>
<h2 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h2><blockquote>
<p>第一范式：每个列都是不可拆分的</p>
<p>第二范式：每个表只做一件事</p>
<p>第三范式：不存在对非主键列的传递依赖</p>
<p>目的：<strong>减少数据耦合</strong></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/8%E5%85%AB%E8%82%A1_Tomcat&amp;Nginx/</url>
    <content><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="什么是web容器？"><a href="#什么是web容器？" class="headerlink" title="什么是web容器？"></a>什么是web容器？</h2><p>早期的HTTP服务器主要用于返回静态资源，如Apache,Nginx服务器都是静态服务器，像浏览器返回静态html,浏览器负责解析html页面；</p>
<p>servlet技术提供了HTTP服务器动态访问应用程序的能力，但是servlet不能独立运行，没有main方法，需要借助容器来运行，如tomcat,jetty等servlet容器，由容器管理servlet。</p>
<p>tomcat就是一个常用的servlet容器，为了方便使用，他也同时具备了HTTP服务器的功能，因此叫做web容器。（tomcat就是一个java程序，servlet由这个java程序创建）</p>
<p>简单来说，tomcat是一个http服务器+servlet容器：</p>
<blockquote>
<p> http服务器：完成网络通信，处理http请求，并返回http响应。具体来说是处理socket连接（解析应用层协议，tcp&#x2F;udp），负责网络IO的字节流与request, response对象的转化。</p>
<p>servlet容器：加载和管理servlet对象。http服务器将请求交给servlet处理，servlet容器将请求分发到具体的servlet，调用service()方法去执行业务代码。</p>
</blockquote>
<blockquote>
<p>一个web容器可以放多个web程序，将程序放在webapps目录下即可；对于一个springmvc项目有一个DispatchServlet，一个web容器中放多个web程序就会有多个servlet。</p>
</blockquote>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Servlet指的是任何实现了Servlet接口的类，由servlet容器创建并管理，用于处理客户端传来的http请求，执行具体的业务代码，再返回响应。最主要的方式是service()方法，具体的业务代码逻辑在service()方法中实现。</p>
<blockquote>
<p>Servlet是一个Java接口，是实现Web技术的核心。我们平时说的Tomcat容器中的servlet是一个实例，由Tomcat容器创建，servlet的核心执行方法是service()，客户端传来的Http请求，会被Tomcat封装成ServletRequest对象，servlet的响应则被封装到ServletResponse对象中，通过这种请求&#x2F;响应模型，来实现客户端与服务端的交互。</p>
</blockquote>
<blockquote>
<p>HttpServlet是一个抽象类，它实现了Servlet接口，对Servlet功能进行了扩展。</p>
</blockquote>
<p>servlet是单例的，在第一次访问的时候被tomcat创建，会出现并发问题，如何解决？</p>
<blockquote>
<ol>
<li>尽量避免使用静态变量和成员变量</li>
<li>如果必须要用，要对静态变量和成员变量线程不安全方法声明锁。</li>
</ol>
</blockquote>
<h2 id="tomcat如何创建servlet的？"><a href="#tomcat如何创建servlet的？" class="headerlink" title="tomcat如何创建servlet的？"></a>tomcat如何创建servlet的？</h2><p>当tomcat容器启动的时候，会读取webapps文件目录下所有web应用的web.xml文件，读取servlet的注册信息。</p>
<p>默认情况当servlet第一次被请求时，通过反射进行实例化，每个servlet是单例的。</p>
<h2 id="SpringMCV中的Servlet"><a href="#SpringMCV中的Servlet" class="headerlink" title="SpringMCV中的Servlet"></a>SpringMCV中的Servlet</h2><p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png" alt="img"></p>
<p>1.客户端的请求先到DispatcherServlet，DispatcherServlet是Servlet接口的一个实现类；</p>
<p>2.通过HandlerMapping，根据uri路径信息寻找Handler(Controller)，找到Handler之后生成适配器HandlerAdapter，DispatcherServlet就能通过适配器执行Handler的方法了；</p>
<p>3.Handler执行完毕，将响应结果返回给DispatcherServlet，web容器再把他封装成response返回给客户端。</p>
<h2 id="Servlet线程池"><a href="#Servlet线程池" class="headerlink" title="Servlet线程池"></a>Servlet线程池</h2><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>用处：1. 做静态服务器 2. 反向代理 3.负载均衡</p>
<p><strong>Nginx</strong>特点是占有内存少， 并发能力强，且Nginx处理静态页面的效率远高于tomcat，分离部署就是通过nginx（或apache等）来处理用户端请求的静态资源，tomcat（或weblogic）处理动态资源，从而达到动静页面访问时由不同的容器来处理。</p>
<h2 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h2><blockquote>
<p>1.做静态web服务器，直接存储原始静态资源；记得使用gzip压缩静态资源，减少网络传输资源。</p>
<p>2.做静态缓存服务器，反向代理原始服务器，缓存原始服务器的静态资源。</p>
</blockquote>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>Nginx能做反向代理服务器。反向代理的“反向”指的是代理的是服务端，客户端传来的请求发送到代理服务器，由代理服务器转发，决定使用哪台原始服务器处理请求。</p>
<p>反向代理向客户端隐藏了原始服务器，nginx配置反向代理，能够实现服务端的负载均衡。</p>
<blockquote>
<p>正向代理：代理的是客户端，一般通过VPN，由VPN代理客户端向服务端发送请求，服务端不知道原始客户端是谁。</p>
</blockquote>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>如果一台服务器，处理不过来客户端发来的请求，一个简单的解决办法就是增加服务器的数量做集群部署，这时需要某种和规则来向服务器集群，均匀的分配请求，这种规则就叫做<strong>负载均衡</strong>策略。</p>
<p>nginx就具备这样一种功能，通过反向代理，实现负载均衡。</p>
<blockquote>
<p>除此之外，nginx还具备<strong>健康检查</strong>（服务器心跳检查）功能，定期向服务器集群的各服务器发送心跳检查请求，来检测是否有服务器处于异常状态。</p>
</blockquote>
<h3 id="Nginx为什么适合做负载均衡？"><a href="#Nginx为什么适合做负载均衡？" class="headerlink" title="Nginx为什么适合做负载均衡？"></a>Nginx为什么适合做负载均衡？</h3><blockquote>
<p>1.nginx属于软件负载均衡，相比于硬件负载均衡，成本更低。一个低配置的服务器就能实现。</p>
<p>2.占用内存低，对高并发友好。Nginx单机支持10万以上的并发连接。</p>
<p>3.自带健康检查（心跳检查）功能</p>
<p>4.支持热部署，可以在不间断服务情况下，升级nginx。</p>
<p>5.支持多种负载均衡策略：轮询，IP哈希，最小连接数。</p>
</blockquote>
<h3 id="Nginx的负载均衡策略"><a href="#Nginx的负载均衡策略" class="headerlink" title="Nginx的负载均衡策略"></a>Nginx的负载均衡策略</h3><ol>
<li><p>轮询（默认方式）</p>
<blockquote>
<p>按照请求的时间顺序向各个服务器分配请求，可以设置权重</p>
</blockquote>
</li>
<li><p>ip哈希</p>
<blockquote>
<p>按照请求的客户端的ip地址进行哈希，来分配请求，可以设置权重;</p>
<p>相同hash的客户端总是会请求到下相同服务器，在一定程度上解决了session不共享的问题。</p>
</blockquote>
</li>
<li><p>最小连接数</p>
<blockquote>
<p>将新的请求分配给当前活跃连接数最少的服务器</p>
</blockquote>
</li>
</ol>
<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>内容分发网络。要给DNS域名解析后台添加CDN解析记录，让用户根据域名解析到原服务器的Ip地址后，不是直接访问原服务器的Ip，而是先访问CDN负载均衡服务器，CDN能够根据请求IP地址来选择分发请求到哪个最近的CDN服务器，CDN服务器有着原服务器的缓存，如果查不到缓存，再一层层查询直到原服务器。</p>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>netty是对NIO网络模型的一种封装，并且对传统NIO模型进行了优化 ，支持多种通信协议（http,websocket）;</p>
<p>netty相比于直接使用jdk自带的NIOapi更加方便，并且性能更好，便于实现多线程reactor模型，很多中间件都用到了netty（zookeeper,rocketMQ,Dubbo）；</p>
<p>目的就是更好的解决提高服务端吞吐量问题，本质上和NIO是相同的；</p>
]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/9%E5%85%AB%E8%82%A1_SptringBoot/</url>
    <content><![CDATA[<h1 id="简单介绍一下Spring，有什么缺点？"><a href="#简单介绍一下Spring，有什么缺点？" class="headerlink" title="简单介绍一下Spring，有什么缺点？"></a>简单介绍一下Spring，有什么缺点？</h1><p>spring是轻量级开发框架，集成了很多模块，如Ioc,Aop等，能够减少重复代码，提高开发效率。</p>
<p>缺点是:需要大量的XML配置文件，比较繁琐。</p>
<h1 id="为什么要有SpringBoot？"><a href="#为什么要有SpringBoot？" class="headerlink" title="为什么要有SpringBoot？"></a>为什么要有SpringBoot？</h1><p>SpringBoot旨在减少配置文件，方便Spring框架开发。</p>
<h1 id="Spring-boot-starters是什么？"><a href="#Spring-boot-starters是什么？" class="headerlink" title="Spring-boot-starters是什么？"></a>Spring-boot-starters是什么？</h1><p>Spring-boot-starters是一系列依赖关系的集合，它能够让我们项目的依赖配置更加简单。</p>
<p>在没有Spring-boot-starters之前，开发一个web应用要引入spring-mvc，tomcat,jackson时，要分别配置，还要考虑他们之间的版本支持关系；但是如果使用一个依赖Spring-boot-starter-web就可以将他们集成一体化配置了，里边包含了web开发服务的所有依赖。</p>
<h1 id="Spring支持哪些内嵌web容器"><a href="#Spring支持哪些内嵌web容器" class="headerlink" title="Spring支持哪些内嵌web容器"></a>Spring支持哪些内嵌web容器</h1><p>默认使用tomcat,还可以用jetty【在pom.xml中先移除tomcat，再添加jetty】</p>
<h1 id="介绍一下-SpringBootApplication注解"><a href="#介绍一下-SpringBootApplication注解" class="headerlink" title="介绍一下@SpringBootApplication注解"></a>介绍一下@SpringBootApplication注解</h1><p>@SpringBootApplication是项目启动注解，他可以看作@EnableAutoConfiguration @ComponentScan @Configration注解的集合。</p>
<blockquote>
<p>@EnableAutoConfiguration: 启用springboot的自动配置功能</p>
<p>@ComponentScan：扫描被@Component（@Controller）等注解注释的类，将他们以bean的形式注入到ioc容器。</p>
<p>​				@ComponentScan默认扫描路径为同级包及其子包；</p>
<p>@Configration允许在上下文中注入额外的bean和其他配置类</p>
</blockquote>
<h1 id="开发RESTful-Web服务常用的注解有哪些？"><a href="#开发RESTful-Web服务常用的注解有哪些？" class="headerlink" title="开发RESTful Web服务常用的注解有哪些？"></a>开发RESTful Web服务常用的注解有哪些？</h1><h2 id="Spring-Bean相关"><a href="#Spring-Bean相关" class="headerlink" title="Spring Bean相关"></a>Spring Bean相关</h2><h3 id="标记为ioc容器管理"><a href="#标记为ioc容器管理" class="headerlink" title="标记为ioc容器管理"></a>标记为ioc容器管理</h3><ul>
<li>@Component @Repository @Service @Controller</li>
</ul>
<h3 id="装配bean"><a href="#装配bean" class="headerlink" title="装配bean"></a>装配bean</h3><ul>
<li>@Autowired @Resource</li>
</ul>
<h3 id="HTTP请求类型"><a href="#HTTP请求类型" class="headerlink" title="HTTP请求类型"></a>HTTP请求类型</h3><ul>
<li>@GetMapping @PostMapping @PutMapping @DeleteMapping</li>
</ul>
<h3 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h3><blockquote>
<p>@RequestParam 用于?传参</p>
<p>@PathVariable用于url路径传参</p>
<p>@RequestBody用于读取Request请求的body部分以json格式传递的数据，将json字符串解析成java对象。</p>
</blockquote>
<blockquote>
<p>一个请求方法只可以有一个@RequestBody，但是可以有多个@RequestParam，@PathVariable</p>
</blockquote>
<blockquote>
<p>@RequestParam，@PathVariable通常用于get请求，get请求一般不用于传递json，硬传递的话要在url中添加json字符串，但是Url有长度限制。</p>
<p>@RequestBody多用于post,put,delete请求，传递json</p>
</blockquote>
<h1 id="Springboot常用的两种配置文件"><a href="#Springboot常用的两种配置文件" class="headerlink" title="Springboot常用的两种配置文件"></a>Springboot常用的两种配置文件</h1><p>properties文件和yml文件。yml配置更加简单，看起来更有层次性（冒号后边的空格不要忘记）</p>
<p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息</p>
<h1 id="Springboot后端请求参数验证"><a href="#Springboot后端请求参数验证" class="headerlink" title="Springboot后端请求参数验证"></a>Springboot后端请求参数验证</h1><p>即使前端做了请求参数验证，后端还是要进行参数验证，为了避免用户绕过浏览器通过http工具请求违法数据。</p>
<blockquote>
<p>对于requestbody请求参数，传入表单类通过框架注解进行参数限制，web方法请求参数前加@Valid</p>
</blockquote>
<blockquote>
<p>对于RequestParam和PathVariable请求参数，请求方法加@valid和@Notnull等限制，在controller类上必须加@Validated注解</p>
</blockquote>
<h1 id="SpringBoot全局异常处理"><a href="#SpringBoot全局异常处理" class="headerlink" title="SpringBoot全局异常处理"></a>SpringBoot全局异常处理</h1><p>通过@ControllerAdvice注解 + @ResponseBody注解修饰配置类，@ExceptionHandler设置特定异常的处理方式。</p>
<p>通过AOP实现，@ControllerAdvice注解会为controller类织入抛异常通知，具体的执行要看下边的配置。</p>
<h1 id="SpringBoot定时任务"><a href="#SpringBoot定时任务" class="headerlink" title="SpringBoot定时任务"></a>SpringBoot定时任务</h1><p>通过@Scheduled修饰定时方法，并在启动类@EnableScheduling</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/06/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/6%E5%85%AB%E8%82%A1_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><ol>
<li>开闭原则<br> 对扩展开放，对修改关闭。  为了程序的可扩展性好！</li>
<li>里氏代换原则<br> 任何基类可以出现的地方，子类一定可以出现。是继承复用的基石，面向对象设计采用的就是这种思想。这是对开闭原则的补充。</li>
<li>单一职责原则<br> 一个类，一个接口只负责一项职责</li>
<li>依赖倒转原则<br> 指的是面向接口的编程方式，要依赖于抽象而不依赖于具体</li>
<li>接口隔离原则<br> 使用多个隔离的接口，比使用单个接口要好</li>
<li>迪米特原则<br> （最少知道原则）减少类之间的耦合</li>
</ol>
<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1 创建型模式"></a>1 创建型模式</h2><p>隐藏创建对象的逻辑，不是使用new关键字来创建对象。</p>
<blockquote>
<p>单例模式，工厂模式，抽象工厂模式，建造者模式。。。</p>
</blockquote>
<h2 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2 结构型模式"></a>2 结构型模式</h2><p>关注<code>类和对象的组合，即如何将类或对象按某种布局组成更大的结构</code></p>
<blockquote>
<p>适配器模式，代理模式，享元模式。。。</p>
</blockquote>
<h2 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3 行为型模式"></a>3 行为型模式</h2><p>该模式用于<code>描述类或对象之间怎样通信、协作共同完成任务，以及怎样分配职责</code>。</p>
<blockquote>
<p>访问者模式，责任链模式。。。</p>
</blockquote>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>保证某个类只有一个实例对象，主要防止一个全局使用的类频繁地创建与销毁它的实例。</p>
<h2 id="1-懒汉式-（线程不安全版）"><a href="#1-懒汉式-（线程不安全版）" class="headerlink" title="1 懒汉式 （线程不安全版）"></a>1 懒汉式 （线程不安全版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-懒汉式-（线程安全版）"><a href="#2-懒汉式-（线程安全版）" class="headerlink" title="2 懒汉式 （线程安全版）"></a>2 懒汉式 （线程安全版）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3 饿汉式"></a>3 饿汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  <span class="comment">//类加载过程保证了线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-双重检查"><a href="#4-双重检查" class="headerlink" title="4 双重检查"></a>4 双重检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;   <span class="comment">//volatile防止指令重排，不加可能导致没生成实例的时候就返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">//第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">//第二次检查</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5 静态内部类"></a>5 静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  <span class="comment">//内部类是延时加载的，在第一次用到它的时候才加载到内存中，实现了lazy loading</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-枚举类"><a href="#6-枚举类" class="headerlink" title="6 枚举类"></a>6 枚举类</h2><p>枚举类在第一次使用到的时候才被加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两种懒汉模式不建议使用：普通懒汉线程不安全，加锁懒汉影响性能；</p>
<p>饿汉：唯一缺点就是即使不使用实例，也会在类加载时创建，不能lazy loading；一般用这个就行了</p>
<p>双重检查：既能lazy loading，又能减少锁的影响；但是实现起来比较复杂</p>
<p>静态内部类：比较完美</p>
<p>枚举类：完美。还能防止反序列化和反射破坏单例。</p>
</blockquote>
<h2 id="单例模式的破坏"><a href="#单例模式的破坏" class="headerlink" title="单例模式的破坏"></a>单例模式的破坏</h2><ol>
<li>反射</li>
<li>序列化与反序列化</li>
</ol>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h2><p>有一个具体的工厂类，生产所有的具体产品类，这些具体产品类通常有一个共同的父类；根据使用者传递的参数不同，创建不同的具体产品实例。</p>
<blockquote>
<p>优点：实现了产品对象创建和使用的解耦；</p>
</blockquote>
<blockquote>
<p>缺点：当使用者需求变了，比如要新增一个产品，就要去工厂类改代码，加else if，不符合开闭原则。不方便扩展，因此简单工厂模式也不在23种设计模式的范围内。</p>
</blockquote>
<h2 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2 工厂方法模式"></a>2 工厂方法模式</h2><p>定义了一个抽象工厂类，能够生产一种抽象产品类；每个具体工厂类与每个具体的产品类一一对应，也就是一个具体工厂类只能生产一种具体产品类；</p>
<blockquote>
<p>好处：便于扩展，一个具体产品类与一个具体工厂类对应，新增产品时不会影响其他产品的代码；</p>
</blockquote>
<blockquote>
<p>缺点：一个具体产品类要对应一个具体的工厂，系统中的类的个数成倍增加，一定程度上增大了系统复杂度。更适用于简单的系统。</p>
</blockquote>
<h2 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3 抽象工厂模式"></a>3 抽象工厂模式</h2><p>定义了一个抽象工厂类，能够生产多种抽象产品类；每个具体工厂类与每种抽象产品类对应，也就是每个具体工厂类生产的是抽象产品，没有细化到具体产品；</p>
<blockquote>
<p> 好处：避免了工厂方法模式在产品较多是要创建许多工厂类的复杂性。</p>
</blockquote>
<blockquote>
<p>缺点：对于新增一个工厂类是方便的，但是新增一个产品等级的时候，需要更改每个工厂的代码。</p>
</blockquote>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式适合创建对象实例时传入参数较多（超过4个），且有些参数是可选的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Computer</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu=builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.ram=builder.ram;</span><br><span class="line">        <span class="built_in">this</span>.usbCount=builder.usbCount;</span><br><span class="line">        <span class="built_in">this</span>.keyboard=builder.keyboard;</span><br><span class="line">        <span class="built_in">this</span>.display=builder.display;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">        <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(String cup,String ram)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu=cup;</span><br><span class="line">            <span class="built_in">this</span>.ram=ram;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setUsbCount</span><span class="params">(<span class="type">int</span> usbCount)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.usbCount = usbCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setKeyboard</span><span class="params">(String keyboard)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.keyboard = keyboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setDisplay</span><span class="params">(String display)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//省略getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Computer computer=<span class="keyword">new</span> <span class="title class_">Computer</span>.Builder(<span class="string">&quot;因特尔&quot;</span>,<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">                .setDisplay(<span class="string">&quot;三星24寸&quot;</span>)</span><br><span class="line">                .setKeyboard(<span class="string">&quot;罗技&quot;</span>)</span><br><span class="line">                .setUsbCount(<span class="number">2</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>

<p>emos项目的R对象应用了这个模式？</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>让两个不兼容的接口，能够一起工作</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>通过代理类的接口，使用被代理类的功能。</p>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>减少对象的创建，如一些池化技术，字符串常量池，线程池，数据库连接池等；还有Integer对于-128~127的对象的缓存。</p>
<p>优点：</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>定义一系列的算法，把他们封装成一个策略类Strategy，使他们能够相互替换，提供给操作策略的上下文类Context进行选择。</p>
<blockquote>
<p> 优点：避免使用大量的条件判断，代码更容易维护</p>
</blockquote>
<blockquote>
<p>缺点：使用的时候要知道所有的策略类，并自行选择</p>
</blockquote>
<h1 id="设计模式的应用"><a href="#设计模式的应用" class="headerlink" title="设计模式的应用"></a>设计模式的应用</h1><p>单例模式</p>
<blockquote>
<p>1.网站计数器：不用每次都刷新到数据库，可以用一个单例对象缓存起来</p>
<p>2.应用程序的日志应用</p>
<p>3.Spring Bean默认都是单例的</p>
</blockquote>
<p>简单工厂模式</p>
<blockquote>
<p>Java的Calender类，通过传入不同参数返回想要的对象</p>
</blockquote>
<p>工厂方法模式</p>
<blockquote>
<p>Collection接口的Iterator的实现，Collection接口的不同实现类得到Iterator对象有自己的方式。</p>
</blockquote>
<p>抽象工厂模式</p>
<blockquote>
<p>Spring框架中的BeanFactory</p>
</blockquote>
<p>代理模式</p>
<blockquote>
<p>Spring AOP</p>
</blockquote>
<p>适配器模式</p>
<blockquote>
<p>Spring MVC适配Controller</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/06/02/%E6%96%B0%E7%A7%91%E5%93%88/</url>
    <content><![CDATA[<h1 id="不合适吧"><a href="#不合适吧" class="headerlink" title="不合适吧"></a>不合适吧</h1><h2 id="好事"><a href="#好事" class="headerlink" title="好事"></a>好事</h2><p><code>leetcode</code></p>
<p><strong>leetcode</strong></p>
<p><img src="data:image/jpeg;base64,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" alt="詹姆斯"></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>的</tag>
        <tag>返回啊</tag>
      </tags>
  </entry>
  <entry>
    <title>新科哈</title>
    <url>/2023/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="7层模型为什么干不过TCP-x2F-IP体系4层模型？"><a href="#7层模型为什么干不过TCP-x2F-IP体系4层模型？" class="headerlink" title="7层模型为什么干不过TCP&#x2F;IP体系4层模型？"></a>7层模型为什么干不过TCP&#x2F;IP体系4层模型？</h1><ul>
<li>制定时OSI专家缺乏实际经验，并且完成标准时缺乏商业驱动力；</li>
<li>层次划分不太合理，有些功能在多个层次重复出现</li>
</ul>
<p>TCP&#x2F;IP四层模型：</p>
<p>​			应用层，传输层，网络层，网络接口层（数据链路层+物理层）</p>
<p>五层理论模型（便于教学）</p>
<span id="more"></span>

<ul>
<li>应用层：定义了两个终端设备上应用程序之间信息交换的格式，从而实现某种特定的网络应用。</li>
<li>传输层：负责向两台终端设备进程之间的通信提供数据传输服务，为应用进程传送应用层报文。</li>
<li>网络层：负责分组网络上不同主机的通讯服务</li>
<li>数据链路层：将网络层下发的IP数据包封装成帧，在相邻节点链路上传输帧 物理层：实现相邻计算机节点之间将数据帧以比特流的方式透明传输，尽可能屏蔽传输介质和物理设备的干扰。</li>
<li>物理层：实现相邻计算机节点之间将数据帧以比特流的方式透明传输，尽可能屏蔽传输介质和物理设备的干扰。</li>
</ul>
<h1 id="网络模型分层的原因？"><a href="#网络模型分层的原因？" class="headerlink" title="网络模型分层的原因？"></a>网络模型分层的原因？</h1><p>对于复杂系统，往往都需要分层， 分层之后每一层只需要专注做一类事情，网络分层也是一样，我认为这样做的好处有以下3点：</p>
<ol>
<li>各层之间相互独立，不需要关注下层如何实现，就像我们平时使用框架开发一个后台程序来说，会分成数据库持久层，业务层service还有前后端数据交互的controller层。上层知道下层提供的接口，进行调用就好。</li>
<li>提高了整体灵活性。每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li>大问题化小 ：分层可以将复杂的网络问题分解为许多较小的问题分而治之，使计算机系统易于设计和标准化。我们进行开发时，也会将系统功能分解成许多更容易解决的小问题，这些小的问题具有更好的边界定义。</li>
</ol>
<blockquote>
<p> “计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.”</p>
</blockquote>
<h1 id="常见的应用层协议？"><a href="#常见的应用层协议？" class="headerlink" title="常见的应用层协议？"></a>常见的应用层协议？</h1><ul>
<li>HTTP：超文本传输协议</li>
</ul>
<blockquote>
<p>主要是为了Web浏览器和Web服务器之间通信而设计的；</p>
</blockquote>
<blockquote>
<p>基于TCP协议，建立连接需要3次握手；目前使用的HTTP大部分是1.1版本，在HTTP1.1中，默认开启Keep-Alive, 表示建立的连接可以在多次请求中复用；</p>
</blockquote>
<blockquote>
<p>HTTP协议是“无状态的”，指对于事务处理没有记忆能力，无法记录客户端用户的状态，意味着如何后续处理需要前面的信息，则必须要重传；一般哦我们通过Session来记录客户端用户的状态。</p>
</blockquote>
<ul>
<li><p>SMTP 邮件传输协议</p>
</li>
<li><p>FTP 文件传输协议</p>
</li>
<li><p>DHCP 动态主机配置协议</p>
</li>
<li><p>DNS 域名解析协议</p>
</li>
<li><p>Telnet 远程登陆协议，通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送。</p>
</li>
<li><p>SSH 安全的网络传输协议，<strong>Telnet</strong> <strong>和</strong> <strong>SSH</strong> <strong>之间的主要区别在于</strong> <strong>SSH</strong> <strong>协议会对传输的数据进行加密保证数据安全性。</strong></p>
</li>
</ul>
<h1 id="TCP-与-UDP-的区别（重要）"><a href="#TCP-与-UDP-的区别（重要）" class="headerlink" title="TCP 与 UDP 的区别（重要）"></a>TCP 与 UDP 的区别（重要）</h1><ol>
<li><strong>是否面向连接</strong> ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong> ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
</ol>
<h1 id="什么时候选择-TCP-什么时候选-UDP"><a href="#什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="什么时候选择 TCP,什么时候选 UDP?"></a>什么时候选择 TCP,什么时候选 UDP?</h1><ol>
<li><p><strong>UDP</strong> <strong>一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大;广播通讯;以及总包量较少的通讯：DHCP DNS</p>
</li>
<li><p><strong>TCP</strong> <strong>用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</p>
</li>
</ol>
<h1 id="使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h1><p>使用TCP协议的应用层协议：</p>
<ol>
<li><strong>HTTP</strong> <strong>协议</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。</li>
<li><strong>HTTPS</strong> <strong>协议</strong> ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li>
<li><strong>FTP</strong> <strong>协议</strong>：文件传输协议 FTP</li>
<li><strong>SMTP</strong> <strong>协议</strong>：简单邮件传输协议</li>
<li><strong>POP3&#x2F;IMAP</strong> <strong>协议</strong>： POP3 和 IMAP 两者都是负责邮件接收的协议。</li>
<li><strong>Telnet</strong> <strong>协议</strong></li>
<li><em>SSH</em>* <strong>协议</strong></li>
</ol>
<p>使用UDP协议的应用层协议：</p>
<ol>
<li>DHCP</li>
<li>DNS</li>
</ol>
<h1 id="TCP-三次握手和四次挥手（非常重要）"><a href="#TCP-三次握手和四次挥手（非常重要）" class="headerlink" title="TCP 三次握手和四次挥手（非常重要）"></a>TCP 三次握手和四次挥手（非常重要）</h1><p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP1.png?raw=true" alt="TCP1.png"></p>
<p>一次握手：客户端发送带有同步标志位SYN的报文（并带有这条报文的序号seq&#x3D;x），然后客户端进入<strong>SYN_SEND</strong> 状态，等待服务器的确认；</p>
<p>二次握手：服务端发送带有同步标志位SYN的确认报文（ACK是确认标志位），并且报文中还包含对一次握手报文的确认序号（x + 1）以及该报文的序号y; 然后服务端进入 <strong>SYN_RECV</strong> 状态</p>
<p>三次握手：客户端发送确认报文ACK，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</p>
<p>【TCP报文为每个字节数据进行了编号seg】</p>
<p>三次握手的目的是建立可靠的通信信道，三次握手的目的是建立可靠的通信信道，必须保证双向</p>
<p>其实三次握手可以拆解成像四次挥手那样，</p>
<p>Client发送同步报文SYN，server返回确认报文ACK client可以确保client à server发送通信正常；</p>
<p>Server发送同步报文SYN, client返回确认报文ACK  server可以确保serveràclient发送通信正常；</p>
<p>显然第二步和第三步可以合并；要保证双向传输的可靠。</p>
<blockquote>
<p>问题的本质是，信道不可靠，为满足“在不可靠信道上可靠地传输信息”，通信双方所需要达成的协议。（三次握手）精辟啊~！</p>
</blockquote>
<h1 id="TCP为什么不是两次握手？"><a href="#TCP为什么不是两次握手？" class="headerlink" title="TCP为什么不是两次握手？"></a>TCP为什么不是两次握手？</h1><p>接下来以3个方面分析三次握手的原因：</p>
<ul>
<li><p><strong>避免历史连接（主要原因）</strong>：如果采用两次握手，server端只要接收到syn报文就要进入连接建立状态，如果由于网络阻塞，client重传了多次同步报文，那么延迟的历史请求报文到达server端后，server也会进入连接建立状态，而client对server发来的确认报文并不理会，造成server端资源浪费；</p>
<p>而三次握手，当server端发来对于历史请求的ack报文后，client会返回带有RST标志位的报文，以此终止历史连接。</p>
</li>
<li><p><strong>三次握手才可以同步双方的初始序列号：</strong></p>
<p>序列号能够保证数据包不重复、不丢弃和按序传输。如果两次握手，只能保证客户端的初始序列号ISN被同步，而不能保证服务端的初始序列号被同步。</p>
</li>
</ul>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>第一次挥手：client发送一个带有终止标志位FIN的报文，用来关闭客户端到服务端的数据传送;</p>
<p>第二次挥手：server收到客户端的FIN后，发送确认报文ACK，通知应用进程该方向数据传输停止；</p>
<p>第三次挥手：server发送带有终止标志位的FIN报文，用来关闭服务端到客户端的数据传送；</p>
<p>第四次挥手：client收到服务端发送的FIN报文，之后发送确认报文ACK，之后进入TIME-WAIT时间等待状态，如果客户端经过2MSL（报文段最长寿命，一个片段在网络中的最大存活时间）一九没有收到server发来的报文，则证明服务端已经关闭连接，随之客户端关闭连接。</p>
<h1 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h1><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<h1 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h1><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h1 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h1><p>因为第四次挥手client发送给server的确认报文ACK可能丢失，server端会超时重传，如果client在发送完ACK之后就直接关闭连接，那么server超时重传的FIN就不会被client接收到。所以2*MSL是为了保证这个FIN的超时重传能被接收。</p>
<h1 id="TCP-如何保证传输的可靠性？"><a href="#TCP-如何保证传输的可靠性？" class="headerlink" title="TCP 如何保证传输的可靠性？"></a>TCP 如何保证传输的可靠性？</h1><p>​    差错检测 超时重传 流量控制  拥塞处理</p>
<h1 id="TCP-如何实现流量控制？"><a href="#TCP-如何实现流量控制？" class="headerlink" title="TCP 如何实现流量控制？"></a>TCP 如何实现流量控制？</h1><p><strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong>如果接收方处理不过来的话，就只能把处理不过来的数据存在 接收缓冲区(Receiving Buffers) 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。</p>
<p><strong>TCP</strong> <strong>利用滑动窗口实现流量控制。发送方有一个发送窗口，接收方有一个接收窗口，</strong> </p>
<p>接收方的确认报文中有已确认接收的字节序号以及接收窗口大小，发送方根据确认报文，进行发送窗口移动和发送窗口大小的调整。</p>
<p>接收方必须有累计确认【累计收到多少个字节就要发送确认报文，确认推迟的时间不应超过0.5秒】和稍带确认机制【接收方在自己有数据要发送时，把确认信息顺便稍带上，稍带确认并不常发生，因为很少同时在两个方向发送数据】</p>
<h1 id="TCP-的拥塞控制是怎么实现的？"><a href="#TCP-的拥塞控制是怎么实现的？" class="headerlink" title="TCP 的拥塞控制是怎么实现的？"></a>TCP 的拥塞控制是怎么实现的？</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫<strong>拥塞</strong>。</p>
<p><strong>拥塞控制</strong>就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP4.png?raw=true" alt="TCP4.png"></p>
<h2 id="拥塞控制与流量控制的区别？"><a href="#拥塞控制与流量控制的区别？" class="headerlink" title="拥塞控制与流量控制的区别？"></a>拥塞控制与流量控制的区别？</h2><p>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>而流量控制是是个端到端的问题，流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<h2 id="TCP如何实现拥塞控制的？"><a href="#TCP如何实现拥塞控制的？" class="headerlink" title="TCP如何实现拥塞控制的？"></a>TCP如何实现拥塞控制的？</h2><p>发送方要维持一个拥塞窗口（cwnd），来衡量网络的拥塞程度，这取决于网络中发生超时重传的次数。发送方让自己的发送窗口取拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>。</p>
<h1 id="ARQ-协议了解吗"><a href="#ARQ-协议了解吗" class="headerlink" title="ARQ 协议了解吗?"></a>ARQ 协议了解吗?</h1><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>
<p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<p><strong>停止等待<strong><strong>ARQ</strong></strong>协议</strong>：发送方发送完一个分组，就停止发送，等待接收的确认ACK</p>
<p><strong>连续<strong><strong>ARQ</strong></strong>协议</strong>：发送方维护一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待确认，接收方采用累计确认的方式。（如果有一个丢失，需要回退N帧的策略，讲窗口起点移动到最后一个确认接收的分组处）</p>
<h1 id="从输入URL-到页面展示到底发生了什么？（非常重要）"><a href="#从输入URL-到页面展示到底发生了什么？（非常重要）" class="headerlink" title="从输入URL 到页面展示到底发生了什么？（非常重要）"></a>从输入URL 到页面展示到底发生了什么？（非常重要）</h1><ol>
<li><p>解析URL </p>
<p>检查URL是否完整合法，确定访问地址</p>
</li>
<li><p>DNS域名解析</p>
<p>先查询本机缓存，没有缓存再查询本地DNS服务器（可能是大学，或者ISP），没有缓存再去查找DNS根服务器（存储着顶级域名），然后查询顶级域名服务器，然后再查低一级的域名服务器…… 迭代查询</p>
<img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS.png?raw=true" alt="DNS.png" style="zoom:50%;" />
</li>
<li><p>如果使用 HTTPS，会在 TCP 与 HTTP 之间多添加一层协议做加密及认证的服务。HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security） 协议，保障了信息的安全。</p>
</li>
<li><p>TCP协议三次握手建立连接</p>
</li>
<li><p>在TCP包头前添加IP信息，生成IP数据报</p>
</li>
<li><p>ARP协议获取对方MAC地址，并讲自己的MAC地址信息封装在帧头帧尾，形成数据帧。</p>
</li>
<li><p>网卡将数字信号转化成电信号传递出去</p>
</li>
<li><p>经过网络中的交换机、路由器，多次转发到达目的主机</p>
</li>
<li><p>目的主机将获取到的数据逐层解析，挨个核对，应用程序接收到HTTP请求报文，处理请求并返回HTTP响应报文，传输结束就通过TCP四次挥手断开连接。</p>
</li>
<li><p>浏览器收到的响应正文，通常包含有HTML,CSS,JS还有图片等文件，再经过浏览器解析渲染，就得到了我们看到的画面。</p>
</li>
</ol>
<h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><p>请求报文：请求行 请求头 请求体 </p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png?raw=true" alt="HTTP请求报文.png"></p>
<p>响应报文：状态行 响应头 响应体</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png?raw=true" alt="HTTP响应报文.png"></p>
<h1 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h1><h2 id="1xx-Informational（信息性状态码）"><a href="#1xx-Informational（信息性状态码）" class="headerlink" title="1xx Informational（信息性状态码）"></a>1xx Informational（信息性状态码）</h2><p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。</p>
<h2 id="2xx-Success（成功状态码）"><a href="#2xx-Success（成功状态码）" class="headerlink" title="2xx Success（成功状态码）"></a>2xx Success（成功状态码）</h2><p>200 OK ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</p>
<p>201 Created ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</p>
<p>202 Accepted ：服务端已经接收到了请求，但是还未处理。</p>
<p>204 No Content ： 服务端已经成功处理了请求，但是没有返回任何内容。</p>
<h2 id="3xx-Redirection（重定向状态码）"><a href="#3xx-Redirection（重定向状态码）" class="headerlink" title="3xx Redirection（重定向状态码）"></a>3xx Redirection（重定向状态码）</h2><p><strong>301 Moved Permanently</strong> ： 资源被永久重定向了。比如你的网站的网址更换了。</p>
<p><strong>302 Found</strong> ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</p>
<p><strong>304 Not Modified</strong> : 如果代理服务器中的文档过期，则代理服务器向原始服务器发起请求，原始服务器给代理服务器的响应为304时，表示代理服务器缓存有效，更新过期时间即可。</p>
<h2 id="4xx-Client-Error（客户端错误状态码）"><a href="#4xx-Client-Error（客户端错误状态码）" class="headerlink" title="4xx Client Error（客户端错误状态码）"></a>4xx Client Error（客户端错误状态码）</h2><p><strong>400 Bad Request</strong> ： 发送的HTTP请求存在问题。比如请求参数不合法、请求方法错误。</p>
<p><strong>401 Unauthorized</strong> ： 未认证却请求需要认证之后才能访问的资源。</p>
<p><strong>403 Forbidden</strong> ：直接拒绝HTTP请求，不处理。一般用来针对非法请求。</p>
<p><strong>404 Not Found</strong> ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</p>
<p><strong>409 Conflict</strong> ： 表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</p>
<h2 id="5xx-Server-Error（服务端错误状态码）"><a href="#5xx-Server-Error（服务端错误状态码）" class="headerlink" title="5xx Server Error（服务端错误状态码）"></a>5xx Server Error（服务端错误状态码）</h2><p><strong>500 Internal Server Error</strong> <strong>：</strong> <strong>服务端出问题了（通常是服务端出<strong><strong>Bug</strong></strong>了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</strong></p>
<p><strong>502 Bad Gateway</strong> <strong>：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</strong></p>
<h1 id="HTTP-和-HTTPS-有什么区别？（重要）"><a href="#HTTP-和-HTTPS-有什么区别？（重要）" class="headerlink" title="HTTP 和 HTTPS 有什么区别？（重要）"></a>HTTP 和 HTTPS 有什么区别？（重要）</h1><ul>
<li><p><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</p>
</li>
<li><p><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 http:&#x2F;&#x2F;，HTTPS 的 URL 前缀是 https:&#x2F;&#x2F;。</p>
</li>
<li><p><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>
</li>
<li><p>HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用<strong>服务器方的证书</strong>进行了<strong>非对称加密</strong>。【保证对称密钥在网络传输的安全性】所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。、</p>
</li>
<li><p><strong>数字证书</strong>：HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ul>
<p>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式： </p>
<ul>
<li><p>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</p>
</li>
<li><p>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
</li>
<li><p>采用「混合加密」的方式的原因： 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但 速度慢。</p>
</li>
</ul>
<h1 id="HTTP-1-0-和-HTTP-1-1-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-有什么区别？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 有什么区别？"></a>HTTP 1.0 和 HTTP 1.1 有什么区别？</h1><ul>
<li><p><strong>连接方式</strong> <strong>:</strong> HTTP 1.0 为TCP短连接，HTTP 1.1 支持TCP长连接。</p>
</li>
<li><p><strong>状态响应码</strong> : HTTP&#x2F;1.1中新加入了大量的状态码</p>
</li>
<li><p><strong>Host****字段</strong> <strong>:</strong> HTTP&#x2F;1.1在请求头中加入了Host字段。</p>
</li>
<li><p><strong>支持管道（<strong><strong>pipeline</strong></strong>）网络传输</strong>：HTTP1.1只要第一个请求发出去了，不必等其回来，就可以发第二个请求 出去，可以减少整体的响应时间。</p>
</li>
</ul>
<h1 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h1><p>http是无状态协议，也就是说客户端对于每个http请求，是不知道哪个客户端发起的。</p>
<p>这就意味着每次用户请求都要进行用户认证。</p>
<p>解决方法有：</p>
<p><strong>Cookie:</strong> </p>
<p>cookie是一种客户端会话技术，每次发起http请求，请求头携带cookie数据，服务端也可以通过在响应头给客户端设置Set-Cookie；通过cookie方式，可以将用户状态（登录信息、及会话期间的其他信息）保存在客户端，客户端请求携带状态信息，以此传递用户状态。</p>
<p>如果用cookie传递信息，容易信息泄露，并且cookie有大小限制。</p>
<p><strong>Session：</strong></p>
<p>​    Session是将用户的会话信息保存在服务端，用一个sessionId来跟踪这个会话信息，sessionId通过cookie方式来和客户端之间进行传递。</p>
<p>​    如果服务端是分布式部署的话，会出现session不共享的问题。</p>
<p><strong>Token：</strong></p>
<p>​    Token与session的流程差不多，区别是token是用保存在redis中的，token一般是一个随机字符串（UUID）作为key，value是用户ID（用于识别用户的登录信息），并且有一个过期时间，token字符串还要传递给客户端一份，每次请求带着token，如果redis中存在相应的token，就表示认证成功；如果请求没带着token或者redis中没有相应token，则会生成一个新的token字符串，保存在redis一份，传给客户端一份。</p>
<p>​    缺点是每次请求都要查询一次redis，给redis带来压力，还要占用redis的空间。</p>
<p><strong>JWT：</strong></p>
<p>​    Json Web Token，他不像session和token是基于存储和验证的，他是基于解析+验证的；JWT登录流程需要额外的一个认证服务器，客户端发起登录请求时（浏览器没有JWT），会到认证服务器去申请到JWT，然后向web应用服务器发起请求，带着JWT，应用服务器验证JWT，检查登录信息。</p>
<p>​    JWT字符串<strong>组成</strong>：[header].[payload].[signature]</p>
<p>​    header部分和payload部分都是json格式，通过base64编码成字符，</p>
<p>​    signature部分是【base64编码处理后的header和payload字符串和secret拼接起来，然后进行一个单向加密算法加密，生成signature部分】secret是保存在服务器的。</p>
<p>​    header字符串，payload字符串和signature字符串三个部分通过.连接，组成JWT字符串。</p>
<p>​    应用服务器<strong>验证</strong>的时候，通过前两部分header，signature，加上服务器才有的secret，用header保存的加密算法进行加密，比较生成的JWT和传来的是否相同就行了。</p>
<p>​    优点：JWT字节占用小，并且不占用服务器资源。</p>
<h1 id="假如客户端浏览器禁用了cookie，该怎么办？"><a href="#假如客户端浏览器禁用了cookie，该怎么办？" class="headerlink" title="假如客户端浏览器禁用了cookie，该怎么办？"></a>假如客户端浏览器禁用了cookie，该怎么办？</h1><p>SessionId, token ,JWT都可以通过cookie传递，如果cookie被浏览器禁用了，</p>
<p>主要有两种方式：Cookie 与 URL 重写【url?传参】或者将SessionId存储在localStorage&#x2F;sessionStorage</p>
<p>url重写，比如 <a href="http://taobao.com/getitem?sessionid=1wui87htentg&?name=baymax&action=buy">http://taobao.com/getitem?sessionid=1wui87htentg&amp;?name=baymax&amp;action=buy</a></p>
<p>在web开发过程中，cookie是我们常用的功能；最基本的用来存储服务端返回的jsessionid来识别用户，甚至保存其它更多的客户信息。假如客户端浏览器禁用了cookie，</p>
<p>就要通过其他方式， URL 重写或者 将SessionId存储在localStorage&#x2F;sessionStorage，每次发送html请求时带上（html5）。后端项目返回相应给前端，前端解析出token字符串，保存在localStorage&#x2F;sessionStorage【另外，cookie不能跨域，localStorage&#x2F;sessionStorage能跨域】</p>
<h1 id="说一下-GET-和-POST-的区别？"><a href="#说一下-GET-和-POST-的区别？" class="headerlink" title="说一下 GET 和 POST 的区别？"></a>说一下 GET 和 POST 的区别？</h1><p>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等，Get请求不带有请求体。</p>
<p>而 POST 方法可以向指定的资源提交数据，我们通常使用json格式将数据放在HTTP请求报文的body里面。</p>
<h1 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h1><p>GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。</p>
<p>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据 就会创建多个资源，所以不是幂等的。</p>
<h1 id="ARP协议了解吗？"><a href="#ARP协议了解吗？" class="headerlink" title="ARP协议了解吗？"></a>ARP协议了解吗？</h1><p>​    ARP协议能够将IP地址解析成对应的MAC地址，每个主机或者路由器有一个ARP高速缓存表，缓存着IP地址和MAC地址的对应关系。如果缓存未命中，那么则广播发送ARP报文，请求指定IP的MAC地址。</p>
<h1 id="NAT-x2F-NAPT协议了解吗？"><a href="#NAT-x2F-NAPT协议了解吗？" class="headerlink" title="NAT&#x2F;NAPT协议了解吗？"></a>NAT&#x2F;NAPT协议了解吗？</h1><p>网络地址转换协议，能够解决公网Ip不足的问题，NAPT协议能够使多个内网Ip公用一个公网Ip，NAPT路由器维护一个映射关系表，能够将内网ip：端口号映射成公网Ip：端口号，用这个公网Ip：端口号去访问网络资源。</p>
<p>Ping命令过程？</p>
<p>Ping命令基于ICMP协议，ICMP是网络控制报文协议。</p>
<p>ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。</p>
<p>Ping命令发送方向目的方发送icmp报文，目的主机接收到该报文，返回响应报文。如果目的方不可达， 则由路由器返回差错报文。</p>
<h1 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h1><p>Base64是用64个可打印字符表示二进制数据的一种编码方式。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li><p>将每三个字节的二进制数据，一共24位，分成4组，每组6位，在每个6位数据前补两个0，一共就变成了4个字节，再根据每个字节的值去查表找到对应的字符。</p>
</li>
<li><p>那么由于原有数据可能不是三个字节的倍数，转化过程中就可能出现：1.每个拆分成的数据不足6位，那么我们就在后面补0，然后再根据值去查表；2.还会导致拆分的总个数不足4个，那么后面空着的就直接补“&#x3D;”就好。</p>
</li>
<li><p><img src="https://github.com/WayV5/imgs/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/base64.png?raw=true" alt="base64.png"></p>
</li>
</ul>
<h2 id="Base64用途"><a href="#Base64用途" class="headerlink" title="Base64用途"></a>Base64用途</h2><ul>
<li><p><strong>二进制存储文件的传输：</strong></p>
<p>因为HTTP1.1是文本传输协议，而对于图片、视频这些二进制存储的文件，在网络传输要转换成文本格式才能传输</p>
</li>
<li><p><strong>特殊字符引发的解析问题：</strong></p>
<p> Get请求方法，要把请求参数拼接在url后边，当出现空格的时候就会导致访问链接解析异常；</p>
<p>还有一些特殊字符会导致http报文格式解析错误；</p>
</li>
</ul>
]]></content>
  </entry>
</search>
