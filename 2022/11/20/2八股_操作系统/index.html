<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="什么是操作系统？​    操作系统是在计算机上运行的最基本的软件程序，它位于计算机硬件资源和应用程序之间，能够管理计算机的硬件资源和应用程序，为应用程序提供服务。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2022/11/20/2%E5%85%AB%E8%82%A1_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Wei&#39;s Blog">
<meta property="og:description" content="什么是操作系统？​    操作系统是在计算机上运行的最基本的软件程序，它位于计算机硬件资源和应用程序之间，能够管理计算机的硬件资源和应用程序，为应用程序提供服务。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/WayV5/imgs/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/p1.png?raw=true">
<meta property="og:image" content="https://github.com/WayV5/imgs/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/p2.png?raw=true">
<meta property="article:published_time" content="2022-11-20T12:15:00.000Z">
<meta property="article:modified_time" content="2023-06-18T03:38:12.614Z">
<meta property="article:author" content="Wei">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/WayV5/imgs/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/p1.png?raw=true">

<link rel="canonical" href="http://example.com/2022/11/20/2%E5%85%AB%E8%82%A1_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | Wei's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wei's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/20/2%E5%85%AB%E8%82%A1_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/naruto.jpg">
      <meta itemprop="name" content="Wei">
      <meta itemprop="description" content="张弛有度，沉浮于心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-20 20:15:00" itemprop="dateCreated datePublished" datetime="2022-11-20T20:15:00+08:00">2022-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-18 11:38:12" itemprop="dateModified" datetime="2023-06-18T11:38:12+08:00">2023-06-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h1><p>​    操作系统是在计算机上运行的最基本的软件程序，它位于计算机硬件资源和应用程序之间，能够管理计算机的硬件资源和应用程序，为应用程序提供服务。</p>
<span id="more"></span>

<h1 id="系统调用？"><a href="#系统调用？" class="headerlink" title="系统调用？"></a>系统调用？</h1><p>​    首先要提到进程在操作系统上运行的两个等级  用户态和核心态，</p>
<p>用户态只能直接读取用户程序的数据，特权较低，想要运行涉及到资源的相关操作，比如进程调度，文件管理，内存管理这些，必须通过操作系统执行内核代码去执行，操作系统为用户进程提供了使用接口，用户进程调用，转交给操作系统去执行这些特权指令，此时状态称为内核态，这个调用接口称作系统调用。</p>
<p>​    这样做的好处是：具有用户态和内核态的区分，保证了计算机系统的</p>
<p>​    <strong>安全性</strong>：如果用户能直接操控系统资源，有些指令是很危险的，安全性难以保证。</p>
<p>​    <strong>性能</strong>：如果用户直接访问共享资源，势必会产生冲突，影响执行效率。</p>
<p>​    系统调用会发生进程的用户态和核心态之间的转换，转换时需要保存现场，恢复现场，状态的保存和恢复都要在CPU寄存器，浪费CPU资源（空间资源、时间资源）。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程?"></a>进程?</h1><p>​    进程实体由 PCB 程序段 数据段 三部分组成。</p>
<p>   <strong>PCB</strong>：进程控制块，是操作系统跟踪、管理进程的一个数据结构，PCB在操作系统内核区储存。组成有：</p>
<ul>
<li>进程描述信息：PID UID</li>
<li>进程控制和管理信息：如当前进程状态，进程优先级等</li>
<li>资源分配清单：程序段指针，数据段指针，键盘，鼠标。。。</li>
<li>CPU相关信息：保存当前CPU寄存器中的值，用于记录和恢复进程<strong>上下文切换</strong>时的状态。</li>
</ul>
<h2 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态?"></a>进程有哪几种状态?</h2><ul>
<li>创建状态(new) ：进程正在被创建，尚未到就绪状态。</li>
<li>就绪状态(ready) ：进程获得了除了CPU之外的一切所需资源，一旦得到CPU时间片即可运行。</li>
<li>运行状态(running) ：进程正在CPU上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li>阻塞状态(waiting)：由于进程缺少某种资源或等待某件事情而进入的状态</li>
<li>结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<p>阻塞态的进程占⽤着物理内存，在<strong>虚拟内存管理</strong>的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换⼊到物理内存。</p>
<p>挂起态：新的状态，描述进程没有占⽤实际的物理内存空间的情况，这个状态就是挂起状态</p>
<p>阻塞挂起状态： 进程在外存（硬盘）并等待某个事件的出现</p>
<p>就绪挂起状态： 进程在外存（硬盘），但只要进⼊内存，马上运行</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/p1.png?raw=true" alt="p1.png"></p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度?"></a>进程调度?</h2><p>进程调度就是按照某种算法，为处于就绪队列中的进程分配CPU资源的方式。</p>
<p>进程调度算法有以下几种：</p>
<p>​    早期批处理系统：</p>
<ol>
<li><p><strong>先来先服务：非抢占式</strong>（进程主动放弃CPU，正常&#x2F;异常完成，或主动阻塞[请求IO]）。按照进程请求CPU的顺序。有利于长作业，不利于短作业。</p>
</li>
<li><p><strong>短作业优先：默认非抢占式（也有抢占式版本）</strong>。按照估计出的进程运行时间来排队，事件短的排在前边。如果一直有短作业请求，那么长作业会产生<strong>饥饿</strong>。</p>
</li>
<li><p><strong>高响应比优先：非抢占式</strong>。响应比&#x3D;（等待时间+进程作业时间）&#x2F;进程作业时间。响应比大的排在前边。</p>
</li>
</ol>
<p>​    交互式系统：</p>
<ol>
<li><p><strong>时间片轮转：抢占式（定时中断）</strong>。为每个进程分配同样长的时间片。</p>
</li>
<li><p><strong>优先级调度算法：</strong>抢占、非抢占式都有。为每个进程分配⼀个优先级，按优先级进⾏调度。</p>
</li>
<li><p><strong>多级反馈队列：抢占式。</strong>设置多个队列，各级队列优先级从高到低，时间片长度从小到大。一个进程如果时间片用完了还没执行完，那么就会被分到下一个队列。【平衡优秀，但是可能会造成饥饿】</p>
</li>
</ol>
<h2 id="进程通信？"><a href="#进程通信？" class="headerlink" title="进程通信？"></a>进程通信？</h2><p><strong>同一主机间进程通信</strong></p>
<ol>
<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：半双工，先进先出，位于内存中。只能用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Named Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道，可以实现本机<strong>任意</strong>两个进程通信。有名管道以<strong>磁盘文件</strong>的方式存在。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：<strong>消息队列存放在内核</strong>中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息<strong>不一定要以先进先出</strong>的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是解决<strong>进程同步</strong>的一种方式，能够解决并发进程对共享数据的访问问题。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
</ol>
<p><strong>不同主机间进程通信</strong></p>
<ol>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h2 id="进程同步？"><a href="#进程同步？" class="headerlink" title="进程同步？"></a>进程同步？</h2><p>并发执行的进程之间访问共享资源时，可能会发生冲突，那么如何协调并发执行的进程之间对资源的使用，就叫做进程同步。</p>
<p>操作系统一般有下面三种线程同步的方式：</p>
<ol>
<li><strong>互斥量(Mutex)：又叫互斥锁，</strong>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，信号量其实就是一个变量，能够表示系统中某种资源的数量，可根据操作信号量值的结果判断是否对公共资源具有访问的权限。</li>
<li><strong>事件(Event)</strong> :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<h2 id="僵尸进程和孤儿进程？"><a href="#僵尸进程和孤儿进程？" class="headerlink" title="僵尸进程和孤儿进程？"></a>僵尸进程和孤儿进程？</h2><p>Linux 系统中，子进程通常是通过fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。</p>
<ul>
<li><p>僵尸进程：任何⼀个⼦进程(init除外)在exit()之后，并⾮马上就消失掉，⽽是留下⼀个称为僵⼫进程 (Zombie)的数据结构，包含进程的PCB信息，以便父进程得到子进程的状态信息（redis用持久化生成rdb文件就是用的fork一个子线程进行的），父进程使用wait()或waitpid()系统调用才能释放子进程的PCB。父进程长时间不使用wait()或waitpid()就会留下僵尸进程。</p>
</li>
<li><p>孤儿进程：父进程已经结束，子进程还在执行。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。解决方法为：操作系统有一个进程号为1的init进程，操作系统会把孤儿进程的父进程设置为init进程，由init进程来回收孤儿进程的资源。</p>
</li>
</ul>
<h2 id="死锁？"><a href="#死锁？" class="headerlink" title="死锁？"></a>死锁？</h2><p>一个进程集合中的每一个进程，都在等待其他进程执行某件事情，而产生的同时被阻塞的现象。</p>
<h3 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h3><ol>
<li><p><strong>互斥</strong>：造成进程死锁的资源必须为互斥资源，在一个时刻只能被一个进程使用。资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</p>
</li>
<li><p><strong>不可抢占</strong>：已经分配给⼀个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放</p>
</li>
<li><p><strong>占有且等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</p>
</li>
<li><p><strong>循环等待</strong>：有一组等待进程 {P0, P1,…, Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。</p>
</li>
</ol>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防死锁，避免死锁，死锁的检测和解除</strong>。</p>
<ol>
<li><p><strong>预防死锁</strong> ：想办法采用某种策略，能够使产生死锁的必要条件被破坏。</p>
</li>
<li><p><strong>避免死锁 ：银行家算法，</strong>在系统分配资源之前，根据当前资源使用情况进行判断，看分配之后是否会进入不安全状态，来判断是否分配资源。</p>
</li>
<li><p><strong>死锁的检测和解除</strong>：</p>
</li>
</ol>
<blockquote>
<p>检测：有向图来记录资源分配，检测有向图中是否存在环，来判断是否死锁。</p>
<p> 恢复: (1) 利用抢占恢复  ： 强行将某进程挂起</p>
<p>（2）利用回滚恢复  ：将某一进程回滚到不发生死锁的状态</p>
<p>（3）强行杀死某一进程</p>
</blockquote>
<h2 id="Java如何排查死锁"><a href="#Java如何排查死锁" class="headerlink" title="Java如何排查死锁"></a>Java如何排查死锁</h2><ol>
<li><p>先看日志</p>
</li>
<li><p>再看堆栈信息：</p>
<ol>
<li><p>jps -l 查看全部线程信息</p>
</li>
<li><p>jstack + 线程号 ：查看堆栈信息</p>
</li>
</ol>
</li>
</ol>
<h3 id="能写一个模拟产生死锁的代码吗？"><a href="#能写一个模拟产生死锁的代码吗？" class="headerlink" title="能写一个模拟产生死锁的代码吗？"></a>能写一个模拟产生死锁的代码吗？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="线程"><a href="#线程" class="headerlink" title="线程?"></a>线程?</h2><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul>
<li><p>进程是操作系统进⾏<strong>资源</strong>调度和分配的基本单位，而线程是最小的执行单位。</p>
</li>
<li><p>一个进程在运行过程中可以产生多个线程，线程更加轻量化：</p>
</li>
</ul>
<blockquote>
<p>线程共享进程的资源（内存空间、网络连接、文件句柄），因此<strong>创建和终止</strong>的时间更快；</p>
<p>线程的切换仅涉及到少量的寄存器和栈区，因此线程<strong>上下文切换</strong>的速度更快；</p>
<p>线程天生共享了进程的大多数资源，因此<strong>线程间通信</strong>效率更高。</p>
</blockquote>
<h3 id="多线程的好处？"><a href="#多线程的好处？" class="headerlink" title="多线程的好处？"></a>多线程的好处？</h3><p>​    线程比进程的开销小，创建和终止的速度快，上下文切换的速度也快，有些应用从功能上要同时发生多个活动，分解成多个线程执行，可以简化模型，加快执行效率；</p>
<h1 id="内存？"><a href="#内存？" class="headerlink" title="内存？"></a>内存？</h1><h2 id="用户代码到内存中的流程"><a href="#用户代码到内存中的流程" class="headerlink" title="用户代码到内存中的流程"></a>用户代码到内存中的流程</h2><p>程序代码编写 -&gt; 编译 -&gt; 链接 -&gt;装入</p>
<p>链接：编译出的机器代码都有各自独立的逻辑地址，链接就是整合他们的逻辑地址，形成一个具有统一逻辑地址的可执行文件。</p>
<blockquote>
<ol>
<li>静态链接</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ol>
</blockquote>
<p>装入：将可执行文件放入内存</p>
<blockquote>
<ol>
<li>绝对装入</li>
<li>静态重定位装入</li>
<li>动态运行时装入：重定位寄存器</li>
</ol>
</blockquote>
<h2 id="局部性原理？"><a href="#局部性原理？" class="headerlink" title="局部性原理？"></a>局部性原理？</h2><p>​    局部性原理是计算机程序运行所呈现出的一种局部性规律，分为时间局部性和空间局部性。</p>
<ul>
<li><p>时间局部性：执行了一条指令，那么这条指令很可能很快会被再次被执行；某个数据被访问过，这个数据很可能很快被再次被访问（由于存在大量循环）</p>
</li>
<li><p>空间局部性：一个程序访问了一个存储单元，在不久时间内，附近的存储单元很可能被访问。（因为数据存放形式大多是连续的）</p>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理要做什么"><a href="#内存管理要做什么" class="headerlink" title="内存管理要做什么"></a>内存管理要做什么</h3><ul>
<li>内存空间的分配与回收</li>
<li>地址转换：装入时完成逻辑地址到物理地址的转换</li>
<li>内存空间的扩展：覆盖、交换、虚拟内存</li>
<li>存储保护：每个用户进程只能访问各自的内存地址</li>
</ul>
<blockquote>
<p>内存管理的方式分为<strong>连续分配</strong>管理方式和<strong>非连续</strong>分配管理方式，连续分配管理方式是指为一个用户程序分配一个连续的内存空间。</p>
</blockquote>
<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a><strong>连续分配</strong>管理方式</h3><p>又有固定分区分配和动态分区分配:</p>
<ol>
<li><p>固定分区分配：是将用户内存空间分为若干个固定大小的分区，每个分区只能运行一个用户程序，会产生<strong>内部碎片，</strong>导致内存利用率低。</p>
</li>
<li><p>动态分区分配：在用户进程装入内存时，根据进程的大小动态分配内存空间。回收再分配时，会产生<strong>外部碎片</strong>，可用”紧凑”的技术来解决，但是“紧凑”的<strong>时间代价</strong>很高。</p>
</li>
</ol>
<h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a><strong>非连续分配</strong>管理方式</h3><p>分为页式分配、段式分配、段页式分配。</p>
<h4 id="页式分配管理"><a href="#页式分配管理" class="headerlink" title="页式分配管理"></a>页式分配管理</h4><ul>
<li><p>将内存采用固定分区分配的方式进行分配，不过每个分区空间更小，称为<strong>页框</strong>。</p>
</li>
<li><p>将进程分成多个部分，每个部分大小与页框相等，称为<strong>页&#x2F;页面</strong>。</p>
</li>
<li><p>那么只有最后一个页有可能产生很小的内部碎片。</p>
</li>
</ul>
<h5 id="页式分配如何得到物理地址？"><a href="#页式分配如何得到物理地址？" class="headerlink" title="页式分配如何得到物理地址？"></a><strong>页式分配如何得到物理地址？</strong></h5><p>将程序页放入内存页框时可以采用离散的方式存放，因此难点在于逻辑地址到物理地址的转换。</p>
<p><strong>页表</strong>记录了页号与页面地址的对应关系，通过页号查询得到页面地址，再结合页内偏移量就能得到实际的物理地址。每个程序的PCB中保存着页表地址的指针。因此程序通过自己的逻辑地址，结合页表，即可确定相应的物理地址。</p>
<blockquote>
<p> <strong>页号</strong> &#x3D; 逻辑地址&#x2F;页面大小；       <strong>页内偏移量</strong> &#x3D; 逻辑地址%页面大小</p>
</blockquote>
<p>当然这是基本的分页管理方式，如果采用的是虚拟内存技术，那么在地址转换过程要更加复杂，页表还要记录页面在外存中的状态，判断页面是否在内存中，（也就是判断是否缺页），进行页面置换，页表项也要动态更新。</p>
<p><img src="https://github.com/WayV5/imgs/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/p2.png?raw=true" alt="p2.png"></p>
<h5 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h5><p>​		快表是为了解决页式管理时，逻辑地址到物理地址转换时，查询页表速度较慢的问题。</p>
<p>​		快表是页表在<strong>高速缓存存储器</strong>Cache中的缓存，当需要查询页表时，先查询快表中的缓存，缓存命中直接返回页面地址，未命中则去查询页表，然后缓存到快表中。</p>
<p>​		由于局部性原理，一个程序访问了一个内存单元，那么这个内存单元附近的内存单元很可能在短时间内被访问，因此很可能查询到的页号是相同的，所以这种缓存机制命中率是很高的，能够很好的提高地址转换效率。</p>
<p>​    	这种操作系统的设计思想在我们开发系统时也经常用到。</p>
<h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><blockquote>
<p>一般用两级页表</p>
</blockquote>
<ul>
<li>单级页表的缺陷是：1. 为了实现逻辑地址到物理地址的快速转换，页表的存放地址是连续的；2. 整个页表需要常驻内存，占用了较大的内存空间；</li>
<li>由于空间局部性原理，一个程序的运行，在一段时间内只需要访问特定的几个页面就可以；</li>
<li>解决方式是采用两级页表，将页表分组，每个分组大小正好是一个页面的大小，然后再用一个页表存储每个分组的地址；</li>
<li>这样每次地址转换只要将需要的页表部分调入内存就可以了。</li>
</ul>
<h4 id="段式分配管理"><a href="#段式分配管理" class="headerlink" title="段式分配管理"></a>段式分配管理</h4><p>​    	分段的实际意义是：将用户程序按照功能和逻辑关系，分成多个段（如MAIN段, 子程序段，数据段等）,以段为单元离散存放在物理内存中。</p>
<p>​    	地址转换方式：段表记录了每个段的段号，段长，以及在物理内存中的基址，然后根据段号+段内偏移量，实现逻辑地址到物理地址的转换。</p>
<p>段式管理和页式管理的区别和共同点：</p>
<ul>
<li>两者的<strong>相同点</strong>是：</li>
</ul>
<p>​		在完成逻辑地址到物理地址转换时，都通过一定映射关系来完成，分页有页表，分段有段表，通过页号段号+偏移量来实现，只不过由于分段长度不是固定的，段表需要额外维护一个段长的字段。（段长对于寻址没有帮助，作用在做越界检查，看段内地址是否大于段长）</p>
<ul>
<li>两者的<strong>主要区别</strong>是：</li>
</ul>
<p>​    	分页是以系统为基准的，系统将内存固定分成了等长的页框，那用户程序就要基于这个标准，被分成一个个页面装入内存；</p>
<p>​    	分段是以用户程序为基准的，根据用户程序的逻辑模块，分成一个个段，长度是不固定的，然后以段为单元分配在系统内存中；这种分段做法的好处是方便进行资源的保护和共享，缺点就是内存利用率低，会产生外部碎片（和连续内存分配中的动态分区分配很像）。</p>
<p>​    	在现代使用虚拟技术的计算机系统上，多采用分页管理。</p>
<h4 id="段页式分配管理"><a href="#段页式分配管理" class="headerlink" title="段页式分配管理"></a>段页式分配管理</h4><p>​    	段页式管理综合分页和分段两种方式，先按照用户程序的逻辑模块分段，然后再将每段分成固定长度的页面，页长由系统决定。</p>
<p>​    	不会产生外部碎片，每段分成最后一页会有较小的内部碎片。</p>
<p>​    	<strong>地址转换</strong>：维护两个表</p>
<p>​		段表记录  段号-段内页数-起始页号</p>
<p>​		页表记录  页号-页基址 </p>
<p>​       根据段号和段内偏移量可算出页号和页内偏移量，根据页号和业内偏移量可知物理地址。</p>
<p>​			a)    段号查表得到起始页号；<br>​			b)   页号 &#x3D; 起始页号 + 段内偏移量&#x2F;页长；<br>​			c)    页内偏移量 &#x3D; 段内偏移量 % 页长；</p>
<h2 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h2><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p>​    早期计算机使用，将内存分为<strong>固定区</strong>和<strong>覆盖区</strong>，固定区存放需要常驻内存的程序模块，对于不会同时装入内存的程序模块，共享某一段覆盖区。实现了内存空间的扩展。</p>
<p>​    缺点：哪些程序段是常驻内存的，哪些可以共享覆盖区的，需要程序员声明，增加了编程负担。</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>​    当内存紧张时，将暂时不具备运行条件的进程换到外存，比如处于阻塞态、就绪态的进程，可以给它换到外存，此时状态叫他挂起态，然后具备运行条件再换入内存。</p>
<p>​    外存的磁盘空间分为<strong>对换区</strong>和<strong>文件区</strong>：</p>
<p>​    <strong>文件区</strong>：用于存放文件，追求存储空间的利用率，离散分布，随机读写；</p>
<p>​    <strong>对换区</strong>：用于存放被换出的进程数据，追究的是换入换出的速度，采用顺序读写的方式，IO速度更快。</p>
<blockquote>
<p>交换技术以<strong>进程</strong>为单位，而虚拟内存是以进程内的<strong>页面</strong>为单位的, 粒度更细。</p>
</blockquote>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h4><p>​    虚拟内存通过一种“数据交换”的方式，将暂时用不到的程序页面放在外存中，在逻辑上扩展了系统的内存空间，是局部性原理的一个重要应用。</p>
<p>​    请求分页管理方式：基本分页管理+虚拟内存。</p>
<h4 id="页缺失是什么意思？"><a href="#页缺失是什么意思？" class="headerlink" title="页缺失是什么意思？"></a>页缺失是什么意思？</h4><p>需要访问的程序页不在内存中，被置换到了外存当中。</p>
<h4 id="页面置换算法有哪些？"><a href="#页面置换算法有哪些？" class="headerlink" title="页面置换算法有哪些？"></a>页面置换算法有哪些？</h4><p>​    页面置换算法是在请求分页管理方式中，当内存块都被占满的情况下，有新的页面要从外存中请求调入时，淘汰当前内存中页面的规则。</p>
<p>页面置换算法性能指标是缺页率。</p>
<p>a)    <strong>最佳置换算法OPT</strong>：每次选择淘汰以后永不访问，或最长时间不被访问的页面。这种算法是最理想的算法，但是由于这个衡量标准只能在上帝视角才知道，因此无法实现。但是可以作为衡量其他算法的一个标准。</p>
<p>b)   <strong>先入先出置换算法FIFO</strong>：维护一个<strong>先进先出队列</strong>，最先进入内存的页面被淘汰。</p>
<p>算法实现简单，但是当为进程分配的内存页增加时，缺页率反而会上升，称为Belady异常（贝拉迪异常）。</p>
<p>c)    <strong>最近最久页面置换算法LRU</strong>（Least Recently Used）：淘汰最近最久没有被使用的页面。页表中记录分配一个字段，记录这个页面没被使用的时间。Mysql里边，当buffer pool满了的时候，淘汰页面用的就是这个算法。</p>
<p>d)   <strong>时钟页面置换算法：</strong>可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/13/1%E5%85%AB%E8%82%A1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="计算机网络">
      <i class="fa fa-chevron-left"></i> 计算机网络
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/12/28/5%E5%85%AB%E8%82%A1_MySQL/" rel="next" title="MySQL">
      MySQL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是操作系统？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">系统调用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">进程?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.</span> <span class="nav-text">进程有哪几种状态?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">3.2.</span> <span class="nav-text">进程调度?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">进程通信？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">进程同步？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="nav-number">3.5.</span> <span class="nav-text">僵尸进程和孤儿进程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">3.6.</span> <span class="nav-text">死锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.6.1.</span> <span class="nav-text">死锁产生的四个必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.2.</span> <span class="nav-text">解决死锁的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%AD%BB%E9%94%81"><span class="nav-number">3.7.</span> <span class="nav-text">Java如何排查死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%BD%E5%86%99%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%8B%9F%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E4%BB%A3%E7%A0%81%E5%90%97%EF%BC%9F"><span class="nav-number">3.7.1.</span> <span class="nav-text">能写一个模拟产生死锁的代码吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.8.</span> <span class="nav-text">线程?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.8.1.</span> <span class="nav-text">线程和进程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">3.8.2.</span> <span class="nav-text">多线程的好处？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">内存？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">用户代码到内存中的流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">局部性原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">4.3.1.</span> <span class="nav-text">内存管理要做什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">连续分配管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.3.</span> <span class="nav-text">非连续分配管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">页式分配管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%88%86%E9%85%8D%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="nav-number">4.3.3.1.1.</span> <span class="nav-text">页式分配如何得到物理地址？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8"><span class="nav-number">4.3.3.1.2.</span> <span class="nav-text">快表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">4.3.3.1.3.</span> <span class="nav-text">多级页表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">段式分配管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86"><span class="nav-number">4.3.3.3.</span> <span class="nav-text">段页式分配管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85"><span class="nav-number">4.4.</span> <span class="nav-text">内存空间的扩充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="nav-number">4.4.1.</span> <span class="nav-text">覆盖技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="nav-number">4.4.2.</span> <span class="nav-text">交换技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">4.4.3.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">什么是虚拟内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E7%BC%BA%E5%A4%B1%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">页缺失是什么意思？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">4.4.3.3.</span> <span class="nav-text">页面置换算法有哪些？</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wei"
      src="/images/naruto.jpg">
  <p class="site-author-name" itemprop="name">Wei</p>
  <div class="site-description" itemprop="description">张弛有度，沉浮于心</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/WayV5" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WayV5" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/19946254539@163.com" title="E-Mail → 19946254539@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


<div>
<iframe frameborder="no" border="0" marginwidth="10" marginheight="10" width=281 height=300 src="https://music.163.com/outchain/player?type=0&id=8456542318&auto=1&height=430"></iframe>
</div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wei</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">85k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:18</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7ea6ec0be4737f3a243a',
      clientSecret: '9903476d1463334b299f767fded53e6299c3a4bf',
      repo        : 'gitalk-comment',
      owner       : 'WayV5',
      admin       : [''],
      id          : 'd933cf08111a23e6c505cddf092e9cad',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
