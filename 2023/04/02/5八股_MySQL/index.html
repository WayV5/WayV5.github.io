<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="MySQL逻辑架构1.连接器 管理客户端连接，验证登陆权限 2.缓存查询 对用户的查询内容进行缓存，缓存命中则不必走存储引擎。但是再MySQL8.0之后移除了这一功能，因为：  命中率不高，要求SQL语句要完全相同; 表结构有任何变化，则缓存全部失效。 因此额外开销较大，弊大于利  3.分析器  分析SQL语法，解析SQL语义，知道这个SQL要干嘛  4.优化器  选择索引，表连接顺序，生成执行计">
<meta property="og:type" content="article">
<meta property="og:title" content="新科哈">
<meta property="og:url" content="http://example.com/2023/04/02/5%E5%85%AB%E8%82%A1_MySQL/index.html">
<meta property="og:site_name" content="Wei&#39;s Blog">
<meta property="og:description" content="MySQL逻辑架构1.连接器 管理客户端连接，验证登陆权限 2.缓存查询 对用户的查询内容进行缓存，缓存命中则不必走存储引擎。但是再MySQL8.0之后移除了这一功能，因为：  命中率不高，要求SQL语句要完全相同; 表结构有任何变化，则缓存全部失效。 因此额外开销较大，弊大于利  3.分析器  分析SQL语法，解析SQL语义，知道这个SQL要干嘛  4.优化器  选择索引，表连接顺序，生成执行计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png?wh=1142*639">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png?wh=1142*748">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png?wh=1142*1522">
<meta property="article:published_time" content="2023-04-02T11:42:37.000Z">
<meta property="article:modified_time" content="2023-06-02T11:49:12.686Z">
<meta property="article:author" content="Wei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png?wh=1142*639">

<link rel="canonical" href="http://example.com/2023/04/02/5%E5%85%AB%E8%82%A1_MySQL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>新科哈 | Wei's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wei's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/5%E5%85%AB%E8%82%A1_MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/naruto.jpg">
      <meta itemprop="name" content="Wei">
      <meta itemprop="description" content="张弛有度，沉浮于心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          新科哈
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-02 19:42:37" itemprop="dateCreated datePublished" datetime="2023-04-02T19:42:37+08:00">2023-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-02 19:49:12" itemprop="dateModified" datetime="2023-06-02T19:49:12+08:00">2023-06-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p>1.连接器</p>
<p>管理客户端连接，验证登陆权限</p>
<p>2.缓存查询</p>
<p>对用户的查询内容进行缓存，缓存命中则不必走存储引擎。但是再MySQL8.0之后移除了这一功能，因为：</p>
<ul>
<li>命中率不高，要求SQL语句要完全相同;</li>
<li>表结构有任何变化，则缓存全部失效。</li>
<li>因此额外开销较大，弊大于利</li>
</ul>
<p>3.分析器</p>
<ul>
<li>分析SQL语法，解析SQL语义，知道这个SQL要干嘛</li>
</ul>
<p>4.优化器</p>
<ul>
<li>选择索引，表连接顺序，生成执行计划</li>
</ul>
<p>5.执行器</p>
<ul>
<li>调用存储引擎接口，返回结果</li>
</ul>
<p>6.存储引擎</p>
<ul>
<li>插件式存储引擎，负责数据的读写。</li>
</ul>
<h2 id="一个SQL语句，有几次权限验证？"><a href="#一个SQL语句，有几次权限验证？" class="headerlink" title="一个SQL语句，有几次权限验证？"></a>一个SQL语句，有几次权限验证？</h2><p>3次。</p>
<p>第一次：连接器阶段，验证用户对于数据库的权限；</p>
<p>第二次：分析器解析完SQL语义的时候，有一个precheck, 判断对表有没有这个操作权限；</p>
<p>第三次：执行器阶段，还会有对表的权限的判断。因为执行时可能会涉及到其他表，比如设置了触发器操作。</p>
<h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p>InnoDB和MyISAM的区别</p>
<p>5.5.5版本之后，InnoDB取代MyISAM成为MySQL的默认存储引擎。</p>
<ol>
<li>事务</li>
<li>崩溃恢复</li>
<li>行锁</li>
<li>MVCC</li>
<li>数据文件和索引文件的存储结构</li>
</ol>
<p>​					InnoDB的数据文件存在主键索引树的叶子节点，而MyISAM的数据文件和索引是分开的。</p>
<ol start="6">
<li>外键</li>
</ol>
<p>​					InnoDB是支持外键的，但是外键在阿里巴巴java开发手册里规定，项目生产里，外键禁止使用，要在业务代码里进行约束，外键会对性能带来损耗。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<h2 id="事务的四个性质ACID"><a href="#事务的四个性质ACID" class="headerlink" title="事务的四个性质ACID"></a>事务的四个性质ACID</h2><p>Atomic 原子性</p>
<p>Consistent 一致性</p>
<p>Isolation 隔离性</p>
<p>Durable 持久性</p>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>​		事务隔离的4个级别？</p>
<ol>
<li>读未提交 <strong>READ-UNCOMMITTED</strong> RU ：允许读到未提交的数据</li>
<li>读已提交 <strong>READ-COMMITTED</strong> RC ：事务能读到其他事务已经提交的事务</li>
<li>可重复读 **REPEATABLE-READ **RR ：一个事务内多次读取数据，都和事务的一致性视图一致。</li>
<li>串行化 <strong>SERIALIZABLE</strong> ：事务按照顺序执行，不支持并发事务</li>
</ol>
<p>默认的事务隔离级别是 ：可重复读  REPEATABLE-READ</p>
<h2 id="MySQL事务隔离级别都是基于锁实现的吗？"><a href="#MySQL事务隔离级别都是基于锁实现的吗？" class="headerlink" title="MySQL事务隔离级别都是基于锁实现的吗？"></a>MySQL事务隔离级别都是基于锁实现的吗？</h2><p>串行化隔离级别是通过锁实现的，而可重复读和读已提交级别下，MVCC和锁都有用到，如果是快照读，用的是MVCC，但是两者生成一致性视图的时刻是不同的，如果 是当前读，比如写操作(update insert delete)，或者加锁读（For update &#x2F; lock in share mode）那么是依赖读写锁的。</p>
<h2 id="并发事务带来的问题？"><a href="#并发事务带来的问题？" class="headerlink" title="并发事务带来的问题？"></a>并发事务带来的问题？</h2><ol>
<li><p>脏读：指事务读到了其他事务尚未读到的数据，RU会有脏读现象</p>
</li>
<li><p>不可重复读：不可重复度是指事务中前后两次对同一数据读到的值可能不一致，RU,RC都会有这个现象，可重复读隔离级别解决了这个事情</p>
</li>
<li><p>幻读：指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
</li>
</ol>
<h3 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h3><p>   首先普通的查询是快照读，由于MVCC一致性视图的存在，是不会出现幻读的；</p>
<p>   但是如果是当前读的话，它会加行锁，所以其他事务的update和delete是会被阻塞的，但是Insert是可以插入新纪录的，新纪录是没有行锁的嘛，所以会产生幻读。</p>
<p>   那么为了解决可重复读隔离级别下的幻读问题，MySQL引入了间隙锁，间隙锁能锁住两行记录间的间隙，防止其他事务插入，间隙锁+行锁合成为next-key lock，来解决幻读的问题。</p>
<h3 id="next-key-lock锁的范围"><a href="#next-key-lock锁的范围" class="headerlink" title="next-key lock锁的范围"></a>next-key lock锁的范围</h3><p>范围： 左开右闭的区间，并且只有查询过程中真正访问到的对象才会加锁。</p>
<p>优化：1.如果是唯一索引上的等值查找，那么加锁时next-key lock会退化为行锁；</p>
<p>​			2.如果是非唯一索引上的等值查找，那么向右遍历访问到索引上第一个不符合条件的值时，会退化为间隙锁。</p>
<h2 id="如何对并发事务进行控制？"><a href="#如何对并发事务进行控制？" class="headerlink" title="如何对并发事务进行控制？"></a>如何对并发事务进行控制？</h2><ol>
<li>通过读写锁</li>
<li>MVCC</li>
</ol>
<h2 id="开启事务的指令"><a href="#开启事务的指令" class="headerlink" title="开启事务的指令"></a>开启事务的指令</h2><p>1.显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</p>
<p>2.<set autocommit=1>参数，每次执行语句会自动开启事务和提交事务。</p>
<h2 id="长事务有什么后果？"><a href="#长事务有什么后果？" class="headerlink" title="长事务有什么后果？"></a>长事务有什么后果？</h2><ol>
<li><p>长时间占用锁资源，会影响性能；</p>
</li>
<li><p>会导致主从延迟</p>
</li>
<li><p>还会导致大量的undo log占用存储空间，因为undo log清理的判断依据是，看如果没有比该事务的更早的一致性视图了，才会被清理，所以说长事务还会影响它后面事务的undo log的清理。</p>
</li>
<li><p>长事务还会影响修改表结构，长事务给表加MDL读锁，之后要有修改表结构的操作，会请求MDL写锁，而MDL队列中写锁优先级高于读锁，所以修改表结构的事务后边的CRUD操作也会被阻塞。</p>
</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>Flush tables with read lock (FTWRL)，使整个库都处于一个只读的状态。</p>
<p>使用场景：做全库逻辑备份。逻辑备份时要保持整个过程数据要保持一致性；当然这只适用于不支持事务的存储引擎，对于InnoDB存储引擎来说，可以通过MVCC拿到一致性视图来进行全库备份，而不需要使用全局锁，造成全库只读。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ol>
<li>表锁：表锁是针对表中数据的，读操作加读锁，写操作加写锁；需要显示命令&lt;lock tables … read&#x2F;write&gt;;在没有出现行锁的时候，表锁是控制并发的方式。</li>
<li>meta data lock (MDL): 元数据锁是针对修改表结构的，在修改表结构的时候，会加MDL写锁，CRUD操作的时候加的是MDL读锁，读锁共享；MDL锁是隐式自动加的。</li>
</ol>
<h2 id="如何安全的给小表加字段（或者说修改表结构）？"><a href="#如何安全的给小表加字段（或者说修改表结构）？" class="headerlink" title="如何安全的给小表加字段（或者说修改表结构）？"></a>如何安全的给小表加字段（或者说修改表结构）？</h2><p>​		由于meta data lock (MDL)的存在，如果在修改表结构之前，有一个长事务存在，会占据MDL写锁，此时修改表结构的事务申请MDL写锁会被阻塞，并且由于申请MDL锁的队列是写锁优先的，所以再后面的CRUD操作也会被阻塞。</p>
<p>那么如何安全的修改表结构呢？</p>
<ol>
<li><p>首先要先清理掉长事务，会让后面的修改表结构操作长时间拿不到MDL写锁；</p>
</li>
<li><p>其次是可以给修改表结构的指令加上一个超时时间，保证不会阻塞后续语句太久。</p>
</li>
</ol>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>InnoDB引擎才支持行锁。</p>
<p>普通读是加读锁，是共享锁(S 锁)；增删改操作加的是行锁，是排他锁(X 锁)。</p>
<h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p>事务中的锁是在需要的时候才上锁的，但是要等到事务提交或者回滚了之后才会释放。</p>
<p>所以说事务中容易造成锁冲突的语句尽量放在事务最后，这样可以减少事务时间的锁等待，增加并发度。</p>
<blockquote>
<p>为什么要两阶段锁呢？</p>
<p>如果写操作完事之后没等事务提交就立马释放，那么其他事务如果快照读还好，有一致性视图，但是如果执行当前读的操作时，就会<strong>脏读</strong>了。</p>
</blockquote>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>间隙锁是为了解决幻读的，只有在可重复读的隔离级级别下才有。因为如果只有行锁，那么插入新纪录的时候不会被上锁，在一个事务中，对于同一个范围内的两次查询，后一次的查询可能会出现新的结果，也就是幻读现象。</p>
<p>Next-key lock 临键锁</p>
<p>为了解决幻读现象，就有了next-key lock，行锁+间隙锁结合就叫做next-key lock  </p>
<p>范围： 左开右闭的区间，并且只有查询过程中真正访问到的对象才会加锁。</p>
<p>优化：1.如果是唯一索引上的等值查找，那么加锁时next-key lock会退化为行锁；</p>
<p>​			2.如果是非唯一索引上的等值查找，那么向右遍历访问到索引上第一个不符合条件的值时，会退化为间隙锁。</p>
<h1 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h1><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB；</p>
<p>redo log是循环写的，有两个指针 write pos和check point，分别指向当前写的位置和要擦除的位置。只要redo log被记录了，那么mysql崩溃后，就可根据check point回放，来恢复数据</p>
<img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png?wh=1142*639" alt="img" style="zoom: 67%;" />

<h3 id="redo-log-刷盘时机"><a href="#redo-log-刷盘时机" class="headerlink" title="redo log 刷盘时机"></a>redo log 刷盘时机</h3><p>事务执行过程中，redo log只写到redo log buffer中，但是要在事务提交，执行commit指令时，才</p>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次<strong>事务提交时</strong>，redo log只停留在redo log buffer</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次<strong>事务提交时</strong>都将持久化到磁盘（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次<strong>事务提交时</strong>都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<blockquote>
<p>如果设置为1，只要事务提交，redo log一定落盘成功；如果事务执行期间MySQL挂了或者宕机，那么事务没提交，redo log不记录也正常。</p>
<p>如果设置为0，如果MySQL挂了或者宕机，则会损失1秒中内的数据</p>
<p>如果设置为2，每次事务都会write文件系统的page cache中，那么MySQL挂了不会有数据损失，但是如果宕机了，就会损失1秒内数据。</p>
</blockquote>
<h3 id="没提交的redo-log为什么会从redo-log-buffer-刷新到磁盘？"><a href="#没提交的redo-log为什么会从redo-log-buffer-刷新到磁盘？" class="headerlink" title="没提交的redo log为什么会从redo log buffer 刷新到磁盘？"></a>没提交的redo log为什么会从redo log buffer 刷新到磁盘？</h3><ol>
<li>后台线程每隔一秒的轮询操作，会将redo log buffer同步到磁盘</li>
<li>redo log buffer的内存空间达到总空间的一半时，会将redo log buffer中的内容write到page cache中</li>
<li>并发事务时，多个事务共享一个redo log buffer，如果redo log刷盘时机的参数选为1，那么有一个事务提交时，把整个redo log buffer全部提交，能够实现组提交，减少磁盘IO。【binlog也有组提交机制】</li>
</ol>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。redo log是循环写</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。binlog是追加写。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<h3 id="binlog格式"><a href="#binlog格式" class="headerlink" title="binlog格式"></a>binlog格式</h3><ul>
<li><strong>statement</strong></li>
</ul>
<p>statement格式的Binlog记录的是每个事务的SQL语句，缺点是从库用来同步的时候可能造成主从不一致，如：一个写操作，加了limit，但是可能走了不同的索引，导致主从不一致</p>
<ul>
<li><strong>row</strong></li>
</ul>
<p>row格式binlog的记录对应到每一行，因此不会出现主从数据不一致的情况，但是这种格式的Binlog文件占用空间会比较大。</p>
<ul>
<li><strong>mixed</strong></li>
</ul>
<p>综合以上两种格式，先判断一个SQL语句是否会造成主从不一致，不会的话用statement格式，否则用row格式</p>
<h3 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h3><p>在事务执行过程中，binlog写入内存中的 binlog cache，事务提交的时候才会刷新到磁盘</p>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<p>sync_binlog&#x3D;0 的时候，表示每次提交事务都只 write到page cache，不 fsync到磁盘；</p>
<p>sync_binlog&#x3D;1 的时候，表示每次提交事务都会执行 fsync到磁盘；</p>
<p>sync_binlog&#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p>
<img src="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png?wh=1142*748" alt="img" style="zoom: 50%;" />

<h3 id="为什么Binlog不能实现崩溃恢复？"><a href="#为什么Binlog不能实现崩溃恢复？" class="headerlink" title="为什么Binlog不能实现崩溃恢复？"></a>为什么Binlog不能实现崩溃恢复？</h3><p>我认为主要是因为binlog没有check point指针，binlog和redo log都是WAL机制（预先写日志），redo log在回放数据的时候，根据check point指针，来恢复数据，check point能保证它之前的数据是全部已经落盘的数据;而Binlog没有这样的机制，binlog只能判断事务是否执行完成了，但是由于WAL机制，事务完成了，数据可能还没有刷盘，因此也就无法判断哪些需要恢复。</p>
<h2 id="redo-log和binlog的两阶段提交？"><a href="#redo-log和binlog的两阶段提交？" class="headerlink" title="redo log和binlog的两阶段提交？"></a>redo log和binlog的两阶段提交？</h2><p>目的：保证两份日志文件的一致性。因为binlog会用作创建备库或者恢复临时库（库被误删了），操作是拿到最近一次的整库备份，加上对应时间节点的Binlog进行恢复。如果redo log和binlog不一致，那么就会导致备库与原库不一致。</p>
<img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png?wh=1142*1522" alt="img" style="zoom: 33%;" />

<p>一个更新语句的流程：【上图从写redolog开始都是执行事务提交指令COMMIT后的操作】</p>
<ol>
<li>先看数据是否在内存buffer pool中，不在的话先将数据从磁盘读到内存中；</li>
<li>修改内存中的数据</li>
<li>写redo log，写完之后标记redo log为prepare状态</li>
<li>写binlog</li>
<li>提交事务时（commit指令），将redo log标记为commit状态</li>
</ol>
<blockquote>
<p>如果不采用两阶段提交，那么如果在写两份日志之间发生崩溃，会导致两份日志数据不一致</p>
</blockquote>
<p>为什么binlog不能支持崩溃恢复</p>
<h2 id="mysql崩溃后，如何恢复数据？"><a href="#mysql崩溃后，如何恢复数据？" class="headerlink" title="mysql崩溃后，如何恢复数据？"></a>mysql崩溃后，如何恢复数据？</h2><p>崩溃恢复的时候，会按照顺序从check point开始扫描redo log</p>
<p>如果这条事务的redo log标记为commit状态，则认为该事务有效，进行提交。</p>
<p>如果redo log是prepare状态，这是需要判断binlog是否完整，如果完整就提交事务，不完整就回滚事务。</p>
<blockquote>
<p>如何判断binlog是否完整？</p>
<p>答：一个事务的binlog有格式的，如果是statement格式，完整的Binlog最后会有commit标志，如果是row格式，最后会有一个XID event。</p>
</blockquote>
<blockquote>
<p>一个事务的Binlog 和redo log是如何关联在一起的？</p>
<p>答: 二者有一个公共字段 XID</p>
</blockquote>
<h2 id="MySQL如何保证数据不丢失？"><a href="#MySQL如何保证数据不丢失？" class="headerlink" title="MySQL如何保证数据不丢失？"></a>MySQL如何保证数据不丢失？</h2><blockquote>
<p>mysql通过write-ahead logging WAL 预先写日志机制，内从中数据修改不用马上去刷新磁盘，用redo log和binlog保证数据不丢失，提高mysql的并行能力。</p>
<p>WAL机制主要得益于两个方面：</p>
<ol>
<li>binlog和redo log顺序写，比数据写磁盘时的随机写要快得多；</li>
<li>组提交机制，可以减少了IO次数，提高了IO性能。</li>
</ol>
</blockquote>
<h2 id="MySQL如何保证原子性？"><a href="#MySQL如何保证原子性？" class="headerlink" title="MySQL如何保证原子性？"></a>MySQL如何保证原子性？</h2><p>通过回滚日志，mysql在开启事务之后，每一个sql语句的逆逻辑都会记录在回滚日志中，当事务没执行完，中途出现异常，或者主动通过rollback指令，就会根据回滚日志将数据恢复到事务开启之前的状态。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>回滚日志记录的是我们事务执行的倒序逻辑，1. 用来事务的回滚； 2. MVCC的实现。</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h2 id="一致性视图"><a href="#一致性视图" class="headerlink" title="一致性视图"></a>一致性视图</h2><p>一致性视图相当于给整库拍了一个快照，保存当前的状态，在RC下每执行一个语句会创建一个一致性视图，RR隔离级别下，在事务启动时开启一致性视图，整个事务使用同一个一致性视图。</p>
<p>读提交RC和可重复读RR的一致性视图的区别？</p>
<p>RC隔离级别下的每执行一个语句就会创建一个一致性视图，而RR隔离级别下，是在开启事务的时候创建的，直到事务提交之前一直使用这一个一致性视图。</p>
<h2 id="如何实现可重复读"><a href="#如何实现可重复读" class="headerlink" title="如何实现可重复读"></a>如何实现可重复读</h2><ol>
<li><p>InnoDB存储引擎的为每行数据提供了隐藏字段，其中的事务Id字段记录了更新该行数据的事务Id，用于表示这行数据的版本；</p>
</li>
<li><p>每个事务在开启一致性视图时会创建一个视图数组，用于记录启动事务瞬间正在活跃的所有事务的id；</p>
</li>
<li><p>事务在查询数据时，通过undo log从数据当前值开始向前查找，比对数据的版本号，也就是更新这条记录的事务Id，</p>
<p>a. 如果id比视图数组的低水位小，表示是在开启一致性视图之前创建的，那么这条事务可见；</p>
<p>b. 如果Id比视图数组的高水位大，表示是后创建的视图修改的数据，那么这条事务不可见，继续根据undo log向前查找;</p>
<p>c. 如果id落在视图数组的高水位和低水位之间，如果视图数组中存在该事务Id，那么就是未提交的事务修改的，不可见，如果不存在，就是已提交事务的修改的，是可见的；</p>
</li>
<li><p>就这样根据undo log回滚视图不断查找，直到找到第一个可见数据。</p>
</li>
</ol>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h2><ol>
<li><p>哈希索引</p>
<p> 时间复杂度接近O(1)，结构简单，缺点是只适合等值查找，不支持范围查找，范围查找要走全表扫描。</p>
</li>
<li><p>有序数组<br> 可以二分查找，时间复杂度log(n)，但是插入新数据时，后边的都需要向后移动，成本较高。</p>
</li>
<li><p>二叉搜索树<br> 查找的时间复杂度为log(n)，但是二叉树每层的节点数太少了，树高会很高，每次查找读磁盘次数都会很多，又会减少查询速度 。</p>
</li>
<li><p>N叉树</p>
<p> N叉树的出现就是来解决访问页面过多的问题，以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。</p>
</li>
</ol>
<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><p>采用B+树，是一种平衡 多叉 搜索 树<br>非叶子节点只存放key，而叶子节点存放key和数据，叶子节点通过双向指针形成链表。</p>
<p>B树与B+树有哪些区别？<br>    B树所有节点都能存放key和数据，每个节点之间是独立的，查找时可能走不到叶子节点就结束了;<br>    而B+树的数据只存在在叶子节点，并且通过链表连接，每次查找都要走到叶子节点;</p>
<p>B+树的优点：</p>
<ol>
<li>由于B树每个节点都存储key和数据，导致每个页面内存储的索引更少，整个索引树的树高会更高，查找时需要更多次读磁盘；</li>
<li>范围查询时，B+树查找到两个端点就可以了，然后通过链表的指针进行遍历即可；而B树要遍历更多节点；</li>
</ol>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>聚簇索引：索引结构和数据存放在一起的索引，InnoDB的主键索引就是聚簇索引</p>
<p>非聚簇索引：索引结构和数据是分开存放的，InnoDB的二级索引就是非聚簇索引，叶子节点存储的是主键值。而MyISAM都是非聚簇索引。</p>
<h2 id="单列索引和联合索引"><a href="#单列索引和联合索引" class="headerlink" title="单列索引和联合索引"></a>单列索引和联合索引</h2><p>单列索引：单个字段做索引；  联合索引：多个字段做索引</p>
<h2 id="主键索引与二级索引"><a href="#主键索引与二级索引" class="headerlink" title="主键索引与二级索引"></a>主键索引与二级索引</h2><p>主键索引：一张表只能有一个主键索引，索引字段要满足不能重复，不为null；主键索引叶子节点存储的是数据。</p>
<p>如果没有显示指定主键字段，则InnoDB自动检查看有没有一个字段能满足主键索引的条件，没有的话会创建一个不可见的6Byte的自增主键。</p>
<p>二级索引：一张表可以有多个二级索引，二级索引叶子节点存储的是主键值。通过二级索引查找到主键值之后，需要根据主键值回表，到主键索引查找到对应数据。</p>
<h2 id="索引的三大特性"><a href="#索引的三大特性" class="headerlink" title="索引的三大特性"></a>索引的三大特性</h2><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>当通过非聚簇索引树查询时，在非聚簇索引树上就有想查询的数据时，就没必要回表了，比如：</p>
<ol>
<li>通过某个普通索引，想查询主键ID字段；</li>
<li>或者联合索引，联合索引有最左匹配原则，当想通过索引中左边的字段查询右侧字段的数据时，也不需要回表。</li>
</ol>
<h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><p>在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配。匹配完成或者遇到范围查询（如&gt; &lt; between）无法继续匹配时，匹配结束。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>如果是联合索引，遇到无法继续匹配的情况了，比如范围查找，那么其他查询条件如果在索引中能找到，会先做判断，不满足的就不用回表了，减少回表次数。</p>
<h2 id="怎么给字符串字段加索引？"><a href="#怎么给字符串字段加索引？" class="headerlink" title="怎么给字符串字段加索引？"></a>怎么给字符串字段加索引？</h2><p>场景1：邮箱登录；</p>
<p>给邮箱字段加索引。 <a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#x73;&#x78;&#x79;&#122;&#x40;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#x6d;">&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#x73;&#x78;&#x79;&#122;&#x40;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#x6d;</a>；问题：字段太长，占据空间太大</p>
<p><strong>前缀索引</strong>，取前几个字符做索引，最左匹配原则。使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</p>
<p>前缀索引的问题是会增加一些扫描行数，牺牲了一些匹配精确度。并且前缀索引依赖于区分度。</p>
<p>场景2：身份证号</p>
<p>身份证号的前缀区分度不高；因此可采用</p>
<p><strong>倒序存储</strong> ， 之后再取前6位做前缀索引，每次需要调用reverse函数</p>
<p><strong>添加hash字段</strong>：为表添加一个hash字段，作为索引。每次插入通过哈希函数计算出身份证号的hash值；hash索引的匹配精度高，会增加一个额外字段空间，一般四个字节就够了；可能会哈希冲突，还要和id联合判断是否完全相同，但是冲突几率比较低；</p>
<p>总体来说hash字段索引查询效率要更高一些。地址空间hash字段可能更多，但是如果前缀区分度低，要更长长度，也会增加额外地址空间。</p>
<h2 id="什么时候不走索引（导致索引失效的原因）？"><a href="#什么时候不走索引（导致索引失效的原因）？" class="headerlink" title="什么时候不走索引（导致索引失效的原因）？"></a>什么时候不走索引（导致索引失效的原因）？</h2><ol>
<li>对索引字段进行了函数计算</li>
</ol>
<blockquote>
<p> select * from t where year(date) &#x3D; 2020 索引上有函数运算</p>
<p>select * from t where id+1&#x3D;1000  写成where id &#x3D; 1000 - 1 就行了</p>
</blockquote>
<ol start="2">
<li>隐式类型转换</li>
</ol>
<blockquote>
<p>首先明确，mysql 中 select “10” &gt; 9 ，字符串和数字做比较的话，是将字符串转换成数字。</p>
<p>select * from tradelog where tradeid&#x3D;110717 相当于  select * from tradelog where  CAST(tradid AS signed int) &#x3D; 110717</p>
<p>所以相当于对索引字段进行了隐式的函数计算，会导致不走索引</p>
</blockquote>
<ol start="3">
<li>隐式字符编码转换</li>
</ol>
<blockquote>
<p>如果两个关联表的字符集不同，也可能不走索引；比如表1字符集是utf8mb3，表2字符集是utf8mb4，由于uft8mb4是超集，范围更大，会将utf8mb3字符的字段转换为utf8mb4的字符进行关联比较。</p>
</blockquote>
<h1 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h1><h2 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h2><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h2 id="分库库表"><a href="#分库库表" class="headerlink" title="分库库表"></a>分库库表</h2><h2 id="高可用性和高可靠性"><a href="#高可用性和高可靠性" class="headerlink" title="高可用性和高可靠性"></a>高可用性和高可靠性</h2><h1 id="零散问题"><a href="#零散问题" class="headerlink" title="零散问题"></a>零散问题</h1><h2 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h2><p>对于二级索引树的数据页通常是无序的，每次读取要进行随机磁盘IO，那么为了避免读磁盘，就将对二级索引树的写操作缓存在change buffer中，等下次要访问这个数据页的时候，再将change buffer中的操作执行。</p>
<blockquote>
<p>对于唯一索引，由于每次要进行唯一性检查，所以每次都要读进内存，所以不走change buffer</p>
</blockquote>
<h2 id="刷脏页"><a href="#刷脏页" class="headerlink" title="刷脏页"></a>刷脏页</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>mysql为每个线程分配一个用于排序的内存区域sort buffer;</p>
<blockquote>
<p>全字段排序：将要查询的内容全部放进sort buffer，更具order by字段进行快排，如果超过sort buffer size，则需要借助临时磁盘文件，进行归并排序；</p>
<p>row id 排序：如果查询内容的每行字节数太大，受sort buffer size限制，如果借用磁盘文件可能数量太多，则采用另一种排序方式,row id排序；   </p>
<p>​				将排序字段和对应的主键放入sort buffer进行排序，之后再根据主键进行一次回表，解决了内存不足问题，但是多了一次磁盘回表操作，因此全字段排序作为默认方式。但是如果是对内存临时表进行排序，回表也不用到磁盘中查，因此采用row id排序。</p>
</blockquote>
<h2 id="随机显示数据"><a href="#随机显示数据" class="headerlink" title="随机显示数据"></a>随机显示数据</h2><p>join</p>
<p>临时表</p>
<h2 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h2><blockquote>
<p>第一范式：每个列都是不可拆分的</p>
<p>第二范式：每个表只做一件事</p>
<p>第三范式：不存在对非主键列的传递依赖</p>
<p>目的：<strong>减少数据耦合</strong></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/02/6%E5%85%AB%E8%82%A1_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="prev" title="新科哈">
      <i class="fa fa-chevron-left"></i> 新科哈
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/02/14%E5%85%AB%E8%82%A1_%E9%9B%86%E5%90%88/" rel="next" title="新科哈">
      新科哈 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">MySQL逻辑架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AASQL%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%89%E5%87%A0%E6%AC%A1%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">一个SQL语句，有几次权限验证？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">2.</span> <span class="nav-text">MySQL存储引擎</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">3.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%80%A7%E8%B4%A8ACID"><span class="nav-number">3.1.</span> <span class="nav-text">事务的四个性质ACID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">事务隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E9%83%BD%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">MySQL事务隔离级别都是基于锁实现的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">并发事务带来的问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="nav-number">3.4.1.</span> <span class="nav-text">如何解决幻读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#next-key-lock%E9%94%81%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">3.4.2.</span> <span class="nav-text">next-key lock锁的范围</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="nav-number">3.5.</span> <span class="nav-text">如何对并发事务进行控制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="nav-number">3.6.</span> <span class="nav-text">开启事务的指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E4%BA%8B%E5%8A%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C%EF%BC%9F"><span class="nav-number">3.7.</span> <span class="nav-text">长事务有什么后果？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="nav-number">4.1.</span> <span class="nav-text">全局锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-number">4.2.</span> <span class="nav-text">表级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E7%BB%99%E5%B0%8F%E8%A1%A8%E5%8A%A0%E5%AD%97%E6%AE%B5%EF%BC%88%E6%88%96%E8%80%85%E8%AF%B4%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%89%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">如何安全的给小表加字段（或者说修改表结构）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E9%94%81"><span class="nav-number">4.4.</span> <span class="nav-text">行锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.4.1.</span> <span class="nav-text">两阶段锁协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="nav-number">4.5.</span> <span class="nav-text">间隙锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="nav-number">5.</span> <span class="nav-text">三大日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redo-log"><span class="nav-number">5.1.</span> <span class="nav-text">redo log</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log-%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="nav-number">5.1.1.</span> <span class="nav-text">redo log 刷盘时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%8F%90%E4%BA%A4%E7%9A%84redo-log%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BB%8Eredo-log-buffer-%E5%88%B7%E6%96%B0%E5%88%B0%E7%A3%81%E7%9B%98%EF%BC%9F"><span class="nav-number">5.1.2.</span> <span class="nav-text">没提交的redo log为什么会从redo log buffer 刷新到磁盘？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binlog"><span class="nav-number">5.2.</span> <span class="nav-text">binlog</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.2.1.</span> <span class="nav-text">binlog格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="nav-number">5.2.2.</span> <span class="nav-text">binlog刷盘时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Binlog%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%EF%BC%9F"><span class="nav-number">5.2.3.</span> <span class="nav-text">为什么Binlog不能实现崩溃恢复？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redo-log%E5%92%8Cbinlog%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">redo log和binlog的两阶段提交？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql%E5%B4%A9%E6%BA%83%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">5.4.</span> <span class="nav-text">mysql崩溃后，如何恢复数据？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="nav-number">5.5.</span> <span class="nav-text">MySQL如何保证数据不丢失？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="nav-number">5.6.</span> <span class="nav-text">MySQL如何保证原子性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undo-log"><span class="nav-number">5.7.</span> <span class="nav-text">undo log</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVCC"><span class="nav-number">6.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%86%E5%9B%BE"><span class="nav-number">6.1.</span> <span class="nav-text">一致性视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">6.2.</span> <span class="nav-text">如何实现可重复读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">7.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text">常见的索引模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text">InnoDB索引模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">7.3.</span> <span class="nav-text">聚簇索引和非聚簇索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">7.4.</span> <span class="nav-text">单列索引和联合索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-number">7.5.</span> <span class="nav-text">主键索引与二级索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">7.6.</span> <span class="nav-text">索引的三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="nav-number">7.6.1.</span> <span class="nav-text">索引覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="nav-number">7.6.2.</span> <span class="nav-text">最左匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="nav-number">7.6.3.</span> <span class="nav-text">索引下推</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">7.7.</span> <span class="nav-text">怎么给字符串字段加索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95%EF%BC%88%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%89%EF%BC%9F"><span class="nav-number">7.8.</span> <span class="nav-text">什么时候不走索引（导致索引失效的原因）？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">MySQL性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%A4%87"><span class="nav-number">8.1.</span> <span class="nav-text">主备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">8.2.</span> <span class="nav-text">读写分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%BA%93%E8%A1%A8"><span class="nav-number">8.3.</span> <span class="nav-text">分库库表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">8.4.</span> <span class="nav-text">高可用性和高可靠性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">零散问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#change-buffer"><span class="nav-number">9.1.</span> <span class="nav-text">change buffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%B7%E8%84%8F%E9%A1%B5"><span class="nav-number">9.2.</span> <span class="nav-text">刷脏页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">9.3.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE"><span class="nav-number">9.4.</span> <span class="nav-text">随机显示数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">9.5.</span> <span class="nav-text">数据库设计的三大范式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wei"
      src="/images/naruto.jpg">
  <p class="site-author-name" itemprop="name">Wei</p>
  <div class="site-description" itemprop="description">张弛有度，沉浮于心</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/WayV5" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WayV5" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/19946254539@163.com" title="E-Mail → 19946254539@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wei</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">62k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">56 分钟</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7ea6ec0be4737f3a243a',
      clientSecret: '9903476d1463334b299f767fded53e6299c3a4bf',
      repo        : 'gitalk-comment',
      owner       : 'WayV5',
      admin       : [''],
      id          : '9d3a180a42bc1b76527fd38ab0839e06',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
